[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python for Decision Analysis and Optimization",
    "section": "",
    "text": "1 Welcome\n  \nIn this online book we will learn some elementary Python programming tools, as well as the implementation of (linear) optimization problems in Python.\nTo install Python we will use the Anaconda distribution, which contains all relevant Python software that we will need. In particular, we will use the Spyder editor, or integrated development environment (IDE), to construct our Python programs.\n\n\n\nAnaconda\n\n\nTo solve (linear) optimization problems we will use Gurobi, a state-of-the-art software package for solving optimization problems that is used extensively in businesses and academia. We will use this software within Python.\n\n\n\nGurobi\n\n\nIn the next chapter we describe how you can install the relevant software, after which we explain some Python basics in Chapter 3. In Chapter 4, we will explain how to implement optimization problems in Python and solve them with the Gurobi solver.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome</span>"
    ]
  },
  {
    "objectID": "02-software.html",
    "href": "02-software.html",
    "title": "2  Software",
    "section": "",
    "text": "2.1 Anaconda\nIn this chapter we will learn how to install Python and run our very first command. You are of course also free to use your own Python installation. In that case it is best to check the Gurobi documentation to see how to properly install this program.\nThe easiest way to install Python and the Spyder editor at once is by installing Anaconda, which is a software package that includes Python, Spyder, and various other software applications. In the block below, you can find an outline for installing Anaconda.\nAfter installation, you can see all the newly installed applications using the Anaconda Navigator. You can open the navigator by searching for the Anaconda Navigator in the Start menu (on Windows) or the equivalent on MacOS.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Software</span>"
    ]
  },
  {
    "objectID": "02-software.html#anaconda",
    "href": "02-software.html#anaconda",
    "title": "2  Software",
    "section": "",
    "text": "NoteAnaconda installation steps\n\n\n\n\nGo to https://www.anaconda.com/download\nClick on “Get started” and sign up with an e-mail address of your choice; verify your e-mail address as instructed.\nGo back to the above Anaconda webpage (either by signing in or via the verification e-mail) and download the Graphical Installer installation file (both for MacOS and Windows). \nAfter downloading the installation file, install it. Follow the installation wizard and keep all the default options during installation.\n\n\n\n\n\n\n\nAnaconda Navigator",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Software</span>"
    ]
  },
  {
    "objectID": "02-software.html#spyder",
    "href": "02-software.html#spyder",
    "title": "2  Software",
    "section": "2.2 Spyder",
    "text": "2.2 Spyder\nTo create Python code and scripts, we will be using the Spyder application, which you can open by clicking on Launch in the Anaconda Navigator or by searching for the Spyder application on your computer directly. We note that there are many other applications that you can use to create Python code with (such as Visual Studio Code and Jupyter Notebook; two other applications also installed in the Anaconda distribution).\nOnce you have opened Spyder, you should see an application that looks like this:\n\n\n\nSpyder\n\n\n\n2.2.1 Python Console\nIn the bottom right pane you see a console with IPython. IPython is short for Interactive Python. We can type Python commands into this console and see the output directly. To find 1+1 in Python, we can use the command 1+1, similar to how we would do it in Excel or in the Google search engine. Let’s try this out in the console. First, click on the console to move the cursor there. Then type 1+1 and press Enter. We will see the output 2 on the next line next to a red Out [1]:\n\n\n\nIPython Console\n\n\nThe red Out [1] means this is the output from the first line of input (after the green In [1]). The second command will have input In [2] and output Out [2].\n\n\n2.2.2 Python Scripts\nTyping commands directly into the IPython console is fine if all you want to do is try out a few different simple commands (like we do at the start of the next chapter). However, when working on a project you will often be executing many commands. If you were to do all of this in the interactive console it would be very easy to lose track of what you are doing. It would also be very easy to make mistakes.\nWriting your commands in Python scripts is a solution to this problem. A Python script is a text file with a .py extension where you can write all of your commands in the order you want them run. You can then get Spyder to run the entire file of commands (or only a part of them).\n\nIn Spyder, in the left pane you see a file open called temp.py when you start up Spyder. This is an example Python script. We can ignore what is written in the first 6 lines of the script. In fact, you can remove these lines if you want. We can add our 1 + 1 command to the bottom of the script like this and save it:\n\n\n\nPython Script\n\n\nIn the Toolbar there are several ways to run this command from the script. For example, you can run the entire file, or run only the current line or selected area. If the cursor is on the line with 1 + 1 and we press the “Run selection or current line” button, then we will see the command and output appear in the IPython console, just like how we typed it there before. Using the script, however, we have saved and documented our work.\nIf you try run the entire file, you will see runfile('...') in the IPython console with the ... being the path to the Python script you are running. However, you don’t see a 2 in the output. This is because when running an entire file, Python does not show the output of each line being run. To see the output of any command we need to put it inside the print() function. We can change our line to print(1 + 1) to see the output when running the entire file:\n\n\n\nUsing the print() function\n\n\nWhen you run the entire file you should now see a 2 below the runfile('...') command. We now know how to write and run Python scripts! In the next chapter we will learn more Python commands.\n\n\n2.2.3 Code snippets in this online book\nIn this book, we won’t always show screenshots like we did above. Instead we will show code snippets in boxes like this:\n\n1 + 1\n\n2\n\n\n The top part is code and the bottom part in gray is the output of the executed code. There is a small clipboard icon on the right which you can use to copy the code to paste into your own Python file to be able to experiment with it yourself.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Software</span>"
    ]
  },
  {
    "objectID": "02-software.html#gurobi-installation",
    "href": "02-software.html#gurobi-installation",
    "title": "2  Software",
    "section": "2.3 Gurobi installation",
    "text": "2.3 Gurobi installation\nBased on the above Anaconda installation, we will next explain how to install Gurobi, which is a software package that can solve (linear) optimization problems via Python. We assume in the below that you already have Anaconda/Python installed on your system as in the above steps.\nIf you get stuck anywhere in the installation process, then you can find more information on Gurobi’s Quick Start Guide.\n\n2.3.1 Register at Gurobi\nVisit the Gurobi website and click on the register button. Open the registration form and make sure that you select the Academic account type, and select Student for the academic position. Register with your TIAS e-mail account.\n\n\n2.3.2 Download Gurobi\nDownload Gurobi from the website. Note that you need to login with your Gurobi account before you can download Gurobi. Select the distribution that corresponds to your system (e.g., Windows or macOS), and select the regular “Gurobi Optimizer”, not any of the AMPL variations. Unless mentioned otherwise, download the most recent version.\n\n\n2.3.3 Install Gurobi\nRun the installer and follow the installation steps. At some point, the installer may ask whether to add Gurobi to your execution path. This is probably useful to accept.\n\n\n2.3.4 Gurobi license\nYou cannot use Gurobi without a license, so you need to apply for a license. As a student you can request a free academic license; take the Named-User Academic one. After you have obtained the license, you need to activate it for your Gurobi installation. If you open the license details on the Gurobi website, you can see what you need to do: open a Command Prompt (Windows) or Terminal (MacOS) and run the grbgetkey command with the code that corresponds to your license. This command will create your license file. Make sure that you remember where the license file is saved. The default location suggested by your device is probably the best choice.\nNote that the grbgetkey command will check that you are on an academic domain, so you need to perform this step on the university network (possibly via a VPN connection). Once installed correctly, you can also run Gurobi without an active VPN connection.\n\n\n2.3.5 Using Gurobi in Python\nGurobi should now be correctly installed, but we also want to be able to use it from Python. Therefore, we need to install Gurobi’s Python package. Open the Anaconda prompt application (can also be found in the Anaconda Navigator) and run the following commands one by one (first line + Enter, second line + Enter).\n\nconda config --add channels http://conda.anaconda.org/gurobi\nconda install gurobi\n\n\n\n\n\n\n\nWarning\n\n\n\nThe Anaconda prompt application is NOT the same as the Command Prompt (Windows) or Terminal (MacOS)\n\n\nIf you don’t have the Anaconda installation, then you can do something similar with the pip command, most likely, for those familiar with it.\n\n\n2.3.6 Test your installation\nNow you can test whether everything is setup correctly. Open an interactive Python session, for instance using Spyder. Try the following commands by adding them into a script (make sure there are no spaces at the beginning of the lines) and press Enter.\n\nfrom gurobipy import Model\nmodel = Model()\n\nSet parameter Username\nSet parameter LicenseID to value 2715549\nAcademic license - for non-commercial use only - expires 2026-09-29\n\n\nIf both these commands succeed, you should see some output related to your academic license.\nIf the first command fails, then the Gurobi python module has not been installed correctly. If the second command fails, then the license has not been setup correctly (make sure the license file is at the right location).\nIf at any point, you need more information about Gurobi, then you can always go to the official Gurobi documention online or send the teacher an e-mail.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Software</span>"
    ]
  },
  {
    "objectID": "03-basics.html",
    "href": "03-basics.html",
    "title": "3  Python basics",
    "section": "",
    "text": "3.1 Math operations\nIn this chapter we will learn how to use Python as a calculator and see some basic programming concepts.\nWe start with the most basic mathematical (arithmetic) operations: Addition, subtraction, multiplication and division are given by the standard +, -, * and / operators that you would use in other programs like Excel. For example, addition:\nprint(2 + 3)\n\n5\nSubtraction:\nprint(5 - 3)\n\n2\nMultiplication:\nprint(2 * 3)\n\n6\nDivision:\nprint(3 / 2)\n\n1.5\nIt is also possible to do multiple operations at the same time using parentheses. For example, suppose we wanted to calculate: \n\\frac{2+4}{4 \\cdot 2} = \\frac{6}{8} = 0.75\n We can calculate this in Python as follows:\nprint((2 + 4) / (4 * 2))\n\n0.75\nWith the ** operator (two stars) we can raise a number to the power of another number. For example, 2^3=2\\times 2\\times 2 = 8 can be computed as\nprint(2 ** 3)\n\n8",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "03-basics.html#math-operations",
    "href": "03-basics.html#math-operations",
    "title": "3  Python basics",
    "section": "",
    "text": "WarningWARNING\n\n\n\nDo not use ^ for exponentiation. This actually does a very different thing in Python.\n\n\n\n\n\n\n\n\nTipExercise 3.1\n\n\n\nCompute the following expressions using the operator +, -, *, / and **:\n\n3 + 5 \\cdot 2\n\\frac{(10 - 4)^2}{3}\n\\frac{\\left((2 + 3) \\cdot 4 - 5\\right)^2}{3 + 1}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "03-basics.html#variables",
    "href": "03-basics.html#variables",
    "title": "3  Python basics",
    "section": "3.2 Variables",
    "text": "3.2 Variables\nIn Python we can assign single numbers, as well as text, to variables and then work with and manipulate those variables.\nAssigning a single number to a variable is very straightforward. We put the name we want to give to the variable on the left, then use the = symbol as the assignment operator, and put the number to the right of the =. The = operator binds a number (on the right-hand size of =) to a name (on the left-hand side of =).\nTo see this at work, let’s set x=2 and y=3 and calculate x+y:\n\nx = 2\ny = 3\nprint(x + y)\n\n5\n\n\nWhen we assign x=2, in our code, the number is not fixed forever. We can assign a new number to x. For example, we can assign the number 6 to x instead. The sum of x (which is 6) and y ( which is 3), is now 9:\n\n# Original variable assignment\nx = 2\ny = 3\nprint(x + y)\n\n# Overwriting assignment of variable x\nx = 6\nprint(x + y)\n\n5\n9\n\n\nFinally, you cannot set x=2 with the command 2 = x. That will result in an error. The name must be on the left of = and the number must be on the right of =.\n\n\n\n\n\n\nTipExercise 3.2\n\n\n\nDefine variables a,b,c with numbers 19, 3 and 7, respectively. Compute the following expressions:\n\na + b \\cdot c\n\\frac{(a - c)^2}{b}\n\\frac{((b + c) \\cdot a - c^2)^2}{a + b}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "03-basics.html#lists",
    "href": "03-basics.html#lists",
    "title": "3  Python basics",
    "section": "3.3 Lists",
    "text": "3.3 Lists\nWe can also store multiple variables in one object, a so-called list. A list with numbers is created by writing down a sequence of numbers, separated by commas, in between two brackets [ and ].\n\nz = [3, 9, 1, 7]\nprint(z)\n\n[3, 9, 1, 7]\n\n\nWe can also create lists with fractional numbers.\n\nz = [3.1, 9, 1.9, 7]\nprint(z)\n\n[3.1, 9, 1.9, 7]\n\n\nTo access the numbers in the list, we can index the list at the position of interest. If we want to get the number at position i in the list, we use the syntax z[i].\n\nprint(z[1])\n\n9\n\n\nSomething strange is happening here… The left-most number in the list is 3.1, but z[1] returns 9. This happens because Python actually starts counting at index 0 (instead of 1).\n\n\n\n\n\n\nNoteIndexing convention in Python\n\n\n\nThe left-most number in a Python list is located at position 0. The number next to that at position 1, etc. That is, the i-th number in a list with n numbers can be found at position i - 1 for i = 1,\\dots,n\n\n\nIn other words, the “first” number in the list is located at position 0, and we can access it using z[0] instead.\nBelow we index the number of the list at positions i \\in \\{0,1,2,3\\} separately.\n\nprint(z[0])\n\n3.1\n\n\n\nprint(z[1])\n\n9\n\n\n\nprint(z[2])\n\n1.9\n\n\n\nprint(z[3])\n\n7\n\n\n\n\n\n\n\n\nTipExercise 3.3\n\n\n\nConsider the list a = [11, 41, 12, 35, 6, 33, 7].\n\nCompute the sum of the numbers at even positions in a (i.e., positions 0, 2, 4, and 6).\nCompute the result of multiplying the first and last elements of a, then subtracting the middle element.\nCompute the square of the element at position 2, divided by the sum of the elements at the odd positions.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "03-basics.html#sec-for-loop",
    "href": "03-basics.html#sec-for-loop",
    "title": "3  Python basics",
    "section": "3.4 Printing text",
    "text": "3.4 Printing text\nIt is also possible to print text in Python with the print() command. To do this, you have to put the desired text in quotation marks, either single '' or double \"\". It does not matter if you use single or double quotation as long as you use the same type on both end of the text.\n\nprint('Hello world!')\n\nHello world!\n\n\n\nprint(\"Hello world!\")\n\nHello world!\n\n\nA piece of text within quotation marks is called a string in Python. It is also possible to store text (strings) in a list, and print it from the list. For example, we can store the days of the weeks as text in the list days as follows.\n\ndays = [\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\"]\n\nIf we now want to print a day, we should index the list at the corresponding position. For example, to print \"Wednesday\", we should index the list at position 2.\n\nprint(days[2])\n\nWednesday\n\n\nIf you want to print both text(s) and variables within the same print() command, you can do this by separating these quantities with a comma.\n\nprint(\"The third day of the week is\", days[2])\n\nThe third day of the week is Wednesday\n\n\n\n\n\n\n\n\nTipExercise 3.4\n\n\n\nCreate a list called courses that contains five course names as text/strings. Then:\n\nPrint the first course in the list.\nPrint the last course in the list.\nPrint a sentence that says: My favorite course is [course]. where [course] should be replaced by your favorite course indexed from the list.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "03-basics.html#for-loop",
    "href": "03-basics.html#for-loop",
    "title": "3  Python basics",
    "section": "3.5 For-loop",
    "text": "3.5 For-loop\nFor-loops are a convenient way to avoid unnecessary repetition of different lines of code. Suppose we want to print all the days of the week from the days list.\nWe can do this by using a print statement for every day separately by indexing days at all its positions.\n\ndays = [\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\"]\n\nprint(\"The days of the week are:\")\nprint(days[0])\nprint(days[1])\nprint(days[2])\nprint(days[3])\nprint(days[4])\nprint(days[5])\nprint(days[6])\n\nThe days of the week are:\nMonday\nTuesday\nWednesday\nThursday\nFriday\nSaturday\nSunday\n\n\nHowever, looking at the above, the only thing that changes in the last seven lines of code is the position at which we access days. We can also print all the days of the week based on the list days above using a for-loop.\n\ndays = [\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\"]\n\nfor i in range(0,7):\n    print(days[i])\n\nMonday\nTuesday\nWednesday\nThursday\nFriday\nSaturday\nSunday\n\n\nWith the line for i in range(0,7): we tell Python that we would like to carry out a piece of code (the line below it) with different values of the iteration variable i ranging from 0 to 7, but NOT including 7. In other words, we want to run a piece of code for the values of i being 0,1,2,3,4,5 and 6. It is important to realize here that the index 7 is not included as value for i in the for-loop (this is what the Python developers decided on).\nIn Python such a range, called the iterable, can be specified with the range(a,b) function where a is the smallest value and b-1 the largest value of i. In the first iteration with i = 0 Python will now print days[0], in the second iteration with i = 1 Python will print days[1], etcetera.\nThe code we want to execute repeatedly can be found under the lines for i in range(0,7): with an indentation (or tab). The indendation is important so that Python known this is the line of code you want to be carried out repeatedly. We can also carry out multiple lines of code in a for-loop, then all these lines should be indented.\n\ndays = [\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\"]\n\nfor i in range(0,7):\n    print(\"Day\", i+1, \"of the week is:\")\n    print(days[i])\n\nDay 1 of the week is:\nMonday\nDay 2 of the week is:\nTuesday\nDay 3 of the week is:\nWednesday\nDay 4 of the week is:\nThursday\nDay 5 of the week is:\nFriday\nDay 6 of the week is:\nSaturday\nDay 7 of the week is:\nSunday\n\n\nNote that in the first line in the for-loop, here we print three aspects in one print() statement: The word Day, the value of i+1, and the words of the week is:. As i ranges from 0 to 6, the values of i+1 ranges from 1 to 7.\nWe note that we only use two print statements for the sake of illustration. The above could have been printed with one print() statement as well.\n\ndays = [\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\"]\n\nfor i in range(0,7):\n    print(\"Day\", i+1, \"of the week is:\", days[i])\n\nDay 1 of the week is: Monday\nDay 2 of the week is: Tuesday\nDay 3 of the week is: Wednesday\nDay 4 of the week is: Thursday\nDay 5 of the week is: Friday\nDay 6 of the week is: Saturday\nDay 7 of the week is: Sunday\n\n\n\n\n\n\n\n\nTipExercise 3.5\n\n\n\nTake your list courses from the previous exercise and consider the list days from above. Print the five sentences: On Monday the course [course0] is being taught., On Tuesday the course [course1] is being taught.; etc. by using a for-loop in which you index the courses and days from the two lists, and where [course0], [course1], etc. are the first, second, etc. course names from the list.\n\n\nWe remark that it is also possible to directly iterate over the values in a list (the iterable).\n\ndays = [\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\"]\n\nfor i in days:\n    print(i)\n\nMonday\nTuesday\nWednesday\nThursday\nFriday\nSaturday\nSunday\n\n\nIn this case, i does not range from 0 to 6, but in iterates directly over the strings in the list days. So in the first iteration i = “Monday”, in the second iteration i = “Tuesday”, etcetera.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "03-basics.html#conditional-statements",
    "href": "03-basics.html#conditional-statements",
    "title": "3  Python basics",
    "section": "3.6 Conditional statements",
    "text": "3.6 Conditional statements\nIt is also possible in Python have different lines of code executed based on conditions. For this we use an if/else statement. This allows the program to execute certain lines of code only when a condition is true.\nFor example, suppose we store a number in the variable x and want to print a message only if x is greater than 5.\n\nx = 8\n\nif x &gt; 5:\n    print(\"x is greater than 5\")\n\nx is greater than 5\n\n\nThe line if x &gt; 5: checks whether the condition x &gt; 5 is true. If it is true, Python executes the indented line below it. If the condition is false, nothing happens and Python continues with the rest of the code. You can check this yourself by changing the value of x to something strictly smaller than 5. If you run the code snippet, nothing should be printed.\nWe can also tell Python what to do if the condition is false by adding an else statement.\n\nx = 3\n\nif x &gt; 5:\n    print(\"x is greater than 5\")\nelse:\n    print(\"x is not greater than 5\")\n\nx is not greater than 5\n\n\nHere Python checks the condition. Since 3 &gt; 5 is false, i.e., the condition x &gt; 5 is not true, the code under else: is executed instead.\nJust like with for-loops, indentation is important. All lines that belong to the if or else block must be indented so Python knows which code belongs to which condition.\nWe can also check more than two conditions using elif (short for “else if”):\n\nx = 5\n\nif x &gt; 5:\n    print(\"x is greater than 5\")\nelif x == 5:\n    print(\"x is exactly 5\")\n    print(\"You can execute multiple lines of code when a condition is true\")\nelse:\n    print(\"x is less than 5\")\n\nx is exactly 5\nYou can execute multiple lines of code when a condition is true\n\n\nIn this case Python checks the conditions from top to bottom and executes only the first one that is true. In the snippet above the line \"x is exactly 5\" will be printed. You can play around with this code snippet by changing the values of x and observing that, depending on its value, a different line will be printed.\nYou can use the following symbols to compare a variable with a given number.\n\n\n\nOperator\nMeaning\nExample (x = 5)\nResult\n\n\n\n\n&lt;\nLess than\nx &lt; 7\nTrue\n\n\n&gt;\nGreater than\nx &gt; 7\nFalse\n\n\n&lt;=\nLess than or equal to\nx &lt;= 5\nTrue\n\n\n&gt;=\nGreater than or equal to\nx &gt;= 6\nFalse\n\n\n==\nEqual to\nx == 5\nTrue\n\n\n!=\nNot equal to\nx != 5\nFalse\n\n\n\nYou can also combine multiple statements into one condition using the and and or keyword arguments. In the code below, we do not finish with an else statement; this is not mandatory.\n\nx = 5\n\nif x &gt; 5 and x &lt; 10:\n    print(\"x is between 5 and 10\")\nelif x == 5 or x == -5:\n    print(\"The absolute value of x is 5\")\n\nThe absolute value of x is 5\n\n\nYou can also combine for-loops and if/else statements. For example, recall the original if/else statement where we checked whether x was greater or equal than 5.\n\nx = 3\n\nif x &gt; 5:\n    print(\"x is greater than 5\")\nelse:\n    print(\"x is not greater than 5\")\n\nx is not greater than 5\n\n\nWe can also check this for a collection of numbers stored in a list numbers by iterating with a for-loop over these numbers and check the conditions for every element in the list.\n\nnumbers = [3, 7, -3, 4, 10]\n\nfor x in numbers:\n    if x &gt; 5:\n        print(\"x is greater than 5\")\n    else:\n        print(\"x is not greater than 5\")\n\nx is not greater than 5\nx is greater than 5\nx is not greater than 5\nx is not greater than 5\nx is greater than 5\n\n\nNote that in the above code we use indentation twice! For every iteration of the for-loop we want to check the if/else statement, so all those lines need to be indented. Because it also needs to be clear, for every iteration, which lines correspond to the if-statement, and which to the else-statement, the print() statements are indented once more.\n\n\n\n\n\n\nTipExercise 3.6\n\n\n\nConsider the list of temparatures (in degrees Celsius) [20, 14, 12, 18, 25, 30, 31] corresponding to the days of the week Monday through Sunday. For every day you have to print the message: [day] is a [cold/normal/hot] summer day., where a day is cold if the temperature is below 15, normal if it is in the interval [15,25] (i.e., greater or equal than 15 and smaller or equal than 25), and hot if it is higher than 25.\nThe output of your code should be:\n\n\nMonday is a normal summer day.\nTuesday is a cold day.\nWednesday is a cold day.\nThursday is a normal summer day.\nFriday is a normal summer day.\nSaturday is a hot summer day.\nSunday is a hot summer day.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "04-linear-optimization.html",
    "href": "04-linear-optimization.html",
    "title": "4  Linear optimization",
    "section": "",
    "text": "4.1 Basics\nIn this chapter we will show how to implement linear optimization problems using Python. The goal is to model optimization problems in Python and then solve them using Gurobi, which is a software package dedicated to solving optimization problems. Note that it is important that you installed Gurobi correctly as explained in Chapter 2.\nAll the relevant functionality needed to use Gurobi via Python is contained in the gurobipy package. For our purposes, we only need two modules from this package:\nIn Python you can include the modules by adding the following line at the top of a script.\nfrom gurobipy import Model, GRB",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear optimization</span>"
    ]
  },
  {
    "objectID": "04-linear-optimization.html#basics",
    "href": "04-linear-optimization.html#basics",
    "title": "4  Linear optimization",
    "section": "",
    "text": "The Model module that we will use to build optimization problems\nThe GRB module that contains various “constants” that we use to include words such as maximize and minimize.\n\n\n\n\nExample: Duplo problem\nTo illustrate how to implement optimization problems in Python, we consider the Duplo problem from the lectures: \n\\begin{array}{llll}\n\\text{maximize}& 15x_1 + 20x_2 && \\text{(profit)} \\\\\n\\text{subject to} &x_1 + 2x_2 \\leq 6 &&\\text{(big bricks)} \\\\\n&2x_1 + 2x_2 \\leq 8 &&\\text{(small bricks)} \\\\\n&x_1, x_2 \\geq 0\n\\end{array}\n with decision variables\n\nx_1: Number of chairs\nx_2: Number of tables\n\nLet us implement the Duplo problem in Gurobi.\n\n\n4.1.1 Model() object\nTo start, we will create a variable (or object) duplo that will contain all the information of the problem, such as the decision variables, objective function and constraints.\nIn programming terms, we create an object from the Model() class. We can give the instance a name by adding the name keyword argument, with value 'Duplo problem' in our case. We add this name with quotations so that Python knows this is plain text.\n\n# Initialize Gurobi model.\nduplo = Model(name='Duplo problem')\n\nSet parameter Username\nSet parameter LicenseID to value 2715549\nAcademic license - for non-commercial use only - expires 2026-09-29\n\n\nYou can think of the Model class object duplo as a large box that we are going to fill with decision variables, an objective function, and constraints. We will also reserve a small space in this box to store information about the optimal solution to the linear optimization problem, once we have optimized the problem.\nThe concept of having “objects” is in fact what the programming language Python is centered around. This is known as object-oriented programming.\n\n\n4.1.2 Decision variables\nTo add decision variables, an objective function, and constraints, to our Model object we use so-called methods which are Python functions.\nTo create a decision variable, we can use the addVar() method. As input argument, we include a name for the decision variables.\n\n# Declare the two decision variables.\nx1 = duplo.addVar(name='chairs')\nx2 = duplo.addVar(name='tables')\n\n\nIf your Model object is not called duplo, but for example production_planning, then you should use production_planning.addVar(name='chairs') instead. The same applies for all later methods that are introduced. Never call a model Model (with capital M) because this spelling is reserved for the Model() class in Gurobi.\n\n\n\n4.1.3 Objective function\nNow that we have our decision variables, we can use them to define the objective function and the constraints.\nWe use the setObjective() method to do so by refering to the variables created above. The sense keyword argument must be used to specify whether we want to maximize or minimize the objective function. For this, we use GRB.MAXIMIZE or GRB.MINIMIZE, respectively.\n\n# Specify the objective function.\nduplo.setObjective(15*x1 + 20*x2, sense=GRB.MAXIMIZE)\n\n\n\n4.1.4 Constraints\nThe next step is to declare the constraints using the addConstr() method. Also here, we can specify the constraints refering to the variables x1 and x2. We give the constraints a name as well.\n\n# Add the resource constraints on bricks.\nduplo.addConstr(x1 + 2*x2 &lt;= 6, name='big-bricks')\nduplo.addConstr(2*x1 + 2*x2 &lt;= 8, name='small-bricks')\n\n&lt;gurobi.Constr *Awaiting Model Update*&gt;\n\n\nWe can also add the nonnegativity constraints x_1 \\geq 0 and x_2 \\geq 0 in this way, but this is actually not needed! By default, Python adds in the background the constraints that the decision variables should be nonnegative when creating them (see also Section 4.1.6).\n\n\n4.1.5 Optimal solution\nNow the model is completely specified, we are ready to compute the optimal solution. We can do this using the optimize() method applied to our model duplo.\n\n# Optimize the model\nduplo.optimize()\n\nGurobi Optimizer version 12.0.1 build v12.0.1rc0 (win64 - Windows 10.0 (19045.2))\n\nCPU model: 12th Gen Intel(R) Core(TM) i7-1265U, instruction set [SSE2|AVX|AVX2]\nThread count: 10 physical cores, 12 logical processors, using up to 12 threads\n\nOptimize a model with 2 rows, 2 columns and 4 nonzeros\nModel fingerprint: 0xadc88607\nCoefficient statistics:\n  Matrix range     [1e+00, 2e+00]\n  Objective range  [2e+01, 2e+01]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [6e+00, 8e+00]\nPresolve time: 0.00s\nPresolved: 2 rows, 2 columns, 4 nonzeros\n\nIteration    Objective       Primal Inf.    Dual Inf.      Time\n       0    3.5000000e+31   3.500000e+30   3.500000e+01      0s\n       2    7.0000000e+01   0.000000e+00   0.000000e+00      0s\n\nSolved in 2 iterations and 0.00 seconds (0.00 work units)\nOptimal objective  7.000000000e+01\n\n\nWe can see some output from Gurobi, and the last line tells us that Gurobi found an optimal solution with objective value 70.\nTo summarize all the step above, we have given the complete code below (but not executed this time).\n\nfrom gurobipy import Model, GRB\n\n# Initialize Gurobi model.\nduplo = Model(name='Duplo problem')\n\n# Declare the two decision variables.\nx1 = duplo.addVar(name='chairs')\nx2 = duplo.addVar(name='tables')\n\n# Specify the objective function.\nduplo.setObjective(15*x1 + 20*x2, sense=GRB.MAXIMIZE)\n\n# Add the resource constraints on bricks.\nduplo.addConstr(x1 + 2*x2 &lt;= 6, name='big-bricks')\nduplo.addConstr(2*x1 + 2*x2 &lt;= 8, name='small-bricks')\n\n# Optimize the duplo\nduplo.optimize()\n\nRecalling our linear optimization problem object as being a “box” filled with decision variables, an objective function and constraints, the box now also contains a small space where the optimal solution is stored.\nLet us have a look at how to access information about the optimal solution. The objective function value of the optimal solution, that was also displayed in the output when optimization the model with duplo.optimize() is stored in the ObjVal attribute. An attribute is a piece of information about an object in Python.\n\n# Print text 'Objective value:' and the duplo.ObjVal attribute value\nprint('Objective value:', duplo.ObjVal)\n\nObjective value: 70.0\n\n\nThe optimal values of a decision variables can be obtained by accessing the X attribute of a variable.\n\nprint('x1 = ', x1.X)\nprint('x2 = ', x2.X)\n\nx1 =  2.0\nx2 =  2.0\n\n\nIf the model has many variables, printing variables in this way is a cumbersome approach. It is then easier to iterate over all variables of the model using the getVars() method. This method creates a list of all the decision variables of the model.\n\nprint(duplo.getVars())\n\n[&lt;gurobi.Var chairs (value 2.0)&gt;, &lt;gurobi.Var tables (value 2.0)&gt;]\n\n\nAs you can see above, we already see the optimal values of the decision variables, but also a lot of unnecessary information.\nLet us print these values in a nicer format by iterating over the list duplo.getVars() using a for-loop with index variable var; you can choose another name here if you want. We print for every variable var its name, stored in the attribute VarName, and its value, stored in the attribute X. In between, we print the = symbol in plain text (hence, the quotations).\nRecall that if you want to print multiple date types (such as a variables and text) in a print() statement, you should separate them with commas.\n\nfor var in duplo.getVars():\n    print(var.VarName, \"=\", var.X)\n\nchairs = 2.0\ntables = 2.0\n\n\n\n\n4.1.6 Help functionality\nTo see all these properties of method, e.g., addVar, you can check out the addVar documentation by typing help(Model.addVar) in Python. Looking up the documentation in this way can be done for every method.\n\nhelp(Model.addVar)\n\nHelp on cython_function_or_method in module gurobipy._model:\n\naddVar(self, lb=0.0, ub=1e+100, obj=0.0, vtype='C', name='', column=None)\n    ROUTINE:\n      addVar(lb, ub, obj, vtype, name, column)\n\n    PURPOSE:\n      Add a variable to the model.\n\n    ARGUMENTS:\n      lb (float): Lower bound (default is zero)\n      ub (float): Upper bound (default is infinite)\n      obj (float): Objective coefficient (default is zero)\n      vtype (string): Variable type (default is GRB.CONTINUOUS)\n      name (string): Variable name (default is no name)\n      column (Column): Initial coefficients for column (default is None)\n\n    RETURN VALUE:\n      The created Var object.\n\n    EXAMPLE:\n      v = model.addVar(ub=2.0, name=\"NewVar\")\n\n\n\nFor example, from this it can be seen that when creating a variable, you can specify more properties. You can use the keyword arguments lb and ub to define a lower and upper bound, respectively, for a decision variable.\nIf we would want to create a variable, with name Test variable, having lower bound 3 and upper bound 7, i.e., these bounds model the constraints x_1 \\geq 3 and x_1 \\leq 7, we can do this with x = duplo.addVar(lb=3, ub=7 ,name='Test variable') using the lb and ub keyword arguments.\nAs you can see above, all the keyword arguments have default values, meaning that if we do not specify them, Gurobi uses the specified default value for them (and sets these outside of our view). For example, by default a variable is continuous (vtype keyword argument) and non-negative (lb keyword argument). This is the reason why we do not have to specify the nonnegativity constraints x_1,x_2 \\geq 0 for the Duplo example.\nAlso note that ub is set to 10^{100} which roughly speaking indicates that the decision variable has no upper bound value by default (because it is highly unlikely that an optimal solution would have a value that large).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear optimization</span>"
    ]
  },
  {
    "objectID": "04-linear-optimization.html#sensitivity-analysis",
    "href": "04-linear-optimization.html#sensitivity-analysis",
    "title": "4  Linear optimization",
    "section": "4.2 Sensitivity analysis",
    "text": "4.2 Sensitivity analysis\nIn class we have investigated how the optimal solution changes when either an objective function coefficient changes, or if one of the right hand side values of a constraint changes.\nTo obtain a concise report with all the OFC ranges of the objective function coefficients, as well as the shadow prices and allowable ranges of all the constraints, right-click and store the Python file (sensitivity_analysis.py) in the same folder as where you stored your linear optimization problem.\nMake sure the name of the file you download here is sensitivity_analysis and that it is stored as a .py file. On Windows you would use “Save as type: All files” and then store the file as sensitivity_analysis.py.\nIn the Python file containing your linear optimization problem, you must include the lines below where you should replace [model_object] by the variable name of your model. For the Duplo example, this was duplo.\n\n\nfrom sensitivity_analysis import report\nreport([model_object])\n\nThe following code defines again the Duplo problem in Gurobi and generates the sensitivity report.\n\nfrom gurobipy import Model, GRB\n\n# Initialize Gurobi model.\nduplo = Model(name='Duplo problem')\n\n# Declare the two decision variables.\nx1 = duplo.addVar(name='chairs')\nx2 = duplo.addVar(name='tables')\n\n# Specify the objective function.\nduplo.setObjective(15*x1 + 20*x2, sense=GRB.MAXIMIZE)\n\n# Add the resource constraints on bricks.\nduplo.addConstr(x1 + 2*x2 &lt;= 6, name='big-bricks')\nduplo.addConstr(2*x1 + 2*x2 &lt;= 8, name='small-bricks')\n\n# Optimize the duplo\nduplo.optimize()\n\n# Generate sensitivity report\nfrom sensitivity_analysis import report\nreport(duplo)\n\nGurobi Optimizer version 12.0.1 build v12.0.1rc0 (win64 - Windows 10.0 (19045.2))\n\nCPU model: 12th Gen Intel(R) Core(TM) i7-1265U, instruction set [SSE2|AVX|AVX2]\nThread count: 10 physical cores, 12 logical processors, using up to 12 threads\n\nOptimize a model with 2 rows, 2 columns and 4 nonzeros\nModel fingerprint: 0xadc88607\nCoefficient statistics:\n  Matrix range     [1e+00, 2e+00]\n  Objective range  [2e+01, 2e+01]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [6e+00, 8e+00]\nPresolve time: 0.00s\nPresolved: 2 rows, 2 columns, 4 nonzeros\n\nIteration    Objective       Primal Inf.    Dual Inf.      Time\n       0    3.5000000e+31   3.500000e+30   3.500000e+01      0s\n       2    7.0000000e+01   0.000000e+00   0.000000e+00      0s\n\nSolved in 2 iterations and 0.00 seconds (0.00 work units)\nOptimal objective  7.000000000e+01",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear optimization</span>"
    ]
  },
  {
    "objectID": "04-linear-optimization.html#beyond-the-basics",
    "href": "04-linear-optimization.html#beyond-the-basics",
    "title": "4  Linear optimization",
    "section": "4.3 Beyond the basics",
    "text": "4.3 Beyond the basics\nWhen building optimization models in gurobipy, you often need many decision variables and long sums in objectives or constraints. Instead of writing everything manually, Gurobi provides tools to do this compactly and clearly.\nTwo especially useful tools are:\n\naddVars() : Create many variables at once\nquicksum() : Efficiently create constraints in terms of decision variables\n\n\n4.3.1 Defining many variables\nIf we define a Model() object with name problem, we can use the syntax x = problem.addVars(n) to tell Python to create n decision variables. You can use the i-th decision variable to define constraints and the objective function by indexing x at position i-1, i.e, by using x[i-1]. Recall that Python starts counting from zero when indexing data objects such as lists.\nIf you want you can also add a list of names for the decision variables using the name keyword argument. Make sure that the number of elements in the list matches the value of n.\nBelow we use addVars() to again define the Duplo example with n = 2.\n\nfrom gurobipy import Model, GRB\n\n# Initialize Gurobi model.\nduplo = Model(name='Duplo problem')\n\n# Declare the two decision variables using addVars()\nx = duplo.addVars(2,name=[\"chairs\",\"tables\"])\n\n# Specify the objective function in terms of x[0] and x[1]\nduplo.setObjective(15*x[0] + 20*x[1], sense=GRB.MAXIMIZE)\n\n# Add the resource constraints on bricks in terms of x[0] and x[1]\nduplo.addConstr(x[0] + 2*x[1] &lt;= 6, name='big-bricks')\nduplo.addConstr(2*x[0] + 2*x[1] &lt;= 8, name='small-bricks')\n\n# Optimize the duplo\nduplo.optimize()\n\n\n\n4.3.2 Defining constraints quickly\nThe function quicksum() is convenient to use if you you want to add the objective function c_1x_1 + x_2x_2 + \\dots + c_nx_n or a constraint of the form a_1x_1 + a_2x_2 + \\dots + a_nx_n \\leq b. You have to import this function into Python just as we have to do with Model and GRB.\nLet us again consider the Duplo example. If we define x = [x_1, x_2] and c = [c_1, c_2] = [2, 2], then we can create the objective function c_1x_1 + c_2x_2 by first creating the list [c_1x_1, c_2x_2], containing the individual terms of the objective function, and then summing up the elements in this list. The latter is precisely what quicksum() does: It takes as input a list and adds up the number in this list.\nIn the code below we do two things:\n\nCreate the list y = [c[0]*x[0], c[1]*x[1]] using the concept of list comprehension.\nUse the quicksum() function to add up the elements in the list y and set the resulting variable obj as our objective function.\n\n\nfrom gurobipy import Model, GRB, quicksum\n\n# Initialize Gurobi model.\nduplo = Model(name='Duplo problem')\n\n# Declare the two decision variables using addVars()\nx = duplo.addVars(2,name=[\"chairs\",\"tables\"])\n\n# Coefficients of objective function\nc = [2,2]\n\n# Define list [c[0]*x[0], c[1]*x[1]]\ny = [c[j]*x[j] for j in range(2)] \n\n# Sum up the terms in the list y\nobj = quicksum(y) \n\n# Define objective \nduplo.setObjective(obj, sense=GRB.MAXIMIZE) \n\nThe part [c[j]*x[j] for j in range(2)] is the compact list comprehension syntax for creating [c[0]*x[0], c[1]*x[1]]. Recall from Section 3.5 that j in range(0,2) means we iterate over the values j = 0 and j = 1 (the value 2 is not included).\nThis time we are only creating a list with two elements, but imagine then if you have 100 variables, then [c[j]*x[j] for j in range(100)] would be all you need to create an objective function of the form c_1x_1 + c_2x_2 + \\dots + c_{100}x_{100} which consists of 100 terms!\nWe remark that you can also combine the above steps into a more compact code that carries out the last three lines in one line.\n\n# Define objective \nduplo.setObjective(quicksum(c[j]*x[j] for j in range(2)), sense=GRB.MAXIMIZE) \n\nIn a similar fashion you can define the left hand side of a constraint a_1x_1 + a_2x_2 + \\dots + a_nx_n \\leq b quickly with quicksum(). Below we have given the Duplo example implemented with the use of quicksum() and addVars().\n\nfrom gurobipy import Model, GRB\n\n# Initialize Gurobi model.\nduplo = Model(name='Duplo problem')\n\n# Declare the two decision variables using addVars()\nx = duplo.addVars(2,name=[\"chairs\",\"tables\"])\n\n# Objective function coefficients\nc = [2,2]\n\n# Big brick coefficients\nb = [1,2]\n\n# Small brick coefficients\ns = [2,2]\n\n# Specify the objective function in terms of x[0] and x[1]\nduplo.setObjective(quicksum(c[j]*x[j] for j in range(2)), sense=GRB.MAXIMIZE)\n\n# Add the resource constraints on bricks in terms of x[0] and x[1]\nduplo.addConstr(quicksum(b[j]*x[j] for j in range(2)) &lt;= 6, name='big-bricks')\nduplo.addConstr(quicksum(s[j]*x[j] for j in range(2)) &lt;= 8, name='small-bricks')\n\n# Optimize the duplo\nduplo.optimize()\n\n# Print optimal values of decision variables\nfor var in duplo.getVars():\n    print(var.VarName, \"=\", var.X)\n\nGurobi Optimizer version 12.0.1 build v12.0.1rc0 (win64 - Windows 10.0 (19045.2))\n\nCPU model: 12th Gen Intel(R) Core(TM) i7-1265U, instruction set [SSE2|AVX|AVX2]\nThread count: 10 physical cores, 12 logical processors, using up to 12 threads\n\nOptimize a model with 2 rows, 2 columns and 4 nonzeros\nModel fingerprint: 0x1b7dc040\nCoefficient statistics:\n  Matrix range     [1e+00, 2e+00]\n  Objective range  [2e+00, 2e+00]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [6e+00, 8e+00]\nPresolve time: 0.00s\nPresolved: 2 rows, 2 columns, 4 nonzeros\n\nIteration    Objective       Primal Inf.    Dual Inf.      Time\n       0    4.0000000e+30   3.500000e+30   4.000000e+00      0s\n       2    8.0000000e+00   0.000000e+00   0.000000e+00      0s\n\nSolved in 2 iterations and 0.00 seconds (0.00 work units)\nOptimal objective  8.000000000e+00\nchairs = 2.0\ntables = 2.0",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear optimization</span>"
    ]
  },
  {
    "objectID": "04-linear-optimization.html#integer-variables",
    "href": "04-linear-optimization.html#integer-variables",
    "title": "4  Linear optimization",
    "section": "4.4 Integer variables",
    "text": "4.4 Integer variables\nIf you are not interested in finding fractional solutions, but want to enforce the decision variables to take integer values, you can do this with the vtype keyword argument.\nConsider the following linear optimization problem (without integrality constraints).\n\n\\begin{array}{lrrrrrrl}\n\\max & z  = & 2x_{1} &+ &x_{2} & & & \\\\\n\\text{s.t. } & &x_1 &+ & x_2& \\leq & 2.5 & \\\\\n& &x_1, & & x_2  & \\geq & 0 &\n\\end{array},\n\n\n# Initialize Gurobi model.\nmodel_frac = Model(name='Fractional problem')\n\n# Suppress Gurobi Optimizer output\nmodel_frac.setParam('OutputFlag',0)\n\n# Declare the two decision variables.\nx1 = model_frac.addVar(name=\"x1\") \nx2 = model_frac.addVar(name=\"x2\") \n\n# Specify the objective function.\nmodel_frac.setObjective(2*x1 + x2, sense=GRB.MAXIMIZE)\n\n# Add the resource constraints on bricks.\nmodel_frac.addConstr(x1 + x2 &lt;= 2.5)\n\n# Optimize the model\nmodel_frac.optimize()\n\n# Print optimal values of decision variables\nfor var in model_frac.getVars():\n    print(var.VarName, \"=\", var.X)\n\nx1 = 2.5\nx2 = 0.0\n\n\nIf we specify vtype=GRB.INTEGER in the addVar() method when creating the variables, Gurobi will find an optimal solution with all decision variables being integers.\n\n# Initialize Gurobi model.\nmodel_int = Model(name='Integer problem')\n\n# Suppress Gurobi Optimizer output\nmodel_int.setParam('OutputFlag',0)\n\n# Declare the two decision variables.\nx1 = model_int.addVar(name=\"x1\",vtype=GRB.INTEGER) \nx2 = model_int.addVar(name=\"x2\",vtype=GRB.INTEGER) \n\n# Specify the objective function.\nmodel_int.setObjective(2*x1 + x2, sense=GRB.MAXIMIZE)\n\n# Add the resource constraints on bricks.\nmodel_int.addConstr(x1 + x2 &lt;= 2.5)\n\n# Optimize the model\nmodel_int.optimize()\n\n# Print optimal values of decision variables\nfor var in model_int.getVars():\n    print(var.VarName, \"=\", var.X)\n\nx1 = 2.0\nx2 = -0.0\n\n\nAnoter common case is where the decision variables are supposed to be binary, meaning they can only take values in \\{0,1\\}. Setting variables to be binary can be done with vtype=GRB.BINARY.\n\n# Initialize Gurobi model.\nmodel_bin = Model(name='Binary problem')\n\n# Suppress Gurobi Optimizer output\nmodel_bin.setParam('OutputFlag',0)\n\n# Declare the two decision variables.\nx1 = model_bin.addVar(name=\"x1\",vtype=GRB.BINARY) \nx2 = model_bin.addVar(name=\"x2\",vtype=GRB.BINARY) \n\n# Specify the objective function.\nmodel_bin.setObjective(2*x1 + x2, sense=GRB.MAXIMIZE)\n\n# Add the resource constraints on bricks.\nmodel_bin.addConstr(x1 + x2 &lt;= 2.5)\n\n# Optimize the model\nmodel_bin.optimize()\n\n# Print optimal values of decision variables\nfor var in model_bin.getVars():\n    print(var.VarName, \"=\", var.X)\n\nx1 = 1.0\nx2 = 1.0",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear optimization</span>"
    ]
  },
  {
    "objectID": "05-monte-carlo-simulation.html",
    "href": "05-monte-carlo-simulation.html",
    "title": "5  Monte Carlo simulation",
    "section": "",
    "text": "5.1 Scenario analysis\nIn this chapter we show how to solve an optimization problem for many scenarios, where each scenario has slightly different input data. We also consider the generation of random scenarios.\nConsider again the Duplo example with objective function coefficients s_1 and s_2: \n\\begin{array}{llll}\n\\text{maximize}& s_1\\cdot x_1 + s_2 \\cdot x_2 && \\text{(profit)} \\\\\n\\text{subject to} &x_1 + 2x_2 \\leq 6 &&\\text{(big bricks)} \\\\\n&2x_1 + 2x_2 \\leq 8 &&\\text{(small bricks)} \\\\\n&x_1, x_2 \\geq 0\n\\end{array}\n with decision variables\nWe can solve the Duplo example for different objective function coefficients, with the results as specified in the table below.\nTo solve the Duplo problem repeatedly in Python using a different scenario every time, we can use a for-loop. We specify the different values of s_1 and s_2 in two separate lists, where s1[i] is the value of s_1 in scenario i+1 (recall Python starts indexing at zero), and similarly s2[i] the value of s_2 in scenario i+1.\nfrom gurobipy import Model, GRB\n\n# Different scenarios\ns1 = [15, 9, 20, 16]\ns2 = [20, 25, 19, 21]\n\nfor i in range(0,4):\n    # Initialize Gurobi model.\n    duplo = Model(name='Duplo problem')\n\n    # Suppress Gurobi Optimizer output\n    duplo.setParam('OutputFlag',0)\n\n    # Declare the two decision variables.\n    x1 = duplo.addVar(name='chairs')\n    x2 = duplo.addVar(name='tables')\n    \n    # Specify the objective function in terms of s1[i], s2[i]\n    duplo.setObjective(s1[i]*x1 + s2[i]*x2, sense=GRB.MAXIMIZE)\n    \n    # Add the resource constraints on bricks.\n    duplo.addConstr(x1 + 2*x2 &lt;= 6, name='big-bricks')\n    duplo.addConstr(2*x1 + 2*x2 &lt;= 8, name='small-bricks')\n    \n    # Optimize the duplo\n    duplo.optimize()\n\n    # Print solution\n    print(\"Optimal solution for scenario\", i+1, \"is [\", x1.X, \",\", x2.X, \"]\")\n\nSet parameter Username\nSet parameter LicenseID to value 2715549\nAcademic license - for non-commercial use only - expires 2026-09-29\nOptimal solution for scenario 1 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 2 is [ 0.0 , 3.0 ]\nOptimal solution for scenario 3 is [ 4.0 , 0.0 ]\nOptimal solution for scenario 4 is [ 2.0 , 2.0 ]\nA couple of remarks are in place for the code above. First of all, note that all the lines below the line for i in range(0,4): are indented because we want the model to be constructed, optimized and printed in every iteration.\nWe use the command duplo.setParam('OutputFlag',0) to suppress the output that Gurobi usually generates when we optimize a linear optimization problem. We do this to avoid that this output is printed in every interation of the for-loop.\nAlso note that the objective function is defined as s1[i]*x1 + s2[i]*x2 meaning that in iteration i, the objective function uses the values s1[i] and s2[i] (which are therefore different in every iteration as they depend on i).\nIn the print() statement we print a combination of text and the values i+1, x1.X and x2.X where the latter two are the values of the optimal solution in scenario i+1.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Monte Carlo simulation</span>"
    ]
  },
  {
    "objectID": "05-monte-carlo-simulation.html#scenario-analysis",
    "href": "05-monte-carlo-simulation.html#scenario-analysis",
    "title": "5  Monte Carlo simulation",
    "section": "",
    "text": "x_1: Number of chairs\nx_2: Number of tables\n\n\n\n\n\nScenario\ns_1\ns_2\nOptimal solution\n\n\n\n\n1\n15\n20\n(2,2)\n\n\n2\n9\n25\n(0,3)\n\n\n3\n20\n19\n(4,0)\n\n\n4\n16\n21\n(2,2)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Monte Carlo simulation</span>"
    ]
  },
  {
    "objectID": "05-monte-carlo-simulation.html#random-scenarios",
    "href": "05-monte-carlo-simulation.html#random-scenarios",
    "title": "5  Monte Carlo simulation",
    "section": "5.2 Random scenarios",
    "text": "5.2 Random scenarios\nIn the previous section, we chose the values of the objective function coefficients in every scenario ourselves. These can also be generated randomly using random number generation functions in Python contained in the NumPy package, which contains a lot of the mathematical functionality that Python has to offer.\nThis package is typically imported under the alias np, which is shorthand notation so that we do not have to type numpy everytime.\n\nimport numpy as np\n\nWe treat two functions for generating random numbers. The first one can be used to generate fractional random numbers.\n\nnp.random.rand(n) : Generates n random numbers from the interval [0,1].\n\nThe generated numbers are stored in a list. Technically speaking, they are stored in a NumPy array, which you can think of as a “mathematical” list (but this is not important for us).\n\nimport numpy as np\n\n# Generate five random (fractional) numbers from [0,1]\nx = np.random.rand(5)\n\n# Print the numbers\nprint(x)\n\n[0.87983832 0.21412419 0.1294719  0.48420194 0.44129602]\n\n\nNote that if you want to generate a (fractional) number from an interval [a,b], you can do this by generating a number x from the interval [0,1], multiplying this number by (b-a) and then adding a to the result.\nIn other words, if x is a random number from [0,1], then the number a + (b-a) \\cdot x is a random number from [a,b].\n\nimport numpy as np\n\n# Interval values\na = 3\nb = 7\n\n# Generate random (fractional) number from [0,1]\nx = np.random.rand(1)\n\n# Random number from interval [a,b] = [3,7]\ny = a + (b-a)*x\n\n# Random number from interval [a,b]\nprint(y)\n\n[3.21321503]\n\n\nNote that, in the above code snippet, even though we only generate one number, it is still given to us in a list. If you only want to get the number (not in a list) you should index the list at position 0. This is important if you want to use such a number for defining the objective function or a constraint.\n\nprint(y[0])\n\n3.2132150286167445\n\n\nYou can also generate multiple numbers from an interval [a,b] if x = [x_0, x_1, \\dots] is a list of numbers generated from [0,1]. If you multiply x with (b-a), then all numbers in the list are multiplied by (b-a), i.e., (b-a)*x = [(b-a)*x_0, (b-a)*x_1,\\dots]. Similarly, if we add a to (b-a)*x, then a is added to every number in the list (b-a)*x, i.e., we get a + (b-a)*x = [a + (b-a)*x_0, a + (b-a)*x_1, \\dots].\n\nimport numpy as np\n\n# Interval values\na = 3\nb = 7\n\n# Generate five random (fractional) numbers from [0,1]\nx = np.random.rand(5)\n\n# Five random numbers from interval [a,b] = [3,7]\ny = a + (b-a)*x\n\n# Print the numbers\nprint(y)\n\n[6.29617634 3.97447146 6.99756199 5.41748576 5.56632036]\n\n\nThe second function we discuss can generate integer-valued numbers from a specified range of integers:\n\nnp.random.randint(low=a, high=b, size=n) : Generates n random integers from the set \\{a, a+1, \\dots, b-1\\}.\n\n\nimport numpy as np\n\n# Generate five random integers from the set {2,3,4,5,6,7,8,9}\ny = np.random.randint(low=2, high=10, size=5)\n\n# Print the numbers\nprint(y)\n\n[4 8 9 9 8]\n\n\nWe can use these random numbers to generate random scenarios and then solve the Duplo example for those scenarios.\n\nfrom gurobipy import Model, GRB\n\n# Different 20 random scenarios\ns1 = np.random.randint(low=15, high=25, size=20) # Numbers from {15,16,...,24}\ns2 = np.random.randint(low=20, high=35, size=20) # Numbers from {20,12,...,34}\n\nfor i in range(0,20):\n    # Initialize Gurobi model.\n    duplo = Model(name='Duplo problem')\n\n    # Suppress Gurobi Optimizer output\n    duplo.setParam('OutputFlag',0)\n\n    # Declare the two decision variables.\n    x1 = duplo.addVar(name='chairs')\n    x2 = duplo.addVar(name='tables')\n    \n    # Specify the objective function in terms of s1[i], s2[i]\n    duplo.setObjective(s1[i]*x1 + s2[i]*x2, sense=GRB.MAXIMIZE)\n    \n    # Add the resource constraints on bricks.\n    duplo.addConstr(x1 + 2*x2 &lt;= 6, name='big-bricks')\n    duplo.addConstr(2*x1 + 2*x2 &lt;= 8, name='small-bricks')\n    \n    # Optimize the duplo\n    duplo.optimize()\n\n    # Print solution\n    print(\"Optimal solution for scenario\", i+1, \"is [\", x1.X, \",\", x2.X, \"]\")\n\nOptimal solution for scenario 1 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 2 is [ 4.0 , 0.0 ]\nOptimal solution for scenario 3 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 4 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 5 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 6 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 7 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 8 is [ 4.0 , 0.0 ]\nOptimal solution for scenario 9 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 10 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 11 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 12 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 13 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 14 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 15 is [ 0.0 , 3.0 ]\nOptimal solution for scenario 16 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 17 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 18 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 19 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 20 is [ 2.0 , 2.0 ]\n\n\nNote that the solution (2,2) appears very often, meaning it is a stable solution in the sense that even though the objective function coefficients change, the solution remains optimal.\nYou can also generate the random numbers inside of the for-loop. Note that in this case you should use s1[0] and s2[0] in the objective function. As discussed before, this is because s1 = np.random.randint(low=15, high=25, size=1) is a list of length 1, and so to get the number in this list, you have to index s1 at index 0.\nNote that in every iteration, first two random numbers s1 and s2 are generated, which are then later used to define the objective function. Because new numbers are generated at the start of every iteration, we are solving a different problem every time.\n\nfrom gurobipy import Model, GRB\n\nfor i in range(0,20):\n    # Generate random coefficients\n    s1 = np.random.randint(low=15, high=25, size=1)\n    s2 = np.random.randint(low=15, high=25, size=1)\n\n    # Initialize Gurobi model.\n    duplo = Model(name='Duplo problem')\n\n    # Suppress Gurobi Optimizer output\n    duplo.setParam('OutputFlag',0)\n\n    # Declare the two decision variables.\n    x1 = duplo.addVar(name='chairs')\n    x2 = duplo.addVar(name='tables')\n    \n    # Specify the objective function in terms of s1[0], s2[0]\n    duplo.setObjective(s1[0]*x1 + s2[0]*x2, sense=GRB.MAXIMIZE)\n    \n    # Add the resource constraints on bricks.\n    duplo.addConstr(x1 + 2*x2 &lt;= 6, name='big-bricks')\n    duplo.addConstr(2*x1 + 2*x2 &lt;= 8, name='small-bricks')\n    \n    # Optimize the duplo\n    duplo.optimize()\n\n    # Print solution\n    print(\"Optimal solution for scenario\", i+1, \"is [\", x1.X, \",\", x2.X, \"]\")\n\nOptimal solution for scenario 1 is [ 4.0 , 0.0 ]\nOptimal solution for scenario 2 is [ 4.0 , 0.0 ]\nOptimal solution for scenario 3 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 4 is [ 4.0 , 0.0 ]\nOptimal solution for scenario 5 is [ 4.0 , 0.0 ]\nOptimal solution for scenario 6 is [ 4.0 , 0.0 ]\nOptimal solution for scenario 7 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 8 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 9 is [ 4.0 , 0.0 ]\nOptimal solution for scenario 10 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 11 is [ 4.0 , 0.0 ]\nOptimal solution for scenario 12 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 13 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 14 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 15 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 16 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 17 is [ 4.0 , 0.0 ]\nOptimal solution for scenario 18 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 19 is [ 2.0 , 2.0 ]\nOptimal solution for scenario 20 is [ 2.0 , 2.0 ]",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Monte Carlo simulation</span>"
    ]
  }
]