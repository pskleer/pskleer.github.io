[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python for Econometrics and Operations Research",
    "section": "",
    "text": "1 Welcome\nWelcome to the online “book” that serves as an introduction to the programming language Python, that you will see in various courses throughout the Econometrics and Operations Research (EOR) bachelor program.\nThe first part of this book is used for the “Python crash course” announced during the course Linear Algebra. The crash course consists of two (recommended) lectures that will form a useful basis for various programming assignments in the EOR bachelor program, including the assignment of the (mandatory) course Linear Optimization in the second quartile of the first year.\nThe two crash course lectures (taught only in English) are outlined below, including links to the lecture materials. To program in Python, we will use the Jupyter Notebook application in which we can execute Python code.\nBefore we jump into coding with Python, we will start by discussing what programming is at the most basic level and motivating why we are learning how to code in Python in the first place.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome</span>"
    ]
  },
  {
    "objectID": "index.html#what-is-a-programming-language",
    "href": "index.html#what-is-a-programming-language",
    "title": "Python for Econometrics and Operations Research",
    "section": "1.1 What is a programming language?",
    "text": "1.1 What is a programming language?\nWithout getting into complicated details, a programming language is a way to communicate to a computer, via written text, tasks or operations that you want it to carry out. This is very different to how we often usually interact with a computer, which often involves pointing and clicking on different buttons and menus with your mouse.\nIn the EOR bachelor program, the goal is often to tell a computer to carry out complicated numerical computations or to visualize numerical data. To some extent, you have already done this in high school using a graphing calculator. In fact, everything that your graphing calculator can do, you can also do with Python, but the advantage of Python is that it can also handle much more complicated tasks.\nTo use Python in a correct fashion, it is important that you understand the grammar, i.e., “syntax”, of the Python programming language. When humans speak to each other and someone makes a grammar mistake, it usually isn’t a big deal. We usually know what they mean. But if you make a “syntax error”, i.e, grammar mistake in a programming language, it won’t understand what you mean. The computer will throw an error.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome</span>"
    ]
  },
  {
    "objectID": "index.html#why-python",
    "href": "index.html#why-python",
    "title": "Python for Econometrics and Operations Research",
    "section": "1.2 Why Python?",
    "text": "1.2 Why Python?\nThere are many different programming languages out there: C, C++, C#, Java, JavaScript, R, Julia, Stata, MATLAB, Fortran, Ruby, Perl, Rust, Go, Lua, Swift - the list goes on. So why should we learn Python over these other alternatives?\nThe best programming language depends on the task you want to accomplish. Are you building a website, writing computer software, creating a game, or analyzing mathematical data? While many languages could perform all of these tasks, some languages excel in some of them.\nPython is by far the most popular programming language when it comes to “data science” tasks, that you will often encounter in the EOR bachelor program. It is also often used in web development, creating desktop applications and games, and for scientific computations. It is therefore a very versatile programming language that can complete a very wide range of tasks.\nPython is also completely free and open source and can run on all common operating systems. This means you can share your code with anyone and they will be able to run it, no matter what computer they are on or where they are in the world.\nThere is also a very large active community that creates packages to do a wide-range of operations, keeping Python up to date with the latest developments. For example, excellent community help is available at Stackoverflow, so if you Google how to do something in Python most likely that question has already been answered on Stackoverflow. Funnily enough, a key skill to develop with programming is how to formulate your question into Google to land on the right Stackoverflow page.\nMore recently, “large-language” models like ChatGPT have become a very useful resource for Python. ChatGPT can write excellent Python code and also explains all the steps it takes, so we encourage you to use it as a tool to help you when you are stuck.\nYou should keep in mind though, that throughout the bachelor program, you will not always be allowed to use tools like ChatGPT. It is also important that you understand basic programming concepts to catch errors that AI might introduce (do not forget that LLMs are merely predicting text and not “consciously” writing a script), or to help improve your AI-prompt writing skills.\nThese days employers are increasingly looking to hire people with programming skills. Knowing how to program in Python - one of the most commonly used languages by companies - is therefore a very valuable addition to your CV.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome</span>"
    ]
  },
  {
    "objectID": "02-installation.html",
    "href": "02-installation.html",
    "title": "2  Software",
    "section": "",
    "text": "2.1 Installing Anaconda\nIn this chapter we will learn how to install Python and run our very first command.\nThe easiest way to install Python and Jupyter Notebook is by installing Anaconda, which is a software package that includes Python, Jupyter Notebook, and other software applications. You can install Anaconda by visiting https://www.anaconda.com/download.\nYou should see this page:\nYou should click the “Skip registration” button (although feel free to register if you like). You will then see the following page:\nYou should then click on the “Download” button. Mac users will see a Mac logo instead.\nAfter downloading the file, click on it to install it. Follow the installation wizard and keep all the default options during installation.\nAfter installation you will see a number of new applications on your computer. You can see all applications that were installed using Anaconda Navigator. You can open the navigator by searching for it in the Start menu (on Windows).\nWe highlight two applications:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Software</span>"
    ]
  },
  {
    "objectID": "02-installation.html#installing-anaconda",
    "href": "02-installation.html#installing-anaconda",
    "title": "2  Software",
    "section": "",
    "text": "Anaconda Download Page\n\n\n\n\n\n\nAnaconda Download Page\n\n\n\n\n\n\n\n\nAnaconda Navigator\n\n\n\n\nJupyter Notebook. This is a web application that allows you to write a notebook (like a report) with text and Python code snippets with output. We will learn how to use this application later on.\nSpyder/VS Code. These are computer applications that allows you to write Python scripts and execute them to see the output. Such an application is called an Integrated Desktop Environment (IDE).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Software</span>"
    ]
  },
  {
    "objectID": "02-installation.html#sec-jn",
    "href": "02-installation.html#sec-jn",
    "title": "2  Software",
    "section": "2.2 Jupyter Notebook",
    "text": "2.2 Jupyter Notebook\nYou can open the Jupyter Notebook application either by pressing ‘Launch’ in the Anaconda Navigator, or you can search for the application directly on your (university) computer via the Start menu.\nThe application will open as a tab in a web browser, and you should then see a list of folders.\n\n\n\nJupyter Notebook application\n\n\n\n2.2.1 Creating new notebook\nYou can navigate to a folder and then create a new notebook by clicking on ‘New’ in the top-right and then selecting ‘Python 3 (ipykernel)’ under Notebook.\n\n\n\nCreating notebook\n\n\nThe new notebook will open in another tab and is stored in the folder in which you created it, typically under the name ‘Untitled.ipynb’. You can change the name of the file either in the folder in which you stored it, or via File -&gt; Rename in the top-left corner. You should see the empty notebook as below.\n\n\n\nNew notebook\n\n\nIn the bar you can type Python code. Let us execute our first code, which is a simple calculation 1 + 1. To find 1+1 in Python, we can use the command 1+1, similar to how we would do it in Excel or in the Google search engine. Let’s try this out. Type 1+1 in the code bar and click \\blacktriangleright Run  (or hit Shift + Enter on your keyboard). We will see the output 2 on the next line next to a red Out [1]:\n\n\n\nFirst Python code\n\n\nThe red Out [1] means this is the output from the code snippet In [1] executed in this notebook. If we continue typing code in the second bar, it will be called In [2] and its output Out [2]. However, the same happens if we would re-run the first code snippet with 1+1: It will also be called In [2] and its output Out [2]. The index keeps track of how many code snippets have been executed in the notebook.\n\n\n2.2.2 Opening existing notebook\nThe extension of a Jupyter Notebook file is .ipynb and sometimes denoted as Jupyter Source File. If you have stored such a file on your computer, you can open in it Jupyter Notebook as follows:\n\nOpen Jupyter Notebook (see above) and navigate to the folder where you stored the file.\nClick on the .ipynb file and then it should open in a new tab of the browser.\n\n\n\n\n\n\n\nWarningWARNING about files on university computer\n\n\n\nIf you store a file on a (TiU) university computer, for example in the Downloads folder, it will typically be deleted when you log out. To avoid this, either:\n\nCopy the file onto a USB drive.\nE-mail the file to yourself.\nStore it on the M: drive (that is denoted by the drive that has your name) of the university computer, whose files are not deleted.\n\nNext time you want to use a file, put it again in the Downloads folder to work on it (and make sure to back it up properly again afterwards).\n\n\nIf you want to open a .ipynb file that is located in the M: drive of a university computer, you need to open Jupyter Notebook differently than explained above (because you cannot navigate to the M: drive if you open Jupyter Notebook via the Start menu). Instead, do the following:\n\nClose all instances of Jupyter Notebook if any are running.\nLook up the Anaconda Prompt application in the Start menu and Run it.\nType jupyter notebook --notebook-dir=M: and press Enter\nJupyter Notebook should now open in the web browser showing the files and folders of the M: drive\nOpen the desired .ipynb file to work on it.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Software</span>"
    ]
  },
  {
    "objectID": "02-installation.html#code-snippets-in-this-book",
    "href": "02-installation.html#code-snippets-in-this-book",
    "title": "2  Software",
    "section": "2.3 Code snippets in this book",
    "text": "2.3 Code snippets in this book\nIn this book, we won’t always show screenshots like we did above. Instead we will show code snippets in boxes like this:\n\n1 + 1\n\n2\n\n\nThe part that is code will be in color and there will be a small clipboard icon on the right which you can use to copy the code to paste into your own Notebook to be able to experiment with it yourself. The output from the code will always be in a separate gray box below it (without a clipboard icon).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Software</span>"
    ]
  },
  {
    "objectID": "03-basics.html",
    "href": "03-basics.html",
    "title": "3  Python basics",
    "section": "",
    "text": "3.1 Arithmetic operations\nIn this chapter we will learn how to use Python as a calculator and see some basic programming concepts.\nWe start with the most basic arithmetic operations: Addition, subtraction, multiplication and division are given by the standard +, -, * and / operators that you would use in other programs like Excel. For example, addition:\n2 + 3\n\n5\nSubtraction:\n5 - 3\n\n2\nMultiplication:\n2 * 3\n\n6\nDivision:\n3 / 2\n\n1.5\nIt is also possible to do multiple operations at the same time using parentheses. For example, suppose we wanted to calculate: \n\\frac{2+4}{4 \\cdot 2} = \\frac{6}{8} = 0.75\n We can calculate this in Python as follows:\n(2 + 4) / (4 * 2)\n\n0.75\nWith the ** operator (two stars) we can raise a number to the power of another number. For example, 2^3=2\\times 2\\times 2 = 8 can be computed as\n2 ** 3\n\n8",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "03-basics.html#arithmetic-operations",
    "href": "03-basics.html#arithmetic-operations",
    "title": "3  Python basics",
    "section": "",
    "text": "WarningWARNING\n\n\n\nDo not use ^ for exponentiation. This actually does a very different thing in Python.\n\n\n\n\n\n\n\n\nTipExercise 3.1\n\n\n\nCompute the following expressions using the operator +, -, *, / and **:\n\n3 + 5 \\cdot 2\n\\frac{(10 - 4)^2}{3}\n\\frac{\\left((2 + 3) \\cdot 4 - 5\\right)^2}{3 + 1}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "03-basics.html#variables",
    "href": "03-basics.html#variables",
    "title": "3  Python basics",
    "section": "3.2 Variables",
    "text": "3.2 Variables\nIn Python we can assign single numbers to variables and then work with and manipulate those variables.\nAssigning a single number to a variable is very straightforward. We put the name we want to give to the variable on the left, then use the = symbol as the assignment operator, and put the number to the right of the =. The = operator binds a number (on the right-hand size of =) to a name (on the left-hand side of =).\nTo see this at work, let’s set x=2 and y=3 and calculate x+y:\n\nx = 2\ny = 3\nx + y\n\n5\n\n\nWhen we assign x=2, in our code, the number is not fixed forever. We can assign a new number to x. For example, we can assign the number 6 to x instead. The sum of x (which is 6) and y ( which is 3), is now 9:\n\nx = 6\nx + y\n\n9\n\n\nFinally, you cannot set x=2 with the command 2 = x. That will result in an error. The name must be on the left of = and the number must be on the right of =.\n\n\n\n\n\n\nTipExercise 3.2\n\n\n\nDefine variables a,b,c with numbers 19, 3 and 7, respectively. Compute the following expressions:\n\na + b \\cdot c\n\\frac{(a - c)^2}{b}\n\\frac{((b + c) \\cdot a - c^2)^2}{a + b}\n\n\n\n\nIf you want to print multiple expressions within the same code snippet, you can use the print() function of Python for each of the expressions.\n\nx = 2\ny = 3\nprint(x + y)\nprint(x - y)\n\n5\n-1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "03-basics.html#lists",
    "href": "03-basics.html#lists",
    "title": "3  Python basics",
    "section": "3.3 Lists",
    "text": "3.3 Lists\nWe can also store multiple variables in one object, a so-called list. A list with numbers is created by writing down a sequence of numbers, separated by commas, in between two brackets [ and ].\n\nz = [3, 9, 1, 7]\nz\n\n[3, 9, 1, 7]\n\n\nWe can also create lists with fractional numbers.\n\nz = [3.1, 9, 1.9, 7]\nz\n\n[3.1, 9, 1.9, 7]\n\n\nTo access the numbers in the list, we can index the list at the position of interest. If we want to get the number at position i in the list, we use the syntax z[i].\n\nz[1]\n\n9\n\n\nSomething strange is happening here… The left-most number in the list is 3.1, but z[1] returns 9. This happens because Python actually starts counting at index 0 (instead of 1).\n\n\n\n\n\n\nNoteIndexing convention in Python\n\n\n\nThe left-most number in a Python list is located at position 0. The number next to that at position 1, etc. That is, the i-th number in a list with n numbers can be found at position i - 1 for i = 1,\\dots,n\n\n\nIn other words, the “first” number in the list is located at position 0, and we can access it using z[0] instead.\nBelow we index the number of the list at positions i \\in \\{0,1,2,3\\} separately.\n\nz[0]\n\n3.1\n\n\n\nz[1]\n\n9\n\n\n\nz[2]\n\n1.9\n\n\n\nz[3]\n\n7\n\n\n\n\n\n\n\n\nTipExercise 3.3\n\n\n\nConsider the list a = [11, 41, 12, 35, 6, 33, 7].\n\nCompute the sum of the numbers at even positions in a (i.e., positions 0, 2, 4, and 6).\nCompute the result of multiplying the first and last elements of a, then subtracting the middle element.\nCompute the square of the element at position 2, divided by the sum of the elements at the odd positions.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "03-basics.html#for-loop",
    "href": "03-basics.html#for-loop",
    "title": "3  Python basics",
    "section": "3.4 For-loop",
    "text": "3.4 For-loop\nSuppose we want to compute the sum of the numbers in the list a of Exercise 3.3. We could do this manually by indexing every number and adding them one by one.\n\na = [1, 4, 2, 5, 6, 3, 7]\n\na[0] + a[1] + a[2] + a[3] + a[4] + a[5] + a[6]\n\n28\n\n\n In fact, we can also define a new variable to store this number in. Let us call this variable total_sum.\n\na = [1, 4, 2, 5, 6, 3, 7]\n\ntotal_sum = a[0] + a[1] + a[2] + a[3] + a[4] + a[5] + a[6]\ntotal_sum\n\n28\n\n\n If the list is a is very long, for example containing thousands of elements, then it becomes very tedious to compute the total sum with the approach above. Such long lists are not uncommon in real-life data.\nA much better way is to use a for-loop, which lets us go through each element in the list one at a time. Here’s how we could compute the sum of the numbers in the list a using a for-loop:\n\na = [1, 4, 2, 5, 6, 3, 7]\ntotal_sum = 0\n\nfor i in [0,1,2,3,4,5,6]:\n    total_sum = total_sum + a[i]\n\nprint(total_sum)\n\n28\n\n\nLet’s break down what is happening here.\n\nWe first define the list a = [1, 4, 2, 5, 6, 3, 7].\nWe define the variable total_sum with initial value 0. This variable will be the running total of the numbers in a that we are adding up.  After the full code has been executed, this variable will contain the sum of all numbers in a, and its value is printed at the end using print(total_sum).\nThe line for i in [0,1,2,3,4,5,6]: indicates that we want to carry out a piece of code multiple times with different values for the variable i.\n\nThe words for and in are Python keywords, meaning they have a very specific purpose in Python. They get a different color when you type them in a code block.\nNote that the line should end with a colon :.\n\nThe piece of code that has to be run multiple times for i \\in \\{0,1,2,3,4,5,6\\} is total_sum = total_sum + a[i]. \n\nFor Python to understand that total_sum = total_sum + a[i] has to be executed with different values for i, we indent this line (using Tab on the keyboard).\nWe overwrite the value of total_sum with its current value plus the number at position i in a, i.e., the number a[i]. In the table below this process is illustrated for all the values of i.\n\n\n\n\n\ni\na[i]\ntotal_sum after this iteration\n\n\n\n\n0\n1\n0 + 1 = 1\n\n\n1\n4\n1 + 4 = 5\n\n\n2\n2\n5 + 2 = 7\n\n\n3\n5\n7 + 5 = 12\n\n\n4\n6\n12 + 6 = 18\n\n\n5\n3\n18 + 3 = 21\n\n\n6\n7\n21 + 7 = 28\n\n\n\nIn the first iteration of the for-loop (i = 0), we have the initial number 0 for total_sum so adding a[0] results in a new value of total_sum being 0 + 1 = 1.\nIn the second iteration, with now total_sum equal to 1, we add the number a[1], which results in the new value of total_sum being 1 (current number of total_sum) plus a[1] (which is 4), resulting in a new running total of 1 + 4 = 5.\nIf we would be interested in only computing, e.g., the sum of the first three numbers in a, we could replace the index list [0,1,2,3,4,5,6] by [0,1,2].\n\na = [1, 4, 2, 5, 6, 3, 7]\ntotal_sum = 0\n\nfor i in [0,1,2]:\n    total_sum = total_sum + a[i]\n\ntotal_sum\n\n7\n\n\n\n\n\n\n\n\nTipExercise 3.4\n\n\n\nCreate the list a = [1, 4, 2, 5, 6, 3, 7].\n\nCompute the sum of the numbers at the even indices using a for-loop.\nCompute the product of the numbers in a using a for-loop.\n\n\n\nIf you want to execute more lines of code in every iteration of the for-loop, you should indent all of them. In the code below we compute the running total total_sum and also use the print() command of Python to print the value of the running total after every addition. This results in all the values in the right column of the above table being printed.\n\na = [1, 4, 2, 5, 6, 99, 3]\ntotal_sum = 0\n\nfor i in [0,1,2,3,4,5,6]:\n    total_sum = total_sum + a[i]\n    print(total_sum)\n\n1\n5\n7\n12\n18\n117\n120\n\n\nOne final note to make is that this approach might still require a lot of typing if the list a contains many values. For example, if we are given a list of a thousand values, we would have to type a list with values 0 through 999 in the for-loop above.\nThere is a way to do this quicker, by using the range() function in Python. If we instead use the line for i in range(7):, then Python executes the indented code below for the values i = 0,1,2,3,4,5,6. Note that i = 7 is not included!\nIn general using for i in range(n): executes the indented lines below for the (in total n) values i = 0,1,2,\\dots,n-1.\n\na = [1, 4, 2, 5, 6, 99, 3]\ntotal_sum = 0\n\nfor i in range(7):\n    total_sum = total_sum + a[i]\n    print(total_sum)\n\n1\n5\n7\n12\n18\n117\n120",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "03-basics.html#conditional-statements",
    "href": "03-basics.html#conditional-statements",
    "title": "3  Python basics",
    "section": "3.5 Conditional statements",
    "text": "3.5 Conditional statements\nIn many programming situations, we want the computer to make decisions based on certain conditions. For example, if a number is negative, we might want to handle it differently than if it were positive. In Python, we can do this using conditional statements, also known as if/else statements.\nLet’s look at a basic example. We first make a general remark about printing text in Python.\n\n\n\n\n\n\nNotePrinting text\n\n\n\nIf you want to print text in Python, you should put it in between quotation marks.\n\nprint(\"Hello world\")\n\nHello world\n\n\nIf you want to print both text and variables, you can do that in the same print() command separating them with a comma.\n\nx = 3\nprint(\"The value of x is\", x)\n\nThe value of x is 3\n\n\nNote that in \"The value of x is\" part, the x-symbol is interpreted merely as a letter, not a variable.\n\n\nNow let us look at an example.\n\nx = 5\n\nif x &gt; 0:\n    print(\"x is positive\")\nelse:\n    print(\"x is not positive\")\n\nx is positive\n\n\nHere is what this code does:\n\nx = 5 assigns the number 5 to the variable x.\nif x &gt; 0: checks whether x is greater than zero, i.e, Python checks whether the condition x &gt; 0 is true or false. If the condition is true, it executes the indented code below, which is a print-statement in this case. Python then no longer checks the else: statement.\nIf the condition is false (i.e., x \\leq 0), then Python executes the indented code under else:, which is a different print-statement in this case.\n\nWe can also have multiple conditions using elif, which stands for “else if”. Below we add the third statement that checks if x is precisely equal to zero. Also here, as soon as Python reaches a statement that is true, it does not check the remaining statements anymore.\n\nx = 0\n\nif x &gt; 0:\n    print(\"x is positive\")\nelif x == 0:\n    print(\"x is zero\")\nelse:\n    print(\"x is negative\")\n\nx is zero\n\n\nIn the code above, we use the syntax x == 0 to define the statement that checks whether x is precisely equal to 0. You should not use x = 0 (otherwise Python would confuse this with assigning a value of 0 to the variable x, which is not what we want).\nThis checks the conditions one by one from top to bottom and executes the first indented code block where the condition is true. If you want more than three conditions, you should start with an if statement, then elif statements, and finish with an else.\nFinally, if you want to execute multiple lines of code for one or more of the conditions, you should indent all those lines under the respective conditions.\n\nx = 1\n\nif x &gt; 0:\n    print(\"x is positive\")\n    print(x)\nelif x == 0:\n    print(\"x is zero\")\nelse:\n    print(\"x is negative\")\n    print(x)\n\nx is positive\n1\n\n\n\n\n\n\n\n\nTipExercise 3.5\n\n\n\nCreate the list a = [1, 4, -4, 0, 5, -3, -7] in Python.\nUse a for-loop in combination with the code above to check for every number in a whether it is positive, zero, or negative. If a number is positive you should print the message \"The number is positive\", if it is zero \"The number is zero\" and if it is negative \"The number is negative\".\nThe output of your piece of code should be as follows.\n\n\nThe number is positive\nThe number is positive\nThe number is negative\nThe number is zero\nThe number is positive\nThe number is negative\nThe number is negative\n\n\n\n\nLet us now look at an example from mathematics. Suppose we want to compute the roots x of a quadratic equation of the form: \nax^2 + bx + c = 0\n Here a,b and c are known given numbers, and the goal is to find one or more x’s that satisfy the above equation.\nThe solution(s) to this problam are given by the quadratic formula (Dutch: abc-formule): \nx = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\n\nHere \\pm means that one solution is given by choosing a plus symbol in the place of \\pm, and the other solution by choosing the minus symbol.\nThe expression under the square root, called the discriminant D = b^2 - 4ac, determines how many (real) roots exist:\n\nIf D &gt; 0, the equation has two real roots.\nIf D = 0, the equation has exactly one real root.\nIf D &lt; 0, there are no (real) roots.\n\n\n\n\n\n\n\nTipExercise 3.6\n\n\n\nCreate variables a = 3, b = 2 and c = -1. Create a variable D for the discriminant (in terms of a,b and c).\n\nUse conditional statements to determine how many roots the quadratic formula ax^2 + bx + c has, based on the three possibilities for the discriminant. For each possibility, print an appropriate message in the indented code block. For the chosen a,b and c, the function has two roots (so this case should be printed in your code). \nUse conditional statements to print the roots x of the quadratic formula ax^2 + bx + c, based on the three possibilities for the discriminant (in the third case, do not print the roots, but a message saying there are no roots). Hint: If you want to print two variables y and z you can use print(y,z) or use print(y) and print(z) on different indented lines.  For the chosen a,b and c, your output should show the roots -1 and 0.333 (possibly with more or less decimals).\n\n\nYou can play around with your code by choosing different numbers for a,b and c, and see if you get different output cases for both questions above.\n\n\n\n\n\n\n\n\nTipExercise 3.7\n\n\n\nCreate the lists a = [3,7,1,4], b = [2,7,4,4] and c = [11,3,0,1]. Write a for-loop that executes your code of Exercise 3.6(ii) for every combination (a_i,b_i,c_i) where a_i,b_i,c_i are the numbers at position i in the lists a,b,c, respectively, for i = 0,1,2,3.\nYour output should look like this.\n\n\nThe formula has no real roots\nThe formula has no real roots\n-4.0 0.0\n-0.5\n\n\n\n\n\n\n\n\n\n\nTipExercise 3.8 (bonus)\n\n\n\nSuppose we are given a list g = [9.1, 1.3, 5.4, 5.6, 5.74, 6.74, 8.25, 9.2, 7.1, 6.9] of student grades.\n\nWrite a Python code that rounds every grade to the nearest half integer, i.e., to the value in the set \\{0, 0.5,1, 1.5,2,2.5,\\dots,8,8.5,9,9.5,10\\} it is closest to, and print this value. Hint: You can round a number to its closest integer by using the round() function. For example round(5.3) gives 5, and round(5.9) gives 6. Think of a way to use the round() function to round to half integers.\n\nOn g as given, the output should be as follows.\n\n\n9.0\n1.5\n5.5\n5.5\n5.5\n6.5\n8.0\n9.0\n7.0\n7.0\n\n\n\nAdjust your code so that grades that lie in the interval (5,6) are rounded either up to 6 or down to 5 depending which of the two a number is closest to (in other words, rounding to 5.5 is no longer allowed). Hint: You can use the and keyword to check multiple conditions in an if-statement.\n\nOn g as given, the output should be as follows.\n\n\n9.0\n1.5\n5\n6\n6\n6.5\n8.0\n9.0\n7.0\n7.0\n\n\nThe latter procedure is in fact how your grades in the EOR bachelor program are rounded.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "03-basics.html#sec-math-basics",
    "href": "03-basics.html#sec-math-basics",
    "title": "3  Python basics",
    "section": "3.6 Math basics",
    "text": "3.6 Math basics\nIn this chapter we will see some of the basic math functionality that Python has to offer. Many of these tasks can be carried out by your graphing calculator as well, but Python can also handle much more difficult problems that you will see in the course of you academic career.\nWe start with the basics of defining a function, such as a quadratic formula.\n\n3.6.1 Python function\nIf we want to compute a certain mathematical expression for many different variables, it is often convenient to use a Python function for this.\nFor example, consider the quadratic function f(x) = x^2 + 2x^2 -1. Say we want to know the values of f(-3), f(-2.5), f(1) and f(4). What we would like to do is to ‘automate’ the computation of a function value, so that we do not have to write out the whole function everytime.\nFor this we can use a Python function for this as follows.\n\ndef f(x):\n    return x**2 + 2*x - 1\n\nWhat does the code above do? First of all the syntax to tell Python we want to define a function called f that takes as input a number x is def f(x):.\nWe next have to tell Python what the function is supposed to compute. On the second line, with one tab indented, we have the return statement. Here we write down the expression that the function should return (or compute), which in our case is the function value f(x) = x^2 + 2x^2 -1.\nWe can now compute the function value f(x) for any value of x. What happens is that Python calls the function f with input the chosen value of x, and then returns the function value f(x), i.e., the expression in the return statement.\n\nf(-2)\n\n-1\n\n\n\nf(1)\n\n2\n\n\nNote that you can also name the function differently, for example we could also have done def quadratic_function(x):. You should then use the name quadratic_function too in the command well you call the Python function to compute the function value f(x).\n\ndef quadratic_function(x):\n    return x**2 + 2*x - 1\n    \nquadratic_function(1)\n\n2\n\n\nJust as your graphing calculator we can plot a Python function, search for its roots, integrate a certain area under the curve and much more! More advanced tasks that Python can handle will introduced in later courses in the EOR bachelor program.\nIf you want to get a better understanding of the codes in the coming sections, you could already have a look at Chapter 9 of this course document of another course taught at the Tilburg School of Economics and Management. We do not explain the code here, but give it as a teaser what more is possible with Python!\n\n\n3.6.2 Plotting\nConsider again the function f(x) = x^2 + 2x - 1. A visualization of this function is given below. If you want to plot a function in Python you have to make use of functionality from NumPy and Matplotlib which are so-called Python packages.\nPackages are functions written by other people to make our live easy, i.e., so that we do not have to write every code file from scratch in Python.\n\n\n\nShow code generating the plot below\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the x range\nx = np.linspace(-3, 3, 600)\n\n# Define the function f\ndef f(x):\n    return x**2 + 2*x -1\n\n# Create the plot\nplt.figure(figsize=(6, 4))\nplt.plot(x, f(x), label='$f(x) = x^2 + 2x - 1$')\n\n# Add labels and title\nplt.title('Plot of the function f on the interval [-3,3]')\nplt.xlabel('x')\nplt.ylabel('f(x)')\n\n# Add a grid\nplt.grid(True)\n\n# Set range\nplt.xlim(-3,3)\nplt.ylim(-4,14)\n\n# Add a legend\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n3.6.3 Root finding\nSimilarly, the SciPy package can be used to carry out various mathematical tasks and algorithms, making it very important for data analysis purposes.\nThe code below uses a pre-written Python function called fsolve() from SciPy to compute the roots of a function f. In other words, fsolve() is a mathematical algorithm for finding the root of a function, such as Newton’s method, that someone implemented in Python and made available publicly for the whole world to use. If you are interested in the source code of this function, you can look it up in the documentation of Python (more specifically, SciPy in this case).\n\nimport scipy.optimize as optimize\n\ndef f(x):\n    return x**2 + 2*x - 1\n\nguess = 3\nf_zero = optimize.fsolve(f,guess) \n\nprint(\"A root of the function f is given by\", f_zero)\n\nA root of the function f is given by [0.41421356]\n\n\nThe function fsolve() takes two inputs: a function of which we want to find a root, and an initial guess (3 in our case) of where the root is.\nEntering an initial guess for where the root is located, is in some sense the equivalent of giving a bracket in which the root should lie on your graphing calculator. In fact, there are other root finding functions available in Python that work in this way, i.e., that require you to give an initial bracket, just as you do on your graphing calculator.\nDifferent initial guesses might lead to different roots found by Python. In fact, as you can see the function f has two roots of which the above code finds the right one. We could find the left root by filling in a different initial guess, e.g., -3 instead of 3.\n\nguess = -3\nf_zero = optimize.fsolve(f,guess) \n\nprint(\"A root of the function f is given by\", f_zero)\n\nA root of the function f is given by [-2.41421356]\n\n\n\n\n3.6.4 Integration\nFinally, it is also possible to use built-in functionality from SciPy to integrate a function. Below we integrate the function f from 0 to 2. This integral area is illustrated in the figure below.\n\n\n\nShow code generating the plot below\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the x range for the full plot\nx = np.linspace(-3, 3, 600)\n\n# Define the function f\ndef f(x):\n    return x**2 + 2*x - 1\n\n# Create the plot\nplt.figure(figsize=(6, 4))\nplt.plot(x, f(x), label='$f(x) = x^2 + 2x - 1$')\n\n# Define the interval for shading (0 to 2)\nx_fill = np.linspace(0, 2, 300)\nplt.fill_between(x_fill, f(x_fill), alpha=0.3, color='orange', \n    label='Area under $f(x)$ from 0 to 2')\n\n# Add labels and title\nplt.title('Plot of function $f$ and shaded integral area from 0 to 2')\nplt.xlabel('x')\nplt.ylabel('f(x)')\n\n# Add a grid\nplt.grid(True)\n\n# Set axis limits\nplt.xlim(-3, 3)\nplt.ylim(-4, 14)\n\n# Add a legend\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\nfrom scipy.integrate import quad\n\n# Define the function to integrate\ndef f(x):\n    return x**2 + 2*x - 1\n\n# Perform the integration from 0 to 2\nresult, error = quad(f, 0, 2)\n\n# Print the result\nprint(\"Integral of f(x) from 0 to 2 is:\", result)\nprint(\"Numerical error in integral computation is at most\", error)\n\nIntegral of f(x) from 0 to 2 is: 4.666666666666666\nNumerical error in integral computation is at most 5.666271351443603e-14\n\n\n\n\n3.6.5 Why Python and not my calculator?\nSo far we have illustrated task with Python that you graphing calculator can also carry out. The advantage of Python is that it can handle much more complicated computing tasks and handle much more difficult mathematical functions, that your graphing calculator is not able to handle.\nMany of these tasks you will come across in various courses of the EOR bachelor program, already starting with the course Linear Optimization in the second quartile of year 1.\nFurthermore, throught the EOR bachelor program you will also see some other programming languages such as R and Matlab. Many of the general programming ideas, such as for-loops and conditional statements, exist in those languages as well, but sometimes the syntax (i.e., the grammar of the programming language) is different than that of Python.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "04-lin-alg.html",
    "href": "04-lin-alg.html",
    "title": "4  Linear algebra",
    "section": "",
    "text": "4.1 Packages\nIn this chapter we will learn how to use Python for linear algebra.\nIn the first session of this crash course you have learned the basics of Python: how to use Python as a calculator, use lists, for-loops, and if-else-statements.\nPython can be used for much more advanced operations as well. As you can imagine, code quickly grows more complicated. Fortunately, we can reuse code written by other through so-called packages (or libraries). In the optional Section 3.6 you might have seen several packages already.\nUsing packages has several advantages. If you use a standard package, then it makes your code more readable. It also reduces the risk of errors: Python packages are typically developed by expert programmers and thoroughly tested before they are released to the public. For the mainstream packages that we will be using, you can thus be reasonably confident that they deliver what they promise.\nAnother major advantage of packages is that they are often heavily optimized in terms of speed and memory efficiency.1\nToday we will use several well-known packages:\nIn a nutshell: packages are functions written by other people to make our life easy, i.e., so that we do not have to write every code file from scratch in Python.\nThe NumPy, SymPy and Matplotlib packages should be installed in a standard Anaconda installation. If you have another Python installation, typically using the PIP package manager should allow you to install packages. In this case, commands like pip install numpy and pip install sympy should do the job.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear algebra</span>"
    ]
  },
  {
    "objectID": "04-lin-alg.html#packages",
    "href": "04-lin-alg.html#packages",
    "title": "4  Linear algebra",
    "section": "",
    "text": "NumPy,\nSympy,\nand Matplotlib.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear algebra</span>"
    ]
  },
  {
    "objectID": "04-lin-alg.html#why-numpy-and-sympy",
    "href": "04-lin-alg.html#why-numpy-and-sympy",
    "title": "4  Linear algebra",
    "section": "4.2 Why numpy and sympy?",
    "text": "4.2 Why numpy and sympy?\nThe package numpy is designed for fast numerical calculations, e.g., with matrices. We can compute matrix products, solve linear systems, and compute inverses with numpy very quicky. The package sympy, on the other hand, is a symbolic mathematics library. It can do exact algebraic manipulations (also with variables x and y), but it is less quick than numerical computations with numpy. sympy also contains a method to do exact row-reduction, to bring a matrix into reduced echelon form. This may also be useful if you did row-reduction by hand and want to verify your result with the computer.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear algebra</span>"
    ]
  },
  {
    "objectID": "04-lin-alg.html#basic-matrix-and-vector-operations-with-numpy",
    "href": "04-lin-alg.html#basic-matrix-and-vector-operations-with-numpy",
    "title": "4  Linear algebra",
    "section": "4.3 Basic matrix and vector operations with Numpy",
    "text": "4.3 Basic matrix and vector operations with Numpy\nSuppose we have the following vectors \\mathbf{x} and \\mathbf{y}, and matrix A: \n\\mathbf{x}=\\left[\\begin{array}{c}1\\\\2\\\\3 \\end{array} \\right], \\mathbf{y}=\\left[\\begin{array}{c}4\\\\5\\\\7 \\end{array} \\right],  A =  \\begin{bmatrix} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{bmatrix}\n\nWe can define vectors in Python as so-called NumPy arrays. Think of these as lists (that we saw earlier) on which we can perform numerical computations. To create such arrays, we have to import the NumPy package numpy. We do this under the alias np (so that we can use the short-hand notation np for numpy everywhere).\n\nimport numpy as np\n\n# Define the vectors and matrix\nx = np.array([1, 2, 3])\ny = np.array([4, 5, 7])\nA = np.array([[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]])\n\nIn Python, we can add vectors, compute the matrix-vector product and multiply matrices. Note: To compute a matrix-vector product you use the command A@x. What happens if you use the command A*x? Now, try to compute A\\mathbf{x}, A\\mathbf{y}, and A(\\mathbf{x}+\\mathbf{y}) with Python. What do you notice?\n\n# your code here",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear algebra</span>"
    ]
  },
  {
    "objectID": "04-lin-alg.html#application-input-output-models",
    "href": "04-lin-alg.html#application-input-output-models",
    "title": "4  Linear algebra",
    "section": "4.4 Application: input-output models",
    "text": "4.4 Application: input-output models\n(From Python Linear Algebra Notebook by Herbert Hamers)\nA chemical plant receives oil from three different regions: the Middle East, South America, and the NorthSea. The quality of the oil is different for each region. These oils will be used to produce gasoline, diesel fuel, and bike chain oil. The oil from the Middle east will be only used for the production of gasoline. Of the oil of South America, 20 % will be used for the production of gasoline, and 80 % for the production of diesel fuel. Finally, 25 % of the North Sea oil will be used to produce gasoline, 25 % to produce diesel fuel, and 50 % for the production of bike chain oil.\nSuppose today a shipment arrives of 5000 barrels of oil from the Middle East, 9000 barrels of oil from South America, and 1000 barrels from the North Sea. The plant wants to know how much gasoline, diesel fuel, and bike chain oil it can produce from this shipment.\nObviously, the 5000 barrels of oil from the Middle East will completely be used for the production of gasoline, i.e. 1\\cdot 5000 = 5000 barrels of gasoline. Of the 9000 barrels of South America oil, 20 % will be used for the production of gasoline. Hence, this leads to 0.2 \\cdot 9000 = 1800 barrels of gasoline. Finally, of the 1000 barrels of North sea oil 25 % will be used for the production of gasoline. Hence, we obtain 0.25\\cdot 1000 = 250 barrels of gasoline. Hence, the total number of barrels of gasoline that will be produced is \n1 \\cdot 5000 + 0.2 \\cdot 9000 + 0.25 \\cdot 1000 = 5000+1800+250=7050.\n By a similar computation, one can compute the total number of barrels of diesel fuel: \n0 \\cdot 5000 + 0.8 \\cdot 9000 + 0.25 \\cdot 1000 = 7450.\n Finally, one can show that the total number of barrels of bike chain oil is 500, using a similar computation.\nThe production process can be summarized using the matrix-vector product. The production process is represented by the following matrix \n\\begin{bmatrix} 1 & 0.2 & 0.25 \\\\ 0 & 0.8 & 0.25 \\\\ 0 &0 &0.5 \\end{bmatrix},\n where the first column represents the division in the three end products of the Middle East oil, the second column represents the division in the three end products of the South America oil, and the third column represents the division in the three end products of the North Sea oil.\n\nA=np.array([[1,0.2,0.25],[0,0.8,0.25],[0,0,0.5]])\nprint(A)\n\n[[1.   0.2  0.25]\n [0.   0.8  0.25]\n [0.   0.   0.5 ]]\n\n\nThe shipment of the oil can be summarized by the following vector: \nq = \\begin{bmatrix} 5000 \\\\ 9000 \\\\ 1000 \\end{bmatrix}\n\nUsing the matrix-vector product, it can easily be calculated how much gasoline, diesel fuel, and bike chain oil can be produced from this oil-delivery: \nAq = \\begin{bmatrix} 1 & 0.2 & 0.25 \\\\ 0 & 0.8 & 0.25 \\\\ 0 &0 &0.5 \\end{bmatrix} \\begin{bmatrix} 5000 \\\\ 9000 \\\\ 1000 \\end{bmatrix} = \\begin{bmatrix} 1 \\cdot 5000 + 0.2 \\cdot 9000 + 0.25 \\cdot 1000 \\\\ 0 \\cdot 5000 + 0.8 \\cdot 9000 + 0.25 \\cdot 1000\\\\ 0 \\cdot 5000 + 0 \\cdot 9000 + 0.5 \\cdot 1000  \\end{bmatrix}  = \\begin{bmatrix} 7050 \\\\ 7450 \\\\ 500 \\end{bmatrix}\n\nHence, using the matrix-vector product we come to the same conclusion: the oil-delivery will result in 7050 barrels of gasoline, 7450 barrels of diesel fuel, and 500 barrels of bike chain oil.\nThe next day a shipment of 10000 barrels of oil from the Middle East, 1000 barrels of South America, and 200 barrels of the North Sea arrives. Determine the output of gasoline, diesel fuel, and key chain oil of this oil-delivery.\n\n# your code here\n\nLet us continue with a variation on the above problem.\nNow, a chemical plant receives oil from five different regions: the Middle East, South America, the North Sea,Africa and Asia. Again, the quality of the oil is different for each region. These oils will be used to produce gasoline, diesel fuel, bike chain oil, fuel 95 and fuel 98. The oil from the Middle east will be only used for the production of gasoline. Of the oil of South America, 20% will be used for the production of gasoline, and 80% for the production of diesel fuel. 25% of the North Sea oil will be used to produce gasoline, 25% to produce diesel fuel, and 50% for the production of bike chain oil. Of the oil of Africa, 10% will be used for the production of gasoline, 10% for the production of bike chain oil, 30% for the production of fuel 95 and 50% for the production of fuel 98. Finally, 30% of the Asia oil will be used to produce gasoline, 5 % to produce diesel fuel, 50 % for the production of fuel 95, and 15% for the production of fuel 98.\nSuppose today a shipment arrives of 5000 barrels of oil from the Middle East, 9000 barrels of oil from South America, 1000 barrels from the North Sea, 4000 barrels of oil from Africa, and 4000 barrels of oil from Asia. The plant wants to know how much gasoline, diesel fuel, bike chain oil, fuel 95, and fuel 98 it can produce from this shipment.\nWith the new information A will be a 5x5 matrix and q will be a 5x1 vector. Determine the output of gasoline, diesel fuel, bike chain oil, fuel 95, and fuel 98 of this oil-delivery.\n\n# your code here",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear algebra</span>"
    ]
  },
  {
    "objectID": "04-lin-alg.html#matrix-operations-inverse-determinant-solving-linear-systems",
    "href": "04-lin-alg.html#matrix-operations-inverse-determinant-solving-linear-systems",
    "title": "4  Linear algebra",
    "section": "4.5 Matrix operations: inverse, determinant, solving linear systems",
    "text": "4.5 Matrix operations: inverse, determinant, solving linear systems\nAssuming we imported NumPy under the alias np, the module np.linalg from NumPy contains several standard linear algebra methods that we will encounter today.\n\ndet(A): Determinant of matrix A\ninv(A): Inverse of matrix A\nsolve(A,b): Solution to linear system A x =b\n\nTo use such a method, you should use the syntax np.linalg.method_name with method_name replaced by one of the three options above.\n\nimport numpy as np\n\nA = np.array([[0,1],[1,0]]) #Define A\nprint(A)\n\nprint(\"The determinant of A is\", np.linalg.det(A))\n\n[[0 1]\n [1 0]]\nThe determinant of A is -1.0\n\n\nExercise 5.1:\n\nCompute the determinant of the following matrices\n\n\nA = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}, \\qquad B = \\begin{pmatrix} 1 & 2 & 3 \\\\ 2 & 3 & 4 \\\\ 1 & 1 & 1 \\end{pmatrix}, \\qquad C = \\begin{pmatrix} 1 & 3 & 2 \\\\ 2 & 3 & 7 \\\\ 1 & 3 & 1 \\end{pmatrix}\n\n\nWhich of the matrices A, B, C are invertible? For each of these matrices, compute the inverse.\n\n\n# your code here \n\nExercise 5.2:\nIn the Linear Algebra course we have seen that if we multiply a single row by a constant k, then the determinant gets multiplied by k as well.\n\nVerify this (using Python) for the matrix obtained from C by multiplying the first row by 10: \nD = \\begin{pmatrix} 10 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1\\end{pmatrix} C\n\nWhat is \\det(10 C)?\n\n\n# your code here\n\nWe can use Python to solve linear systems of equations using numpy. Consider for example the following system of equations:\n\n\\left\\{\\begin{array}{rl}\nx_1 - 3x_2  &= 5 \\\\\n-x_1 +x_2 +5x_3 &= 2 \\\\\nx_2 + x_3 &= 0\n\\end{array}\\right.\n\nWe can solve the system very efficiently numerically with the command np.linalg.solve(A,b):\n\nimport numpy as np\n\n# Coefficient matrix A\nA = np.array([[1, -3, 0],\n              [-1, 1, 5],\n              [0, 1, 1]])\n\n# Right-hand side vector b\nb = np.array([5, 2, 0])\n\n# Solve the system\nx = np.linalg.solve(A, b)\nprint(\"Solution:\", x)\n\nSolution: [ 2. -1.  1.]\n\n\nAs you can see, the solution is x_1=2.0, x_2=-1.0, x_3=1.0. Note that the output is numerical i.e., it is an approximation computed with finite precision arithmetic inside the computer. numpy is faster for large systems than sympy, but it may introduce tiny rounding errors (e.g., 2.00000000001 instead of 2).\nExercise 5.3: Use numpy to solve the following system:\n\n\\left\\{\\begin{array}{rl}\nx_1 - 3x_2 + 4x_3 &= -4 \\\\\n3x_1 -7x_2 +7x_3 &= -8 \\\\\n-4x_1 + 6x_2 + 2x_3 &= 4\n\\end{array} \\right.\n\n\n# your code here",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear algebra</span>"
    ]
  },
  {
    "objectID": "04-lin-alg.html#modifying-matrix-entries",
    "href": "04-lin-alg.html#modifying-matrix-entries",
    "title": "4  Linear algebra",
    "section": "4.6 Modifying matrix entries",
    "text": "4.6 Modifying matrix entries\nConsider the following large matrix A, and a zero matrix B of the same size as A:\n\nA = np.array([\n    [5, 12, 7, 3, 14, 6, 9, 2, 11, 8],\n    [1, 13, 4, 10, 7, 5, 12, 6, 8, 3],\n    [9, 2, 11, 5, 13, 7, 4, 10, 6, 12],\n    [8, 1, 14, 6, 9, 3, 11, 2, 5, 13],\n    [7, 10, 3, 12, 6, 9, 2, 8, 4, 11],\n    [2, 6, 9, 5, 11, 7, 3, 12, 10, 1],\n    [4, 8, 2, 10, 5, 13, 6, 9, 1, 7],\n    [12, 3, 6, 11, 2, 8, 5, 14, 7, 10],\n    [10, 5, 1, 7, 12, 4, 8, 3, 6, 9],\n    [3, 9, 5, 8, 1, 10, 7, 11, 2, 12]\n])\nB=np.zeros((10,10))\n\nWe can modify entries of B separately. E.g., we can modify the top-left entry of B to be 100:\n\nB[0,0]=100\nprint(B)\n\n[[100.   0.   0.   0.   0.   0.   0.   0.   0.   0.]\n [  0.   0.   0.   0.   0.   0.   0.   0.   0.   0.]\n [  0.   0.   0.   0.   0.   0.   0.   0.   0.   0.]\n [  0.   0.   0.   0.   0.   0.   0.   0.   0.   0.]\n [  0.   0.   0.   0.   0.   0.   0.   0.   0.   0.]\n [  0.   0.   0.   0.   0.   0.   0.   0.   0.   0.]\n [  0.   0.   0.   0.   0.   0.   0.   0.   0.   0.]\n [  0.   0.   0.   0.   0.   0.   0.   0.   0.   0.]\n [  0.   0.   0.   0.   0.   0.   0.   0.   0.   0.]\n [  0.   0.   0.   0.   0.   0.   0.   0.   0.   0.]]\n\n\nExercise 5.4: Use for loops over the row indices i and column indices j to modify the entries of B as follows, for each entry of A:\n\nIf A_{ij} &lt; 6, set B_{ij} =100.\nIf A_{ij} \\geq 6, set B_{ij} = A_{ij}.\n\nThen, compute the sum of all entries in B with np.sum(B). What is the result?\n\n# your code here",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear algebra</span>"
    ]
  },
  {
    "objectID": "04-lin-alg.html#linear-transformations-of-images",
    "href": "04-lin-alg.html#linear-transformations-of-images",
    "title": "4  Linear algebra",
    "section": "4.7 Linear transformations of images",
    "text": "4.7 Linear transformations of images\nIn this section we will illustrate the concept of applying linear transformations to real-life images. We use the cv2 library, the numpy library, and the matplotlib packages for this.\nThe above packages should be installed in a standard Anaconda installation. If you have another Python installation, typically using the PIP package manager should allow you to install packages. In this case, commands like “pip install opencv-python” “pip install numpy” “pip install matplotlib” in a (Windows) powershell should do the job.\n\nimport cv2\nimport numpy as np\nimport matplotlib.pyplot as plt \n\nA linear transformation for a vector in \\mathbb{R}^2 can be represented by \n\\begin{bmatrix}x'\\\\ y' \\end{bmatrix}= \\begin{bmatrix}a_{11}& a_{12} \\\\ a_{21}& a_{22} \\\\ \\end{bmatrix}\\begin{bmatrix}x\\\\ y\\end{bmatrix}\n\nFor images, (x,y) are the pixel coordinates of the original image and (x',y') are the pixel coordinates of the transformed image. First we load in an image (this can be any image with the name `image.jpg’, but it must be in the same folder as the Python notebook):\n\n\nimg2 = cv2.imread('image.jpg')\n\nplt.imshow(img2[:,:,::-1])\nplt.axis('off')\n\n\n\n\n\n\n\n\nThe picture can be seen as a set of points in \\mathbb{R}^2, corresponding to the pixels, where each point is assigned a color. We are now going to move the points according to a linear transformation \\mathbb{R}^2 \\to \\mathbb{R}^2 which maps \\mathbf{x} to A\\textbf{x}.\nWe first predefine a Python function called perform_Transformation() to apply a transformation to the image. You don’t have to understand this code, but only remember that its purpose is to apply transformations to images. The function takes as input an image and a transformation matrix.\n\n# Function to apply transformation and visualize the result (source: kaggle.com)\ndef perform_Transformation(image, A):\n    rows,cols,ch = image.shape\n\n    M = np.array([[A[0,0], A[0,1], 0],\n                [A[1,0], A[1,1], 0]])\n\n    dst = cv2.warpAffine(image,M,(cols,rows))\n    \n    \n    plt.figure(figsize = (24,8))\n    plt.subplot(211); plt.imshow(image[:,:,::-1]); plt.title('Original Image')\n    \n    plt.subplot(212); plt.imshow(dst[:,:,::-1]); plt.title(\"Transformed Image\")\n\nNext, we create a 2x2 (transformation) matrix A and use the image that we stored in img2 variable and apply the transformation function to these inputs. The function prints both the original and transformed image.\n\n# The matrix A scales the picture down 50% in both the x direction and y direction\nA = np.array([[0.5,0],\n                [0,0.5]])\n\nperform_Transformation(img2, A)\n\n\n\n\n\n\n\n\nExercise 5.5:\n\nCan you scale the picture 50% down in the x-direction only?\nInvestigate what the matrix A=\\begin{bmatrix} 0  &1 \\\\ 1 & 0  \\end{bmatrix} does to the picture. Can you explain why?\n\n\n# your code here\n\nThe following matrix rotates the picture approximately 45 degrees (note that \\sin(\\pi/4) = \\cos(\\pi/4) \\approx 0.707). Sadly, the image is only partly visible then.\n\n# The matrix A rotates the picture 45 degrees\nA = np.array([[0.707,-0.707],\n                [0.707,0.707]])\n\nperform_Transformation(img2, A)\n\n\n\n\n\n\n\n\nExercise 5.6:\n\nLet A=\\begin{bmatrix} 0.5  &0 \\\\ 0 & 1  \\end{bmatrix} and B= \\begin{bmatrix} 0  &1 \\\\ 1 & 0  \\end{bmatrix}. Compute the matrix products AB and BA.\nInvestigate what the matrix BA= \\begin{bmatrix} 0  &1 \\\\ 1 & 0  \\end{bmatrix}\\begin{bmatrix} 0.5  &0 \\\\ 0 & 1  \\end{bmatrix} does to the picture. Can you explain why?\nWhat does the matrix AB = \\begin{bmatrix} 0.5  &0 \\\\ 0 & 1  \\end{bmatrix} \\begin{bmatrix} 0  &1 \\\\ 1 & 0  \\end{bmatrix} to the picture and why?\nCan you scale the picture 50% down in the x-direction only, and then rotate the picture (approximately) 45 degrees? What matrix corresponds to this?\n\n\n# your code here",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear algebra</span>"
    ]
  },
  {
    "objectID": "04-lin-alg.html#symbolic-computations-sympy",
    "href": "04-lin-alg.html#symbolic-computations-sympy",
    "title": "4  Linear algebra",
    "section": "4.8 Symbolic computations: sympy",
    "text": "4.8 Symbolic computations: sympy\nThe sympy library is for symbolic computations. We will now demonstrate how this library works. sympy also contains a function to bring a matrix into reduced echelon form. This is very useful if you want to verify manual calculations.\n\nimport sympy as sp\n\nWe now show how to solve the following system of equations:\n\n\\left\\{\\begin{array}{l}\nx_1 - 3x_2 + 4x_3 = -4 \\\\\n3x_1 -7x_2 +7x_3 = -8 \\\\\n-4x_1 + 6x_2 + 2x_3 = 4\n\\end{array}\\right.\n The augmented matrix of the system of linear equations is\n\n\\left[\\begin{array}{ccc|c}\n1 & -3 & 4 & -4 \\\\\n3 & -7 & 7 & -8 \\\\\n-4 & 6 & 2 & 4 \\\\\n\\end{array}\\right]\n\nIn Python you can do this with sympy as follows.\n\nAb=sp.Matrix([[1,-3,4,-4],[3,-7,7,-8],[-4,6,2,4]])\n\nNow we can find the reduced form of the system using rref() from the sympy library. The method returns two elements. The first is the row-reduced echelon form of the matrix, and the second is a list of the pivot columns. By typing Ab_rref[0], only the row-reduced echelon form is printed.\n\nAb_rref = Ab.rref()\nAb_rref[0]\n\n\\displaystyle \\left[\\begin{matrix}1 & 0 & 0 & 2\\\\0 & 1 & 0 & 2\\\\0 & 0 & 1 & 0\\end{matrix}\\right]\n\n\nThe system is consistent and we can immediately see the general solution: x_1=2, x_2=2 and x_3=0. The solution is exact, e.g., Python did not round the number 2 to 2.00000 as it does when using the numpy module. sympy allows us to do exact computation with matrices, as opposed to approximate computations with numpy. Computations with sympy are generally slower than with numpy, so for very large systems, numpy is preferred.\nExercise 5.7: Use Python to solve the following system of equations:\n\n\\left\\{\\begin{array}{l}\nx_1 - 3x_2  = 5 \\\\\n-x_1 +x_2 +5x_3 = 2 \\\\\nx_2 + x_3 = 0\n\\end{array}\\right.\n\n\n# your code here",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear algebra</span>"
    ]
  },
  {
    "objectID": "04-lin-alg.html#application-supply-and-demand-model",
    "href": "04-lin-alg.html#application-supply-and-demand-model",
    "title": "4  Linear algebra",
    "section": "4.9 Application: supply and demand model",
    "text": "4.9 Application: supply and demand model\n(From Linear Algebra notebook by Herbert Hamers)\nThe demand q_d and supply q_s of an item depend on the price p and income Y. Suppose that the relation between demand, price and income can be described by the equation\nq_d = 8 - 0.2p + 0.1Y,\nand the relation between supply and price by the equation\nq_s = 6 + 0.3p.\nThe market is in equilibrium if q_s = q_d. Replacing both q_s and q_d by the new variable q, the market equilibrium can be found by solving the following system of two linear equations for the unknowns p, q and Y:\n\n\\left\\{\\begin{array}{l}\nq = 8 - 0.2p + 0.1Y\\\\\nq = 6 + 0.3p.\n\\end{array}\\right.\n\nFirst, we will rewrite this system of linear equations. We place all terms with a variable to the left of the equal sign and moreover we put terms with the same variable in the different equations right below each other:\n\n\\left\\{\\begin{array}{l}\nq + 0.2p - 0.1Y = 8\\\\\nq - 0.3p = 6.\n\\end{array}\\right.\n\n\nAb = sp.Matrix([[1, 0.2, -0.1, 8], [1, -0.3, 0, 6]]) \nAb\n\n\\displaystyle \\left[\\begin{matrix}1 & 0.2 & -0.1 & 8\\\\1 & -0.3 & 0 & 6\\end{matrix}\\right]\n\n\nExercise 5.8:\nHow many solutions does this system of linear equations have? You can use the function rref() again to find the row reduced echelon form of the above matrix. Determine the solution if Y=50.\n\n# your code here",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear algebra</span>"
    ]
  },
  {
    "objectID": "04-lin-alg.html#symbolic-computation-of-the-determinant-in-python-with-sympy",
    "href": "04-lin-alg.html#symbolic-computation-of-the-determinant-in-python-with-sympy",
    "title": "4  Linear algebra",
    "section": "4.10 Symbolic computation of the determinant in Python with sympy",
    "text": "4.10 Symbolic computation of the determinant in Python with sympy\nThe sympy package can also be used to calculate determinants of symbolic matrices.\nExercise 5.9:\nWe now investigate how to compute determinants of symbolic matrices using sympy. Let \nA = \\begin{pmatrix}  1 & 0 & x \\\\ 1 & -x & 0 \\\\ x & 0 & -x \\end{pmatrix}.\n Our goal will be to compute the determinant of A in terms of x. First we define the variable x as a “symbolic” variable in Sympy.\n\nimport sympy as sp\nx = sp.symbols('x')\n\nNext, carry out the following steps.\n\nDefine the matrix A using the variable x.\nCompute the determinant of A using the command A.det(). For which values of x does the determinant equal zero?\nTo be able to see more easily for which values of x the determinant equals 0, you can use Sympy’s sp.factor() function to factor the determinant. The input of this function is the determinant of A. Apply this function and argue for which values of x the matrix A is invertible.\n\n\n# your code here",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear algebra</span>"
    ]
  },
  {
    "objectID": "04-lin-alg.html#optional-row-reduction-with-intermediate-steps",
    "href": "04-lin-alg.html#optional-row-reduction-with-intermediate-steps",
    "title": "4  Linear algebra",
    "section": "4.11 (Optional) Row reduction with intermediate steps",
    "text": "4.11 (Optional) Row reduction with intermediate steps\nThis optional section describes a more advanced code snippet that implements a row-reduction algorithm from scratch, and allows you to output the intermediate operations. You should be able to read most of the code and recognize the algorithm, but some details have not been explained in this notebook. More specifically, you will see again for-loops and if-statements, but also “new” functions such as .copy(), .as_mutable(), .append(). If you are interested, we invite you to look up their documentation. You can also use this algorithm to revisit some examples that you have seen in the linear algebra course.\n\nAs a disclaimer: this code has been generated using ChatGPT.\n\nfrom sympy import Matrix\n\ndef rref_with_steps(mat):\n    \"\"\"\n    Perform row-reduction to RREF while recording intermediate steps and row operations.\n    Returns:\n        rref_matrix (Matrix),\n        pivot_columns (tuple),\n        steps (list of (Matrix, str))  # Each step is (matrix_snapshot, operation_description)\n    \"\"\"\n    A = mat.as_mutable().copy()\n    rows, cols = A.shape\n    pivots = []\n    steps = [(A.copy(), \"Initial matrix\")]\n\n    row = 0\n    for col in range(cols):\n        if row &gt;= rows:\n            break\n\n        # Find pivot row\n        pivot_row = None\n        for r in range(row, rows):\n            if A[r, col] != 0:\n                pivot_row = r\n                break\n\n        if pivot_row is None:\n            continue\n\n        # Swap rows if needed\n        if pivot_row != row:\n            A.row_swap(pivot_row, row)\n            steps.append((A.copy(), f\"Swap R{pivot_row+1} ↔ R{row+1}\"))\n\n        # Scale pivot row\n        pivot_val = A[row, col]\n        if pivot_val != 1:\n            A.row_op(row, lambda x, _: x / pivot_val)\n            steps.append((A.copy(), f\"R{row+1} → (1/{pivot_val})·R{row+1}\"))\n\n        # Eliminate other rows\n        for r in range(rows):\n            if r != row and A[r, col] != 0:\n                factor = A[r, col]\n                A.row_op(r, lambda x, j: x - factor * A[row, j])\n                steps.append((A.copy(), f\"R{r+1} → R{r+1} - ({factor})·R{row+1}\"))\n\n        pivots.append(col)\n        row += 1\n\n    return A, tuple(pivots), steps\n\n\nA = Matrix([[1, 2, 1],\n            [2, 4, 3],\n            [3, 6, 5]])\n\nrref_matrix, pivots, steps = rref_with_steps(A)\n\nprint(\"RREF:\")\nprint(rref_matrix)\nprint(\"Pivot columns:\", pivots)\n\nprint(\"\\nSteps:\")\nfor i, (s, op) in enumerate(steps):\n    print(f\"Step {i}: {op}\")\n    display(s)\n\nRREF:\nMatrix([[1, 2, 0], [0, 0, 1], [0, 0, 0]])\nPivot columns: (0, 2)\n\nSteps:\nStep 0: Initial matrix\n\n\n\\displaystyle \\left[\\begin{matrix}1 & 2 & 1\\\\2 & 4 & 3\\\\3 & 6 & 5\\end{matrix}\\right]\n\n\nStep 1: R2 → R2 - (2)·R1\n\n\n\\displaystyle \\left[\\begin{matrix}1 & 2 & 1\\\\0 & 0 & 1\\\\3 & 6 & 5\\end{matrix}\\right]\n\n\nStep 2: R3 → R3 - (3)·R1\n\n\n\\displaystyle \\left[\\begin{matrix}1 & 2 & 1\\\\0 & 0 & 1\\\\0 & 0 & 2\\end{matrix}\\right]\n\n\nStep 3: R1 → R1 - (1)·R2\n\n\n\\displaystyle \\left[\\begin{matrix}1 & 2 & 0\\\\0 & 0 & 1\\\\0 & 0 & 2\\end{matrix}\\right]\n\n\nStep 4: R3 → R3 - (2)·R2\n\n\n\\displaystyle \\left[\\begin{matrix}1 & 2 & 0\\\\0 & 0 & 1\\\\0 & 0 & 0\\end{matrix}\\right]",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear algebra</span>"
    ]
  },
  {
    "objectID": "04-lin-alg.html#footnotes",
    "href": "04-lin-alg.html#footnotes",
    "title": "4  Linear algebra",
    "section": "",
    "text": "Under the hood, numpy for instance relies on BLAS and LAPACK for most of its linear algebraic subroutines. BLAS and LAPACK are written in a programming language called Fortran, see for example the LAPACK documentation. LAPACK is used by many other programming languages, including Matlab.↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Linear algebra</span>"
    ]
  },
  {
    "objectID": "05-linear-optimization.html",
    "href": "05-linear-optimization.html",
    "title": "5  Linear optimization",
    "section": "",
    "text": "5.1 Gurobi installation\nIn this chapter we will show how to implement linear optimization problems using Python. The goal is to model optimization problems in Python and then solve them using Gurobi, which is a software package dedicated to solving optimization problems.\nIn the next section we explain how to install Gurobi on your personal laptop, and how to connect it to Anaconda. On the university computers Gurobi is already installed and configured correctly, so if you are using such a computer, you can skip the next section.\nIt is assumed that you already have Python installed on your system. Otherwise, you need to install Python first. The Anaconda distribution is a good choice. If you get stuck anywhere in the installation process, then you can find more information on Gurobi’s Quick Start Guide.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Linear optimization</span>"
    ]
  },
  {
    "objectID": "05-linear-optimization.html#gurobi-installation",
    "href": "05-linear-optimization.html#gurobi-installation",
    "title": "5  Linear optimization",
    "section": "",
    "text": "5.1.1 Register at Gurobi\nVisit the Gurobi website and click on the register button. Open the registration form and make sure that you select the Academic account type, and select Student for the academic position.\n\n\n5.1.2 Download Gurobi\nDownload Gurobi from the website. Note that you need to login with your Gurobi account before you can download Gurobi. Select the distribution that corresponds to your system (e.g., Windows or macOS), and select the regular “Gurobi Optimizer”, not any of the AMPL variations. Unless mentioned otherwise, download the most recent version.\n\n\n5.1.3 Install Gurobi\nRun the installer and follow the installation steps. At some point, the installer may ask whether to add Gurobi to your execution path. This is probably useful to accept.\n\n\n5.1.4 Gurobi license\nYou cannot use Gurobi without a license, so you need to apply for a license. As a student you can request a free academic license; take the Named-User Academic one. After you have obtained the license, you need to activate it for your Gurobi installation. If you open the license details on the Gurobi website, you can see what you need to do: open a command prompt and run the grbgetkey command with the code that corresponds to your license. This command will create your license file. Make sure that you remember where the license file is saved. The default location is probably the best choice.\nNote that the grbgetkey command will check that you are on an academic domain, so you need to perform this step on the university network (possibly via a VPN connection). Once installed correctly, you can also run Gurobi without an active VPN connection.\n\n\n5.1.5 Using Gurobi in Python\nGurobi should now be correctly installed, but we also want to be able to use it from Python. Therefore, we need to install Gurobi’s Python package. Open your Anaconda prompt (if you have the Anaconda installation) and run the following commands.\n\nconda config --add channels http://conda.anaconda.org/gurobi\nconda install gurobi\n\nIf you don’t have the Anaconda installation, then you can do something similar with the pip command.\n\n\n5.1.6 Test your installation\nNow you can test whether everything is setup correctly. Open an interactive Python session, for instance using Jupyter Notebook. Try the following commands:\n\nfrom gurobipy import Model\nmodel = Model()\n\nSet parameter Username\nSet parameter LicenseID to value 2715549\nAcademic license - for non-commercial use only - expires 2026-09-29\n\n\nIf both these commands succeed, then you are done.\nIf the first command fails, then the Gurobi python module has not been installed correctly. If the second command fails, then the license has not been setup correctly (make sure the license file is at the right location).\nIf at any point, you need more information about Gurobi, then you can always go to the official Gurobi documention online.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Linear optimization</span>"
    ]
  },
  {
    "objectID": "05-linear-optimization.html#basics",
    "href": "05-linear-optimization.html#basics",
    "title": "5  Linear optimization",
    "section": "5.2 Basics",
    "text": "5.2 Basics\nAll the relevant functionality needed to use Gurobi via Python is contained in the gurobipy package. For our purposes, we only need two modules from this package:\n\nThe Model module that we will use to build optimization problems\nThe GRB module that contains various “constants” that we use to include words such as maximize and minimize, as well as binary and integer.\n\nIn Python you can include the modules by adding the following line at the top of a script.\n\nfrom gurobipy import Model, GRB\n\n\n5.2.1 Example: Duplo problem\nTo illustrate how to implement optimization problems in Python, we consider the Duplo problem from the lectures: \n\\begin{array}{llll}\n\\text{maximize}& 15x_1 + 20x_2 && \\text{(profit)} \\\\\n\\text{subject to} &x_1 + 2x_2 \\leq 6 &&\\text{(big bricks)} \\\\\n&2x_1 + 2x_2 \\leq 8 &&\\text{(small bricks)} \\\\\n&x_1, x_2 \\geq 0\n\\end{array}\n with decision variables\n\nx_1: Number of chairs\nx_2: Number of tables\n\nLet us implement the Duplo problem in Gurobi.\n\nModel object\nTo start, we will create a variable (or object) model that will contain all the information of the problem, such as the decision variables, objective function and constraints.\nIn programming terms, we create an object from the Model() class. We can give the instance a name by adding the name keyword argument, with value 'Duplo problem' in our case. We add this name with quotations so that Python knows this is plain text.\n\n# Initialize Gurobi model.\nmodel = Model(name='Duplo problem')\n\nYou can think of the Model class object model as a large box that we are going to fill with decision variables, an objective function, and constraints. We will also reserve a small space in this box to store information about the optimal solution to the linear optimization problem, once we have optimized the problem.\nThe concept of having “objects” is in fact what the programming language Python is centered around. This is known as object-oriented programming, which you will learn about more later in your first full programming course. You can have a look, for example, here already if you are interested in this concept.\n\n\nDecision variables\nTo add decision variables, an objective function, and constraints, to our Model object we use so-called methods which are Python functions.\nTo create a decision variable, we can use the addVar() method. As input argument, we include a name for the decision variables.\n\n# Declare the two decision variables.\nx1 = model.addVar(name='chairs')\nx2 = model.addVar(name='tables')\n\n\nIf your Model object is not called model, but for example model_Duplo, then you should use model_Duplo.addVar(name='chairs') instead. The same applies for all later methods that are introduced. Never call a model Model (with capital M) because this spelling is reserved for the Model() class in Gurobi.\n\nWhen creating a variable, you can specify more properties. For example, we might have an upper and lower bound for a decision variable (such as a nonnegativity constraint). You can use the keyword arguments lb and ub, respectively, for this.\nTo see all these properties, you can check out the addVar documentation by typing help(Model.addVar) in Python. Looking up the documentation in this way can be done for every method.\n\nhelp(Model.addVar)\n\nHelp on cython_function_or_method in module gurobipy._model:\n\naddVar(self, lb=0.0, ub=1e+100, obj=0.0, vtype='C', name='', column=None)\n    ROUTINE:\n      addVar(lb, ub, obj, vtype, name, column)\n\n    PURPOSE:\n      Add a variable to the model.\n\n    ARGUMENTS:\n      lb (float): Lower bound (default is zero)\n      ub (float): Upper bound (default is infinite)\n      obj (float): Objective coefficient (default is zero)\n      vtype (string): Variable type (default is GRB.CONTINUOUS)\n      name (string): Variable name (default is no name)\n      column (Column): Initial coefficients for column (default is None)\n\n    RETURN VALUE:\n      The created Var object.\n\n    EXAMPLE:\n      v = model.addVar(ub=2.0, name=\"NewVar\")\n\n\n\nIf we would want to create a variable, with name test variable, having lower bound 3 and upper bound 7, we can do this with x = model.addVar(lb=3,ub=7,name='test variable') using in particular the lb and ub keyword arguments.\nAs you can see above, all the keyword arguments have default values, meaning that if we do not specify them, Gurobi uses the specified default value for them. For example, by default a variable is continuous (vtype keyword argument) and non-negative (lb keyword argument), so we do not have to specify these for the Duplo exmpale, because there we have x_1, x_2 \\geq 0.\nAlso note that ub is set to 10^{100} which roughly speaking indicates that the decision variable has no upper bound value by default.\n\n\nObjective function\nNow that we have our decision variables, we can use them to define the objective function and the constraints.\nWe use the setObjective() method to do so by refering to the variables created above. The sense keyword argument must be used to specify whether we want to maximize or minimize the objective function. For this, we use GRB.MAXIMIZE or GRB.MINIMIZE, respectively.\n\n# Specify the objective function.\nmodel.setObjective(15*x1 + 20*x2, sense=GRB.MAXIMIZE)\n\n\n\nConstraints\nThe next step is to declare the constraints using the addConstr() method. Also here, we can specify the constraints refering to the variables x1 and x2. We give the constraints a name as well.\n\n# Add the resource constraints on bricks.\nmodel.addConstr(x1 + 2*x2 &lt;= 6, name='big-bricks')\nmodel.addConstr(2*x1 + 2*x2 &lt;= 8, name='small-bricks')\n\n&lt;gurobi.Constr *Awaiting Model Update*&gt;\n\n\nNow the model is completely specified, we are ready to compute the optimal solution. We can do this using the optimize() method applied to our model model.\n\n# Optimize the model\nmodel.optimize()\n\nGurobi Optimizer version 12.0.3 build v12.0.3rc0 (win64 - Windows 10.0 (19045.2))\n\nCPU model: 12th Gen Intel(R) Core(TM) i7-1265U, instruction set [SSE2|AVX|AVX2]\nThread count: 10 physical cores, 12 logical processors, using up to 12 threads\n\nOptimize a model with 2 rows, 2 columns and 4 nonzeros\nModel fingerprint: 0xadc88607\nCoefficient statistics:\n  Matrix range     [1e+00, 2e+00]\n  Objective range  [2e+01, 2e+01]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [6e+00, 8e+00]\nPresolve time: 0.02s\nPresolved: 2 rows, 2 columns, 4 nonzeros\n\nIteration    Objective       Primal Inf.    Dual Inf.      Time\n       0    3.5000000e+31   3.500000e+30   3.500000e+01      0s\n       2    7.0000000e+01   0.000000e+00   0.000000e+00      0s\n\nSolved in 2 iterations and 0.02 seconds (0.00 work units)\nOptimal objective  7.000000000e+01\n\n\nWe can see some output from Gurobi, and the last line tells us that Gurobi found an optimal solution with objective value 70.\nTo summarize all the step above, we have given the complete code below (but not executed this time).\n\nfrom gurobipy import Model, GRB\n\n# Initialize Gurobi model.\nmodel = Model(name='Duplo problem')\n\n# Declare the two decision variables.\nx1 = model.addVar(name='chairs')\nx2 = model.addVar(name='tables')\n\n# Specify the objective function.\nmodel.setObjective(15*x1 + 20*x2, sense=GRB.MAXIMIZE)\n\n# Add the resource constraints on bricks.\nmodel.addConstr(x1 + 2*x2 &lt;= 6, name='big-bricks')\nmodel.addConstr(2*x1 + 2*x2 &lt;= 8, name='small-bricks')\n\n# Optimize the model\nmodel.optimize()\n\nRecalling our linear optimization problem object as being a “box” filled with decision variables, an objective function and constraints, the box now also contains a small space where the optimal solution is stored.\nLet us have a look at how to access information about the optimal solution. The objective function value of the optimal solution, that was also displayed in the output when optimization the model with model.optimize() is stored in the ObjVal attribute. An attribute is a piece of information about an object in Python.\n\n# Print text 'Objective value' and the model.ObjVal attribute value\nprint('Objective value:', model.ObjVal)\n\nObjective value: 70.0\n\n\nThe optimal values of a decision variables can be obtained by accessing the X attribute of a variable.\n\nprint('x1 = ', x1.X)\nprint('x2 = ', x2.X)\n\nx1 =  2.0\nx2 =  2.0\n\n\nIf the model has many variables, printing variables in this way is a cumbersome approach. It is then easier to iterate over all variables of the model using the getVars() method. This method creates a list of all the decision variables of the model.\n\nprint(model.getVars())\n\n[&lt;gurobi.Var chairs (value 2.0)&gt;, &lt;gurobi.Var tables (value 2.0)&gt;]\n\n\nAs you can see above, we already see the optimal values of the decision variables, but also a lot of unnecessary information.\nLet us print these values in a nicer format by iterating over the list model.getVars() using a for-loop with index variable var; you can choose another name than var for the index variable if you want. We print for every variable var its name, stored in the attribute VarName, and its value, stored in the attribute X. In between, we print the = symbol in plain text (hence, the quotations).\nRecall that if you want to print multiple data types (such as a variables and text) in a print() statement, you should separate them with commas.\n\nfor var in model.getVars():\n    print(var.VarName, \"=\", var.X)\n\nchairs = 2.0\ntables = 2.0\n\n\n\n\n\n\n\n\nTipExercise 1\n\n\n\nM\\text{\\'e}decins sans Fronti\\text{\\`e}res (MSF) (Dutch: Artsen zonder Grenzen) wants to build medical kits to use in region with an epidemic. The following constraints should be taken into account.\n\nMSF has raised € 6400 to build two types of medical medical kits: vaccination and surgical kits. Assembling a surgical kit costs € 320; a vaccination kit € 210.\n\nMSF has in total 80 labour hours available in which employees can build these kits. Building a surgical kit requires 2.5 labour hours; a vaccination kit requires 4.5 labour hours.\nAt most 15 vaccination kits can be built.\n\nA linear optimization problem that maximizes the total number of produced kits is given below. The decision variables are the number of surgical kits (x_1) and the number of vaccination kits (x_2) to assemble.\n\n\\begin{array}{lrrrrrrl}\n\\max & z  = & x_{1} &+ &x_{2} & & & \\ \\ \\ \\textit{total number of kits}\\\\\n\\text{s.t. } & & 320x_1 &+ & 210x_2& \\leq & 6400 & \\ \\ \\ \\textit{budget constraint}\\\\\n&& 2.5x_1 &+ & 4.5x_2& \\leq & 80 & \\ \\ \\ \\textit{labor hours constraint}\\\\  \n  && & & x_2& \\leq & 15 & \\ \\ \\ \\textit{at most $15$ vac. kits}\\\\  \n& &x_1, & & x_2  & \\geq & 0 & \\ \\ \\ \\textit{nonneg. constraints}\n\\end{array}\n\nImplement this model in Python with a Model object called model_msf, with decision variable whose keyword arguments for name are 'Surgical kits' and 'Vaccination kits', respectively. Optimize your model.\nIf you include the following lines at the end of your code, you should get the output as indicated.\n\n# Replace model_msf by chosen name of Model object if different.\n# For example, if your object is called model, then use model.getVars() instead\nfor var in model_msf.getVars():\n    print(var.VarName, \"=\", var.X)\n\nSurgical kits = 9.444444444444445\nVaccination kits = 15.0\n\n\n\n\nAs you can see in the output of Exercise 1, the optimal values of the decision variables are not integer, although this is a desired property because we cannot build, e.g., 9.44 kits. We will later see how you can enforce the decision variables to be integer-valued as well. You can ignore this shortcoming for now.\n\n\n\n\n\n\nTipExercise 2\n\n\n\nA brewery produces beer in Haarlem and Eindhoven (plants), and ships to Amsterdam, Amersfoort, Gouda, Den Bosch and Breda (customers).\nWe can ship beer units from the plants to the customers, taking into account transportation costs, demand of the customers and supply of the plants. In the table below we have indicated the following input data:\n\nUnit transport costs (in euros) from the plants (Haarlem, Eindhoven) to the customers (Amsterdam, Breda, Gouda, Amersfoort, Den Bosch);\nDemand of each customer: what needs to at least be delivered;\nMaximum supply capacity of each plant: what can at most be supplied.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA’dam\nBreda\nGouda\nA’foort\nDen Bosch\nSupply\n\n\n\n\nHaarlem\n131\n405\n188\n396\n485\n47\n\n\nEindhoven\n554\n351\n479\n366\n155\n63\n\n\nDemand\n28\n16\n22\n31\n12\n\n\n\n\nWe define decision variables x_{pc} that model the number of units shipped from plant p to customer c, with the meaning of the indices p and c as follows:\n\nPlants: p = 1 for Haarlem, p = 2 for Eindhoven.\nCustomers: c = 1 for Amsterdam, c = 2 for Breda, c = 3 for Gouda, c = 4 for Amersfoort, c = 5 for Den Bosch.\n\nA linear optimization problem that minimizes the total transportation costs subject to the demand and supply constraints is given below.\n\n\\begin{array}{rll}\n\\min & \\displaystyle  131x_{11} + 405x_{12} + 188x_{13} + 396x_{14} + 485x_{15} +   \\\\\n&  554x_{21} + 351x_{22} + 479x_{23} + 366x_{24} + 155x_{25}   & \\\\\n{\\rm s.t.} & \\displaystyle   x_{11} + x_{12} + x_{13} + x_{14} + x_{15} \\leq   47 & \\textit{supply  Haarlem}\\\\  \n& \\displaystyle   x_{21} + x_{22} + x_{23} + x_{24} + x_{25}  \\leq  63 & \\textit{supply Eindhoven} \\\\  \n& \\displaystyle   x_{11} + x_{21} \\geq 28 & \\textit{demand A'dam} \\\\  \n& \\displaystyle   x_{12} + x_{22} \\geq 16 & \\textit{demand Breda} \\\\  \n& \\displaystyle   x_{13} + x_{23} \\geq 22 & \\textit{demand Gouda} \\\\  \n& \\displaystyle   x_{14} + x_{24} \\geq 31 & \\textit{demand A'foort} \\\\  \n& \\displaystyle   x_{15} + x_{25} \\geq 12 & \\textit{demand Den Bosch} \\\\  \n& x_{11}, x_{12}, x_{13},x_{14},x_{15},x_{21},x_{22},x_{23},x_{24},x_{25} \\geq 0  &   \\textit{ship nonneg. amounts}\n\\end{array}\n\nImplement this model in Python with a Model object called model_beer. In the name keyword argument of a decision variable, indicate the plant-customer combination it represents (for example, you could define x11 = model_beer.addVar(name='Haarlem-Amsterdam') for the decision variable x_{11} modeling the Haarlem-Amsterdam combination).\nIf you include the following lines at the end of your code, you should get the output as indicated.\n\nfor var in model_beer.getVars():\n    print(var.VarName, \"=\", var.X)\n\nHaarlem-Amsterdam = 28.0\nHaarlem-Breda = 0.0\nHaarlem-Gouda = 19.0\nHaarlem-Amersfoort = 0.0\nHaarlem-Den Bosch = 0.0\nEindhoven-Amsterdam = 0.0\nEindhoven-Breda = 16.0\nEindhoven-Gouda = 3.0\nEindhoven-Amersfoort = 31.0\nEindhoven-Den Bosch = 12.0\n\n\n\n\nAs you might have experienced in Exercise 2, once the number of decision variables and/or constraints grows, it becomes more tedious to write out the full problem in Python. Luckily, there are more efficient ways to implement the above problem, that only require a couple of lines of code, even if there are many more plants and customers! This is beyond the scope of this course.\n\n\n\n5.2.2 Infeasible models\nNot every linear optimization problem has an optimal solution. For example, the problem\n\n\\begin{array}{lrrrrrrl}\n\\min & z  = & 2x_{1} &+ &x_{2} & & & \\\\\n\\text{s.t. } & &x_1 &+ & x_2& \\leq & -1 & \\\\\n& &x_1, & & x_2  & \\geq & 0 &\n\\end{array}\n\nhas no feasible solution, because the sum of two nonnegative numbers (x_1,x_2 \\geq 0) can never sum up to something smaller or equal than -1 (x_1 + x_2 \\leq -1). The implementation of this problem is given below. It can be seen from the output (on the last line) that the model is indeed infeasible.\n\n# Initialize Gurobi model.\nmodel = Model(name='Infeasible model')\n\n# Declare the two decision variables.\nx1 = model.addVar() # We leave out the name keyword argument\nx2 = model.addVar() \n\n# Specify the objective function.\nmodel.setObjective(x1 + x2, sense=GRB.MINIMIZE)\n\n# Add the resource constraints on bricks.\nmodel.addConstr(x1 + x2 &lt;= -1)\n\n# Optimize the model\nmodel.optimize()\n\nGurobi Optimizer version 12.0.3 build v12.0.3rc0 (win64 - Windows 10.0 (19045.2))\n\nCPU model: 12th Gen Intel(R) Core(TM) i7-1265U, instruction set [SSE2|AVX|AVX2]\nThread count: 10 physical cores, 12 logical processors, using up to 12 threads\n\nOptimize a model with 1 rows, 2 columns and 2 nonzeros\nModel fingerprint: 0xf5807d19\nCoefficient statistics:\n  Matrix range     [1e+00, 1e+00]\n  Objective range  [1e+00, 1e+00]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [1e+00, 1e+00]\nPresolve removed 0 rows and 2 columns\nPresolve time: 0.02s\n\nSolved in 0 iterations and 0.02 seconds (0.00 work units)\nInfeasible model\n\n\nYou can look up the type of solution to a problem in the Status attribute of a model.\n\nmodel.Status\n\n3\n\n\nThe above output number is not informative right away. The number represents the Optimization Status Code, whose meaning you can look up in Gurobi’s online documentation.\n\n\n\n\n\n\nTipExercise 3\n\n\n\nWhen implementing and optimizing the following problem \n\\begin{array}{lrrrrrrl}\n\\max & z  = & 2x_{1} &+ &x_{2} & & & \\\\\n\\text{s.t. } & &x_1 &- & x_2& \\leq & 5 & \\\\\n& &x_1, & & x_2  & \\geq & 0 &\n\\end{array},\n Python returns an Optmization Status Code of 4. Look up in the online documentation, more specifically the Reference Manual, what this means.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Linear optimization</span>"
    ]
  },
  {
    "objectID": "05-linear-optimization.html#integer-variables",
    "href": "05-linear-optimization.html#integer-variables",
    "title": "5  Linear optimization",
    "section": "5.3 Integer variables",
    "text": "5.3 Integer variables\nIf you are not interested in finding fractional solutions, but want to enforce the decision variables to take integer values, you can do this with the vtype keyword argument.\nConsider the following linear optimization problem (without integrality constraints).\n\n\\begin{array}{lrrrrrrl}\n\\max & z  = & 2x_{1} &+ &x_{2} & & & \\\\\n\\text{s.t. } & &x_1 &+ & x_2& \\leq & 2.5 & \\\\\n& &x_1, & & x_2  & \\geq & 0 &\n\\end{array},\n\n\n# Initialize Gurobi model.\nmodel_frac = Model(name='Fractional problem')\n\n# Suppress Gurobi Optimizer output\nmodel_frac.setParam('OutputFlag',0)\n\n# Declare the two decision variables.\nx1 = model_frac.addVar(name=\"x1\") \nx2 = model_frac.addVar(name=\"x2\") \n\n# Specify the objective function.\nmodel_frac.setObjective(2*x1 + x2, sense=GRB.MAXIMIZE)\n\n# Add the resource constraints on bricks.\nmodel_frac.addConstr(x1 + x2 &lt;= 2.5)\n\n# Optimize the model\nmodel_frac.optimize()\n\n# Print optimal values of decision variables\nfor var in model_frac.getVars():\n    print(var.VarName, \"=\", var.X)\n\nx1 = 2.5\nx2 = 0.0\n\n\nIf we specify vtype=GRB.INTEGER in the addVar() method when creating the variables, Gurobi will find an optimal solution with all decision variables being integers.\n\n# Initialize Gurobi model.\nmodel_int = Model(name='Integer problem')\n\n# Suppress Gurobi Optimizer output\nmodel_int.setParam('OutputFlag',0)\n\n# Declare the two decision variables.\nx1 = model_int.addVar(name=\"x1\",vtype=GRB.INTEGER) \nx2 = model_int.addVar(name=\"x2\",vtype=GRB.INTEGER) \n\n# Specify the objective function.\nmodel_int.setObjective(2*x1 + x2, sense=GRB.MAXIMIZE)\n\n# Add the resource constraints on bricks.\nmodel_int.addConstr(x1 + x2 &lt;= 2.5)\n\n# Optimize the model\nmodel_int.optimize()\n\n# Print optimal values of decision variables\nfor var in model_int.getVars():\n    print(var.VarName, \"=\", var.X)\n\nx1 = 2.0\nx2 = -0.0\n\n\nAnoter common case is where the decision variables are supposed to be binary, meaning they can only take values in \\{0,1\\}. Setting variables to be binary can be done with vtype=GRB.BINARY.\n\n# Initialize Gurobi model.\nmodel_bin = Model(name='Binary problem')\n\n# Suppress Gurobi Optimizer output\nmodel_bin.setParam('OutputFlag',0)\n\n# Declare the two decision variables.\nx1 = model_bin.addVar(name=\"x1\",vtype=GRB.BINARY) \nx2 = model_bin.addVar(name=\"x2\",vtype=GRB.BINARY) \n\n# Specify the objective function.\nmodel_bin.setObjective(2*x1 + x2, sense=GRB.MAXIMIZE)\n\n# Add the resource constraints on bricks.\nmodel_bin.addConstr(x1 + x2 &lt;= 2.5)\n\n# Optimize the model\nmodel_bin.optimize()\n\n# Print optimal values of decision variables\nfor var in model_bin.getVars():\n    print(var.VarName, \"=\", var.X)\n\nx1 = 1.0\nx2 = 1.0\n\n\n\n\n\n\n\n\nTipExercise 4\n\n\n\nTake your solution from Exercise 1, and modify it so that the decision variables only take integer values. Optimize the model again.\nYour output should now be as follows:\n\n# Print optimal values of decision variables\nfor var in model_msf.getVars():\n    print(var.VarName, \"=\", var.X)\n\nSurgical kits = 9.0\nVaccination kits = 15.0",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Linear optimization</span>"
    ]
  },
  {
    "objectID": "05-linear-optimization.html#beyond-the-basics",
    "href": "05-linear-optimization.html#beyond-the-basics",
    "title": "5  Linear optimization",
    "section": "5.4 Beyond the basics",
    "text": "5.4 Beyond the basics\nYou can also do more complicated things with gurobipy such as defining many decision variables with one command, or use a for-loop to create many constraints in one go.\nTo illustrate these concepts, we will write a compact code to solve a general standard form problem with m constraints and n decision variables: \\min \\mathbf{c'x} subject to \\mathbf{Ax} = \\mathbf{b}, \\mathbf{x} \\geq \\mathbf{0} where \\mathbf{c} \\in \\mathbb{R}^n, \\mathbf{b} \\in \\mathbb{R}^m, \\mathbf{A} \\in \\mathbb{R}^{m \\times n}, and x = (x_1,\\dots,x_{n}).\nMore explicitly, the problem is as follows:\n\n\\begin{array}{rrrcrrlll}\n\\min &  c_1 x_1 &+& \\cdots& + & c_{n}x_{n}& & & \\\\\n{\\rm s.t.} &  a_{1}x_1& +& \\cdots& +& a_{1n} x_{n} &= &b_1 &\\\\\n& & & \\vdots & & & & \\\\\n&  a_{m1}x_1& +& \\cdots& +& a_{mn} x_{n} &= &b_{m}& \\\\\n&  x_1, & & \\cdots& & x_{n} & \\geq & 0 & \\\\\n\\end{array}\n\nSuppose we are given the following input data in Numpy arrays (see the Linear Algebra chapter).\n\nimport numpy as np\n\n# Objective function coefficients\nc = np.array([3, 1, 7, 2, -1]) # n = 5\n\n# Matrix A (m = 3, n = 5)\nA = np.array([\n    [2, 1, 0, 3, -1],\n    [1, 0, 4, 0, 2],\n    [0, 3, -2, 1, 1]\n])\n\n# Right-hand side vector b\nb = np.array([10, 12, 5]) # m = 3\n\n\nDecision variables\nTo create the decision variables x_1,\\dots,x_5, we can use addVar() five times, but this is rather cumbersome, especially if we would have many more decision variables.\nInstead we can use the related method addVars() that allows us to create many variables simultaneously.\n\n# Create Model object\nmodel = Model(\"Standard form problem\")\n\n# We define m and n here for convenience later\nm = 3 # Alternatively, m = len(b)\nn = 5 # Alternatively, n = len(c)\n\n# Add decision variables\nx = model.addVars(n)\n\nWith the syntax x = model.addVars(n) we tell Python to create n (= 5) decision variables. You can use the i-th decision variable to define constraints and the objective function by indexing x at position i-1, i.e, by using x[i-1]. Recall that Python starts counting from zero when indexing data objects such as lists.\nIf you want you can also add a list of names for the decision variables using the name keyword argument. Make sure that the number of elements in the list matches the value of n.\n\n# Add decision variables\nx = model.addVars(n,name=[\"Var1\",\"Var2\",\"Var3\",\"Var4\",\"Var5\"])\n\n\n\nObjective function\nWe continue with creating the objective function by indexing the variables in x and the array c containing the objective function coefficients.\n\n# Create objective function\nmodel.setObjective(x[0]*c[0] + x[1]*c[1] + x[2]*c[2] + x[3]*c[3] + x[4]*c[4])\n\nWe can do this even more compactly by using the quicksum() function, which has to be imported from gurobipy. In the code below we do two things:\n\nCreate the list y = [x[0]*c[0], x[1]*c[1], x[2]*c[2], x[3]*c[3], x[4]*c[4]] using the concept of list comprehension.\nUse the quicksum() function to add up the elements in the list y and set the resulting quantity as our objective function.\n\n\nfrom gurobipy import quicksum\n\n# Create objective function\ny = [x[j]*c[j] for j in range(n)] # List with terms of the objective function\nmodel.setObjective(quicksum(y)) # Sum up the terms in the list y\n\nThe part [x[j]*c[j] for j in range(n)] is the compact list comprehension syntax for carrying out the piece of code below where we repeatedly append the terms x[j]*c[j] as elements to an (initially empty) list y using the append() method for a list.\n\ny = [] # Start with empty list y\nfor j in range(n): # For every index j = 1,2,...,n:\n    y.append(x[j]*c[j]) # Append the element x[j]*c[j] to the list y \n\nNote that these computations are actually still quite abstract up until this point, because the decision variables have no actual values yet! You should think of these more as symbolic computations.\n\n\nConstraints\nWe continue with adding the equality constraints. We use a for-loop to loop over the equalities a_{i1}x_1 + \\dots + a_{in}x_n = b_i for i = 1,\\dots,m (note that Python starts counting at 0, though). Note that the array A is a list of lists, and that A[i] corresponds to the coefficients a_{i1},\\dots,a_{in}.\n\nprint(A[2]) # Last row i = 2 of the matrix A\n\n[ 0  3 -2  1  1]\n\n\nFurthermore, A[i][j] is then the j-th element on the i-th row.\n\nprint(A[2][3]) # Last row i = 2 and element j = 3 of the matrix A\n\n1\n\n\nFor a fixed i, the list [A[i][j]*x[j] for j in range(n)] then contains the coefficients of the i-th row multiplied by the variables in x, i.e, [a_{i1}x_1, ..., a_{in}x_n]. Applying quicksum() to this list then computes the expression a_{i1}x_1 + \\dots + a_{in}x_n. This should equal b_i, so we model the constraint by quicksum([A[i][j]*x[j] for j in range(n)]) == b[i]. This is done below.\n\n# Create constraints\nfor i in range(m):\n    y = [A[i][j]*x[j] for j in range(n)]\n    model.addConstr(quicksum(y) == b[i])\n\nAll together, our code looks as below. The beauty of this is that even if the input data arrays A, b and c get larger, the code below does not. (The critical reader might note that, if we want to include the variable names with the list [\"Var1\",\"Var2\",\"Var3\",\"Var4\",\"Var5\"], then this list would get longer when n increases, but there are also ways to create this list with a short command.)\n\nimport numpy as np\nfrom gurobipy import Model, GRB, quicksum\n\n# Objective function coefficients\nc = np.array([3, 1, 7, 2, -1]) # n = 5\n\n# Matrix A (m = 3, n = 5)\nA = np.array([\n    [2, 1, 0, 3, -1],\n    [1, 0, 4, 0, 2],\n    [0, 3, -2, 1, 1]\n])\n\n# Right-hand side vector b\nb = np.array([10, 12, 5]) # m = 3\n\n# Create Model object\nmodel = Model(\"Standard form problem\")\n\n# We define m and n here for convenience later\nm = 3\nn = 5\n\n# Add decision variables\nx = model.addVars(n,name=[\"Var1\",\"Var2\",\"Var3\",\"Var4\",\"Var5\"])\n\n# Create objective function\nmodel.setObjective(quicksum(x[j]*c[j] for j in range(n)))\n\n# Create constraints\nfor i in range(m): #Below, A[i][j] is element a_{ij}\n    model.addConstr(quicksum(A[i][j]*x[j] for j in range(n)) == b[i]) \n\n# Optimize the model\nmodel.optimize()\n\nGurobi Optimizer version 12.0.3 build v12.0.3rc0 (win64 - Windows 10.0 (19045.2))\n\nCPU model: 12th Gen Intel(R) Core(TM) i7-1265U, instruction set [SSE2|AVX|AVX2]\nThread count: 10 physical cores, 12 logical processors, using up to 12 threads\n\nOptimize a model with 3 rows, 5 columns and 11 nonzeros\nModel fingerprint: 0xf50960e7\nCoefficient statistics:\n  Matrix range     [1e+00, 4e+00]\n  Objective range  [1e+00, 7e+00]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [5e+00, 1e+01]\nPresolve time: 0.00s\nPresolved: 3 rows, 5 columns, 11 nonzeros\n\nIteration    Objective       Primal Inf.    Dual Inf.      Time\n       0   -2.0000000e+30   2.000000e+30   2.000000e+00      0s\n       3    1.3375000e+01   0.000000e+00   0.000000e+00      0s\n\nSolved in 3 iterations and 0.01 seconds (0.00 work units)\nOptimal objective  1.337500000e+01\n\n\n\n# Print optimal values of decision variables\nfor var in model.getVars():\n    print(var.VarName, \"=\", var.X)\n\nVar1 = 4.75\nVar2 = 0.0\nVar3 = 0.0\nVar4 = 1.3749999999999998\nVar5 = 3.625",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Linear optimization</span>"
    ]
  }
]