<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.52">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Exercises Lecture 8 (Sections 10.1-10.2)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="tutorial-lec8_files/libs/clipboard/clipboard.min.js"></script>
<script src="tutorial-lec8_files/libs/quarto-html/quarto.js"></script>
<script src="tutorial-lec8_files/libs/quarto-html/popper.min.js"></script>
<script src="tutorial-lec8_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="tutorial-lec8_files/libs/quarto-html/anchor.min.js"></script>
<link href="tutorial-lec8_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="tutorial-lec8_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="tutorial-lec8_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="tutorial-lec8_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="tutorial-lec8_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="style.css">
</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="tutorial-lec8.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Exercises Lecture 8 (Sections 10.1-10.2)</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><link rel="preconnect" href="https://fonts.googleapis.com"> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""> <link href="https://fonts.googleapis.com/css2?family=Fira+Mono&amp;family=Fira+Sans&amp;display=swap" rel="stylesheet"></p>
<p>Make sure to import Numpy, Matplotlib and Scikit-learn to be able to complete all the exercises.</p>
<div id="a55f613f" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LogisticRegression</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> make_blobs</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Display numerical values in NumPy arrays only up to three decimals, </span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># and suppress scientific notation</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>np.set_printoptions(precision<span class="op">=</span><span class="dv">3</span>, suppress<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<blockquote class="blockquote">
<p><b>Disclaimer:</b> For some questions where random numbers are involved, it might happen that your output obtained from running the test input is different than the output given. <br><br> This can happen if, despite the use of a random seed, you generate random numbers in a different way than was done in the solution by the teacher. This does not necessarily mean that your answer is wrong. If you are unsure about your solution, ask the teacher. <br><br> As an example, you can generate a normally distributed random number with mean <span class="math inline">0</span> and standard deviation <span class="math inline">1</span> with <code>np.random.normal(0,1)</code> or <code>np.random.randn()</code>, but these numbers will usually be different. Also, the shape of an array that you fill with random numbers can have an influence on the outcome: The command <code>np.random.randn(3,4)</code> does not yield the same <span class="math inline">3 \times 4</span> array as <code>np.random.randn(4,3).T</code>.</p>
</blockquote>
<section id="question-1" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="question-1">Question 1</h4>
<p>In this exercise, we will write a model for logistic regression with two label classes and <span class="math inline">n</span> features, i.e., we have data points <span class="math inline">x_i = [x_{i0},\dots,x_{i(n-1)}] \in \mathbb{R}^n</span>. We first write a function that can generate (synthetic) input data for us.</p>
<p>The data set will consist of the set <span class="math inline">D_0 = \{x_0,\dots,x_{m-1}\} \subset \mathbb{R}^n</span> whose points will get label <span class="math inline">0</span>, and set <span class="math inline">D_1 = \{x_m,\dots,x_{2m-1}\} \subset \mathbb{R}^n</span> whose points will get label <span class="math inline">1</span>.</p>
<p>The entries of the points <span class="math inline">x_i = [x_{i0},\dots,x_{i(n-1)}] \in D_0</span> for <span class="math inline">i = 0,\dots,m-1</span> will be normally distributed with <span class="math inline">x_{ij}</span> having mean <span class="math inline">\mu_j^0</span> and standard deviation <span class="math inline">\sigma_j^0</span> for <span class="math inline">j = 0,\dots,n-1</span>. The entries of the points <span class="math inline">x_i = [x_{i0},\dots,x_{i(n-1)}] \in D_1</span> for <span class="math inline">i = m,\dots,2m-1</span> will be normally distributed with <span class="math inline">x_{ij}</span> having mean <span class="math inline">\mu_j^1</span> and standard deviation <span class="math inline">\sigma_j^1</span> for <span class="math inline">j = 0,\dots,n-1</span>.</p>
<ol type="a">
<li><p>Write a function <code>synthetic_data()</code> that takes as input four one-dimensonal arrays <span class="math inline">\mu^k = [\mu_0^k,\dots,\mu_{n-1}^k]</span> and <span class="math inline">\sigma^k = [\sigma_0^k,\dots,\sigma_{n-1}^k]</span> for <span class="math inline">k = 0,1</span>, and a number <span class="math inline">m</span>. It should return a <span class="math inline">2m \times n</span> array <span class="math inline">x</span> whose rows are the data points <span class="math inline">x_i</span> for <span class="math inline">i = 0,\dots,2m-1</span> as specified above, and a vector <span class="math inline">y</span> defined by <span class="math display">
y_i= \left\{
\begin{array}{ll}
0 &amp; i = 0,\dots,m-1 \\
1 &amp; i = m,\dots,2m-1
\end{array}\right..
</span> Note that the first <span class="math inline">m</span> rows of <span class="math inline">x</span> correspond to the data points in <span class="math inline">D_0</span>, and the second <span class="math inline">m</span> rows to the data points in <span class="math inline">D_1</span>. Do not use for-loops.</p></li>
<li><p>Test your function on the following input by re-creating the figure below.</p></li>
</ol>
<div id="3b2ed3d4" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Fix randomness</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">3</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>mu1 <span class="op">=</span> np.array([<span class="dv">0</span>,<span class="dv">0</span>])</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>sigma1 <span class="op">=</span> np.array([<span class="dv">1</span>,<span class="dv">2</span>])</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>mu2 <span class="op">=</span> np.array([<span class="dv">5</span>,<span class="dv">5</span>])</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>sigma2 <span class="op">=</span> np.array([<span class="dv">3</span>,<span class="dv">2</span>])</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="dv">25</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>x_data, y_data <span class="op">=</span> synthetic_data(mu1,sigma1,mu2,sigma2,m)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="8a7efc85" class="cell" data-execution_count="4">
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="tutorial-lec8_files/figure-html/cell-5-output-1.png" class="quarto-figure quarto-figure-center figure-img" width="573" height="416"></p>
</figure>
</div>
</div>
</div>
<p>We will next perform a logistic regression on the data points using the sigmoid function <span class="math display">
f(z) = \frac{1}{1 + e^{-p(z)}}
</span> with <span class="math inline">p(z) = \alpha + \sum_{i=0}^{n-1} \beta_iz_i</span> for <span class="math inline">z = [z_0,\dots,z_{n-1}] \in \mathbb{R}^n</span>.</p>
<ol start="3" type="a">
<li><p>Write a function <code>multi_feature_logistic_regression()</code> that takes as input an <span class="math inline">m \times n</span> two-dimensional array <span class="math inline">x</span> whose rows represent data points, and an <span class="math inline">m</span>-dimensional binary vector <span class="math inline">y</span> with one label per data point. It should output an array <span class="math inline">[\alpha,\beta_0,\dots,\beta_{n-1}]</span> with the fitted coefficients of the function <span class="math inline">f</span> above, as well as an array containing the predicted labels for each data point given by the <code>predict()</code> method. <br><br> Use the <code>fit()</code> function on an instance of <code>LogisticRegression</code> to carry out this task. Set the <code>penalty</code> keyword argument to be <code>'l1'</code>. This penalty option only works with certain solvers, which you can set with the <code>solver</code> keyword argument. Check out the documentation of <code>LogisticRegression</code> to find a suitable solver.</p></li>
<li><p>Test your function on the data generated in part b).</p></li>
</ol>
<div id="f69f8cf3" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>p_coef, y_pred <span class="op">=</span> multi_feature_logistic_regression(x_data,y_data)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Coefficients of function p are"</span>, p_coef)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Coefficients of function p are [-2.125  0.411  0.729]</code></pre>
</div>
</div>
<p>Also create the confusion matrix of the outputted predicted labels (in comparison with the true labels), i.e., the <span class="math inline">(i,j)</span>-th entry of the matrix contains the number of data points whose true label was <span class="math inline">i</span> and whose predicted label is <span class="math inline">j</span>. The matrix should be the following:</p>
<div id="12dad058" class="cell" data-execution_count="7">
<div class="cell-output cell-output-stdout">
<pre><code>[[23  2]
 [ 1 24]]</code></pre>
</div>
</div>
<ol start="5" type="a">
<li>Create the plot below where all data points with predicted and true label <span class="math inline">0</span> are red, all data points with predicted and true label <span class="math inline">1</span> are blue, and all data points whose predicted label is different from its true label are black.</li>
</ol>
<div id="f34d67c0" class="cell" data-execution_count="8">
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="tutorial-lec8_files/figure-html/cell-9-output-1.png" class="quarto-figure quarto-figure-center figure-img" width="578" height="431"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="question-2" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="question-2">Question 2</h4>
<p>The goal of this exercise is to create an implementation of the <span class="math inline">k</span>-means algorithm from scratch. The input of the final algorithm that we build in the coming parts is a collection of data points <span class="math inline">x_0,\dots,x_{n-1} \in \mathbb{R}^d</span> given as the rows of an <span class="math inline">n \times d</span> array <span class="math inline">x</span>, with <span class="math inline">x_i = [x_{i0},\dots,x_{i(d-1)}]</span> for <span class="math inline">i = 0,\dots,n-1</span>.</p>
<p>We start by creating a function that can be used to choose <span class="math inline">K</span> initial centers for the <span class="math inline">K</span>-means algorithm.</p>
<ol type="a">
<li>Write a function <code>init_centers()</code> that takes as input an array <span class="math inline">x</span> as above, and a number <span class="math inline">K</span>. It should output a matrix containing <span class="math inline">K</span> rows chosen uniformly at random from the rows in <span class="math inline">x</span> (without replacement). That is, every row is equally likely to be chosen.<br> <i>Hint: A function from Section 8.1.2 might be useful here.</i></li>
</ol>
<p>Test your function on the input data below.</p>
<div id="03d2b3b2" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Fix randomness</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">3</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Data points</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>n, d <span class="op">=</span> <span class="dv">10</span>, <span class="dv">3</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.random.rand(n,d)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Center generation</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>centers <span class="op">=</span> init_centers(x,K)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(centers)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[0.649 0.278 0.676]
 [0.441 0.03  0.457]
 [0.591 0.024 0.559]
 [0.545 0.78  0.306]]</code></pre>
</div>
</div>
<p>We continue with writing a function that returns for every row <span class="math inline">x_i</span> in <span class="math inline">x</span> the index <span class="math inline">k \in \{0,\dots,K-1\}</span> of the center in the set <span class="math inline">\{c_0,\dots,c_{K-1}\}</span> that is closest to <span class="math inline">x_i</span> in <span class="math inline">L^2</span>-norm. This is Step 1 from the <span class="math inline">K</span>-means algorithm as described in Section 10.2.2.</p>
<ol start="2" type="a">
<li>Write a function <code>closest()</code> that takes as input an <span class="math inline">n \times d</span> array whose rows represent data points <span class="math inline">x_i</span>, and a <span class="math inline">K \times d</span> array whose rows represent centers <span class="math inline">c_0,\dots,c_{K-1}</span>. It should output an <span class="math inline">n</span>-dimensional array indicating on position <span class="math inline">i</span> the label/index in <span class="math inline">\{0,1,\dots,K-1\}</span> of the center that is closest to <span class="math inline">x_i</span> for <span class="math inline">i = 0,\dots,n-1</span>. <br><br> You are allowed to use the <code>distance_matrix</code> function from the <code>scipy.spatial</code> module; check the <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance_matrix.html">documentation</a> to see how this function works. The function <code>np.argmin()</code> might also be useful in your solution. Do not use for-loops in your solution.</li>
</ol>
<p>Test your function on the <code>x</code> and <code>centers</code> arrays generated in the test input of part a).</p>
<div id="41f75afa" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>label_closest <span class="op">=</span> closest(x,centers)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(label_closest)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[3 3 1 1 0 2 1 3 3 0]</code></pre>
</div>
</div>
<p>We continue with a function that takes as input an <span class="math inline">n \times d</span> array whose rows represent data points <span class="math inline">x_i</span> for <span class="math inline">i = 0,\dots,n-1</span>, and an <span class="math inline">n</span>-dimensional array whose <span class="math inline">i</span>-th entry is label <span class="math inline">L_i \in \{0,\dots,K-1\}</span> of data point <span class="math inline">x_i</span>. The function will output new centers <span class="math display">
\hat{c}_k = \frac{1}{|G_k|} \sum_{i \in G_k} x_i,
</span> where <span class="math inline">G_k = \{i : L_i = k\}</span> for <span class="math inline">k = 0,\dots,K-1</span>. This is Step 2 of the <span class="math inline">K</span>-means algorithm described in Section 10.2.2.</p>
<ol start="3" type="a">
<li>Write a function <code>new()</code> taking as input the <span class="math inline">n \times d</span> and <span class="math inline">n</span>-dimensional arrays described above, and outputs a <span class="math inline">K \times d</span> array with the <span class="math inline">\hat{c}_k</span> centers as its rows. You are allowed to use one for-loop in your solution. <i> You may assume that the input data is so that <span class="math inline">|G_k| &gt; 0</span> for any <span class="math inline">k</span>, i.e., every center has at least one data point that is closest to it.</i></li>
</ol>
<p>Test your function on the <code>x</code> array from the test input of part a), with labels the <code>label_closest</code> array generated in the test input of part b).</p>
<div id="ed21d161" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>new_center <span class="op">=</span> new(x,label_closest)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(new_center)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[0.436 0.333 0.806]
 [0.275 0.217 0.264]
 [0.591 0.024 0.559]
 [0.575 0.705 0.413]]</code></pre>
</div>
</div>
<p>We now combine the three functions written in parts a)-c) and define our <span class="math inline">K</span>-means algorithm.</p>
<ol start="4" type="a">
<li>Write a function <code>kmeans()</code> that takes as input an <span class="math inline">n \times d</span> array whose rows represent data points <span class="math inline">x_i \in \mathbb{R}^d</span> for <span class="math inline">i = 0,\dots,n-1</span>, a number of clusters <span class="math inline">K</span> and a number of iterations <span class="math inline">T</span>. It should perform <span class="math inline">T</span> iterations of the <span class="math inline">K</span>-means algorithm (as in Section 10.2.2), where the initial centers are randomly chosen using your function from part a), and where the functions in parts b) and c) are subsequently performed for <span class="math inline">T</span> iterations. <br><br> Your function should output the final centers as well as an array of labels indicating the closest center for every data point at the end of the algorithm.</li>
</ol>
<p>Test your function on the input below, which is the <code>make_blobs</code> data used in Section 10.2.</p>
<div id="6e28c6ee" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> make_blobs</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Data generation</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>x_data, _ <span class="op">=</span> make_blobs(</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>     n_samples<span class="op">=</span><span class="dv">200</span>, <span class="co"># n = 200</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>     n_features<span class="op">=</span><span class="dv">2</span>, <span class="co"># d = 2</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>     centers<span class="op">=</span>np.array([[<span class="op">-</span>r,<span class="op">-</span>r],[<span class="op">-</span>r,r],[r,r],[r,<span class="op">-</span>r]]), </span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>     cluster_std<span class="op">=</span><span class="fl">2.5</span>, </span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>     random_state<span class="op">=</span><span class="dv">32</span>, </span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Number of iterations</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Choice of number of clusters to look for</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Run K-means algorithm</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>centers, label_closest <span class="op">=</span> kmeans(x_data,K,T)</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Print found centers</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The final centers are </span><span class="ch">\n</span><span class="st">"</span>, centers)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The final centers are 
 [[ 5.187  4.922]
 [-4.527  5.368]
 [ 4.502 -5.287]
 [-4.747 -4.874]]</code></pre>
</div>
</div>
<p>Note that these centers are fairly close to the centers chosen to generate the synthetic data with.</p>
</section>
<section id="question-3" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="question-3">Question 3</h4>
<p>Recall that the quality of a clustering with centers <span class="math inline">c_0,\dots,c_{K-1}</span> can be measured in terms of the <i>sum of squared errors (SSE)</i></p>
<p><span class="math display">
\begin{array}{ll}
\displaystyle \text{SSE}_{x_0,\dots,x_{n-1}}(c_1,\dots,c_k) &amp; = \displaystyle \sum_{i=0}^{n-1} \min_{k=0,\dots,K-1} ||x_i - c_k||_2^2  \\
&amp; = \displaystyle \sum_{i=1}^{n-1} \min_{k=0,\dots,K-1} \sum_{j=0}^{d-1} (x_{ij} - c_{kj})^2
\end{array}
</span></p>
<p>which aggregates the squared <span class="math inline">L^2</span>-norm distances of all data points <span class="math inline">x_i</span> to their closest center. Recall that <span class="math inline">x_i = [x_{i0},\dots,x_{i(d-1)}]</span> for <span class="math inline">i = 0,\dots,n-1</span> and <span class="math inline">c_k =  [c_{k0},\dots,c_{k(d-1)}]</span> for <span class="math inline">k = 0,\dots,K-1</span>.</p>
<ol type="a">
<li>Using your function <code>closest()</code> from Exercise 2b), define a function <code>sse()</code> that takes as input an <span class="math inline">n \times d</span> array <span class="math inline">x</span> whose rows represent data points <span class="math inline">x_i \in \mathbb{R}^d</span>, and a <span class="math inline">K \times d</span> array whose rows represent clusters <span class="math inline">c_0,\dots,c_{K-1}</span>. It should output the SSE error function defined above. Do not use a for-loop. <br><br> <i>As a hint, try to understand the piece of code below first. Use the underlying idea to create a matrix whose rows are <span class="math inline">x_i - c_{k_i}</span> for <span class="math inline">i = 0,\dots,n-1</span>, where <span class="math inline">k_i</span> is the index of the center closest to <span class="math inline">x_i</span>.</i></li>
</ol>
<div id="25ea39fd" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> np.array([[<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">6</span>],[<span class="dv">8</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>],[<span class="dv">6</span>,<span class="dv">1</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">8</span>],[<span class="dv">41</span>,<span class="dv">1</span>,<span class="dv">17</span>,<span class="dv">9</span>,<span class="dv">18</span>]])</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>indices <span class="op">=</span> np.array([<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>])</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(z[indices])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[ 8  1  2  3  5]
 [41  1 17  9 18]
 [ 6  1  7  9  8]
 [ 1  4  3  5  6]
 [ 8  1  2  3  5]
 [ 6  1  7  9  8]]</code></pre>
</div>
</div>
<p>Test your function using the <code>x_data</code> and <code>centers</code> arrays from the test input of Exercise 2d). It should give the following output.</p>
<div id="cb6586b4" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>error <span class="op">=</span> sse(x_data,centers)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(error)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>2349.133855912266</code></pre>
</div>
</div>
<ol start="2" type="a">
<li>Write a function <code>optimal_K</code> that takes as input an <span class="math inline">n \times d</span> array <span class="math inline">x</span> whose rows represent data points <span class="math inline">x_i \in \mathbb{R}^d</span>, and numbers <span class="math inline">K_{\max}</span> and <span class="math inline">T</span>. It should output a scatter plot with for every <span class="math inline">K = 1,\dots,K_{\max}</span> the SSE computed using the centers outputted by <code>kmeans(x,K,T)</code> where <code>kmeans()</code> is the function you constructed in Exercise 2d).</li>
</ol>
<p>Test your function for <span class="math inline">K_{\max} = 10</span>, <span class="math inline">T = 100</span>, and as <span class="math inline">x</span> the array <code>x_data</code> created in the test input of Exercise 2d). Your figure should look like below. Can you give an interpretation of what you see in the figure?</p>
<div id="893b432e" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Input parameters</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>Kmax <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Create scatter plot</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>optimal_K(x_data,Kmax,T)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="tutorial-lec8_files/figure-html/cell-22-output-1.png" class="quarto-figure quarto-figure-center figure-img" width="610" height="449"></p>
</figure>
</div>
</div>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>