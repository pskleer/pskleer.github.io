[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computational Aspects in Econometrics - Python II module",
    "section": "",
    "text": "1 About",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "Computational Aspects in Econometrics - Python II module",
    "section": "1.1 Welcome",
    "text": "1.1 Welcome\nWelcome to the online “book” for the Python II module of Computational Aspects in Econometrics. We will follow the content in this book during the lectures and it is the basis of the material that will appear on the exam, so you should read through this book carefully. Because this book is new, it is likely that we will make some edits throughout the course.\nPlease not that this is an advanced Python module. We assume familiarity with the basics of programming in Python. For students enrolled in the bachelor Econometrics and Operations Research, the topics of the course Programming for EOR is a good example of what I expect you to be familiar with. An online book covering most of these topis can be found here. This book also contains some topics not covered in Programming for EOR.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "index.html#goal",
    "href": "index.html#goal",
    "title": "Computational Aspects in Econometrics - Python II module",
    "section": "1.2 Goal",
    "text": "1.2 Goal\nThe goal of this module is to teach you the basics of scientific computing with Python. Here you should think mostly of implementing algorithmic tasks that you encounter during your Econometrics and Operations Research courses, such as, linear algebra, optimization, statistics and machine learning. We hope that the skills you are taught here can be useful for, e.g., numerical work in your bachelor or (perhaps later) master thesis. Furthermore, many companies nowadays program in Python, so the topics of this module can also be useful in your professional career later in life.\nNext to teaching you how to implement certain mathematical task in a correct manner in Python, we also put emphasis on good coding practices. Especially if you start to write scripts with hundres of lines of code, it is important that you learn how to do this in a structured fasion using efficient Python functionality. Good coding practices are the topic of the next chapter. The idea is that you use these practices when doing the exercises corresponding to every lecture, as well as the group assignment.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "index.html#use-of-spyder",
    "href": "index.html#use-of-spyder",
    "title": "Computational Aspects in Econometrics - Python II module",
    "section": "1.3 Use of Spyder",
    "text": "1.3 Use of Spyder\nThis course document is based on the use of Spyder as integrated development environment (IDE) for creating Python code, i.e., the program that the code is written in. You can also use VS code or any other IDE to do the exercises and/or assignment in. Whenever this book contains screenshots to illustrate something, they will have been taken in Spyder.\nTo install the Anaconda distribution containing Spyder, follow the steps here. This is the installation that was alos recommended in the Python I module.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "02-good-coding.html",
    "href": "02-good-coding.html",
    "title": "2  Good coding practices",
    "section": "",
    "text": "2.1 Efficient computations\nPerhaps the most important topic of this course is that of efficient computation, i.e., to make efficient use of the mathematical functionality that Python has to offer, in particular the functionality of the NumPy package.\nThe way to think of this is as follows: Many of the mathematical tasks and exercises that we will see could, in theory, be solved using for- and/or while-loops, as well as if/else-statements. However, there are often more efficient functions programmed in the NumPy package in Python that can carry out these task in a quicker way using less code!\nLet us look at an example. Suppose I am given a vector x = [x_1,\\dots,x_n] \\in \\mathbb{R}^n, and I want to compute the L^2-norm \n||x||_2 = \\sqrt{\\sum_{i=1}^n x_i^2}\n of this vector. One way to solve this directly would be by using a for-loop to compute the sum inside the square root, and then take the square root of this number. We will illustrate this next for the vector x = [1,2,3,\\dots,300.000].\n# Length of vector\nn = 300000\n\n# Compute inner summation of ||x||_2\ninner_sum = 0\nfor i in range(1,n+1):\n    inner_sum = inner_sum + i**2\n\n# Take square root\ntwo_norm = (inner_sum)**(0.5)\n\n# Print value of two-norm\nprint(two_norm)\n\n94868566.97584295\nAnother way to do this is to define the vector x efficiently making use of the arange() function in Numpy, followed by the linalg.norm() function that can compute the L^2-norm for us directly. We will see these functions in more detail in a subsequent chapter.\nIt is standard convention to import the Numpy package under the alias np.\n#Import Numpy package under the alias np\nimport numpy as np\n\n# Length of vector\nn = 300000\n\n# Define vector x as array using arange() function\nx = np.arange(1,n+1)\n\n# Compute two-norm with built-in function\ntwo_norm = np.linalg.norm(x)\n\n# Print value of two-norm\nprint(two_norm)\n\n94868566.97584295\nThis is a much cleaner, and in fact faster, way to compute the L^2-norm of the vector x. Especially for large values of n, the second piece of code that exploits the Numpy functionality can be much faster! The Python code below (which we will not discuss) illustrates this comparison by timing how long both approaches require to compute the norm for n = 30.000.000 (i.e., thirty million). If you run the code below on your own device, you might get different outputs, but, in general, there should be a significant (multiplicative) difference in execution time.\nCode that times execution of the two approaches above\nimport numpy as np\nimport time\n\n## Computing norm with for-loop\n\n# We determine the time it takes to input the code between start and end\nstart = time.time()\n\n# Length of vector\nn = 30000000\n\n# Compute inner summation of ||x||_2\ninner_sum = 0\nfor i in range(1,n+1):\n    inner_sum = inner_sum + i**2\n\n# Take square root\ntwo_norm = (inner_sum)**(0.5)\n\nend = time.time()\n\n# Time difference\nloop_time = end - start\nprint('%.10f seconds needed for computing norm' % (loop_time), \n      'with for-loop')\n\n## Computing norm with Numpy functions\n\n#We determine the time it takes to input the code between start and end\nstart = time.time()\n\n# Length of vector\nn = 30000000\n\n# Define vector x as array using arange() function\nx = np.arange(1,n+1)\n\n# Compute two-norm with built-in function\ntwo_norm = np.linalg.norm(x)\n\nend = time.time()\n\n# Time difference\nnumpy_time = end - start\nprint('%.10f seconds needed for computing norm' % (numpy_time), \n      'with Numpy functions')\n\n\n#This shows how many times faster Numpy approach is faster than for-loop solution\nif numpy_time != 0:\n    (print('NumPy\\'s approach is %i times more efficient than for-loop approach.'\n            % ((loop_time)/(numpy_time))))\n\n\n10.1826477051 seconds needed for computing norm with for-loop\n0.1143376827 seconds needed for computing norm with Numpy functions\nNumPy's approach is 89 times more efficient than for-loop approach.\nOne important take-away of the above comparison is the following.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Good coding practices</span>"
    ]
  },
  {
    "objectID": "02-good-coding.html#efficient-computations",
    "href": "02-good-coding.html#efficient-computations",
    "title": "2  Good coding practices",
    "section": "",
    "text": "When performing mathematical tasks, avoid the use of for- and while-loops, as well as if/else-statements, by efficient use of Python functionality.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Good coding practices</span>"
    ]
  },
  {
    "objectID": "02-good-coding.html#no-hard-coding",
    "href": "02-good-coding.html#no-hard-coding",
    "title": "2  Good coding practices",
    "section": "2.2 No hard coding",
    "text": "2.2 No hard coding\nSuppose we are given the function f(x) = a \\cdot x^2+ a\\cdot b \\cdot x - a \\cdot b \\cdot c and the goal is to compute f(10) for a = 3, b = 4 and c = -10. One way of doing this would be to plug in all the variables and return the resulting function value.\n\n# Hard coding\nprint(3*(10**2) + 3*4*10 + 4*-2*3)\n\n396\n\n\nHowever, this is inefficient for the following reason: If we would want to change the number x = 10 to, e.g., x = 20, we would have to twice replace 10 by 20. The same is true for the variable a, which appears in even three places. In general, in large scripts, variables can appear in more than a hundred places. To overcome this inefficiency issue, it is always better to separate the input data (the x,a,b and c in this case) from the function execution\n\n# No hard coding\ndef f(x, a, b, c):\n    return a*x**2 + a*b*x + b*c*a\n\nx = 10\na, b, c = 3, 4, -2\nprint(f(x, a, b, c))\n\n396\n\n\nThe take-away of the above comparison is the following.\n\nSeparate input data from the execution of functions and commands.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Good coding practices</span>"
    ]
  },
  {
    "objectID": "02-good-coding.html#dont-repeat-yourself-dry",
    "href": "02-good-coding.html#dont-repeat-yourself-dry",
    "title": "2  Good coding practices",
    "section": "2.3 Don’t repeat yourself (DRY)",
    "text": "2.3 Don’t repeat yourself (DRY)\nIf you have to carry out a piece of code for multiple sets of input data, always avoid copy-pasting the code. As a first step, try to to the repeated execution using a for-loop. For example, suppose we want to print the function values f(x,3,4,-2) for x = 1,2,3,4, with f as in the previous section. We can do this as follows.\n\ndef f(x, a, b, c):\n    return a*x**2 + a*b*x + b*c*a\n\na, b, c = 3, 4, -2\n\n# With repetition\nx = 1\nprint('%.2f' % f(x,a,b,c))\nx = 2\nprint('%.2f' % f(x,a,b,c))\nx = 3\nprint('%.2f' % f(x,a,b,c))\nx = 4\nprint('%.2f' % f(x,a,b,c))\n\n-9.00\n12.00\n39.00\n72.00\n\n\nA more efficient way of typing this, is by using a for-loop that repeatedly executes the print statement.\n\nimport numpy as np\n\na, b, c = 3, 4, -2\nx = [1,2,3,4]\n# Determine all function values with list comprehension\ny = [f(i,a,b,c) for i in x]\n\n# Print values in y (could also print the whole vector y right away)\nfor j in y:\n    print(j)\n\n-9\n12\n39\n72\n\n\nThe take-away of the above comparison is the following.\n\nDon’t carry out the same task on different inputs twice by copy-pasting code, but use, e.g., a for-loop in which you iterate over the inputs.\n\nIn fact, later on in the course we will explain the concept of vectorizing a function, to make sure it can handle multiple input simultaneously. This is another way to avoid unnecessary repetition and in fact also the use of loops.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Good coding practices</span>"
    ]
  },
  {
    "objectID": "02-good-coding.html#single-responsibility",
    "href": "02-good-coding.html#single-responsibility",
    "title": "2  Good coding practices",
    "section": "2.4 Single responsibility",
    "text": "2.4 Single responsibility\nWhen you write larger pieces of codes, it is often useful to split it up in smaller parts that all serve their own purpose. Suppose we want to implement Newton’s method for finding a root x of a function f : \\mathbb{R} \\rightarrow \\mathbb{R}, i.e., a point x that satisfies f(x) = 0.\nNewton’s methods starts with a (suitably chosen) initial guess x_0 \\in \\mathbb{R} and repeatedly computes better approximations using the recursive formula \nx_{i+1} = x_i - \\frac{f(x_i)}{f'(x_i)}\n\nThe goal is to implement this formula for the function f(x) = (x-1)^2 - 1, whose derivative is f'(x) = 2(x-1). The roots of this function are x = 0 and x = 2.\n\n# We implement the function y = x - f(x)/f'(x)\ndef y(x):\n    return x - ((x-1)**2 - 1)/(2*(x-1))\n\nx0 = 3\nx1 = y(x0) \n\nprint(x1)\n\n2.25\n\n\nA clearer way to implement the formula x_{i+1} = x_i - f(x_i)/f'(x_i) is to define separate functions for the evaluation of the functions f and f', and then combine these to create the recursive formula. In this way, we get three functions that are each responsible for one aspect of Newton’s formula, namely implementing the function f, implementing the function f' and computing the recursive formula. This also makes it easier for a user of the code to understand what is happening.\n\n# Single responsibility version\n\n# Define f\ndef f(x):\n    return (x-1)**2 - 1\n\n# Define f'\ndef fprime(x):\n    return 2*(x-1)\n\n# Implement function y = x - f(x)/f'(x)\ndef y(x):\n    return x - f(x)/fprime(x)\n\nx0 = 3\nx1 = y(x0) \n\nprint(x1)\n\n2.25\n\n\nThe take-away of the above comparison is the following.\n\nIf you are implementing a complex mathematical task involving multiple aspects, try to separate these aspects in different functions.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Good coding practices</span>"
    ]
  },
  {
    "objectID": "02-good-coding.html#documentation",
    "href": "02-good-coding.html#documentation",
    "title": "2  Good coding practices",
    "section": "2.5 Documentation",
    "text": "2.5 Documentation\nThe final good coding practice that we discuss is documentation. Ideally, you should always explain inside a function what the inputs and outputs are, and for larger scripts it is good to indicate what every part of the script does. For smaller functions and scripts this is not always necessary. We will next give an example for Newton’s method as in the previous section\n\n## Function that implements Newton's method\ndef newton(f,fprime,x0,iters):\n    \"\"\"\n    This function implements Newton's iterative method \n    x_{i+1} = x_i - f(x_i)/f'(x_i) for finding root of f.\n    \n    Input parameters\n    ----------\n    f : Function f\n    fprime : Derivative of the function f\n    x0 : Initial estimate for root x of f.\n    iters : Number of iterations that we run Newton's method.\n    \n    Returns\n    -------\n    Approximation for x satisfying f(x) = 0.\n    \"\"\"\n    \n    # Initial guess\n    x = x0 \n    \n    # Repeatedly compute the recursive formula \n    # by overwriting x for 'iters' iterations\n    for i in range(iters):\n        x_new = x - f(x)/fprime(x) \n        x = x_new\n    return x\n    \n## An example of Newton's method as implemented above\n\n# Define f\ndef f(x):\n    return (x-1)**2 - 1\n\n# Define f'\ndef fprime(x):\n    return 2*(x-1)\n    \n# Define intial guess and number of iterations\nx0 = 10\niters = 6   \n\n# Run Newton's method\nroot = newton(f,fprime,x0,iters)\n\n# Print output and explain what has been computed\nprint('Running Newton\\'s method for %.i iterations with initial' % iters,\n       'estimate %.2f' % x0,'\\n','gives (estimated) root x = %.7f' % root, \n       'with f(x) = %.7f' % f(root))\n\nRunning Newton's method for 6 iterations with initial estimate 10.00 \n gives (estimated) root x = 2.0000013 with f(x) = 0.0000025\n\n\nThe following is a set of guidelines regarding how to add documentation to a function.\n\nTry to adhere to the following documention rules when writing complex functions:  1. Function documentation between triple double-quote characters. 2. Clearly describe what a function does and what its input and output arguments are. 3. Choose descriptive variable names, lines not longer than 80 characters. 4. Don’t add comments for every line. Add comments for main ideas and complex parts.  5. A comment should not repeat the code as text (e.g. “time = time + 1 # increase time by one).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Good coding practices</span>"
    ]
  },
  {
    "objectID": "03-numpy-arrays.html",
    "href": "03-numpy-arrays.html",
    "title": "3  NumPy arrays",
    "section": "",
    "text": "3.1 Introduction\nThe NumPy package (module) is used in almost all numerical computations using Python. It is a package that provides high-performance vector, matrix and higher-dimensional data structures for Python. High-performance here refers to the fact that Python can perform computations on such data structures very quickly if appropriate functions are used for this.\nTo use NumPy you need to import the numpy module. This is typically done under the alias np so that you don’t have to type numpy all the time when using a function from the module.\nimport numpy as np\nWe emphasize at this point that there is often not a unique way or command to achieve a certain outcome. When doing the exercises corresponding to the theory given in this chapter, it is, however, recommended to find a solution using the presented functionality.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>NumPy arrays</span>"
    ]
  },
  {
    "objectID": "03-numpy-arrays.html#creating-arrays",
    "href": "03-numpy-arrays.html#creating-arrays",
    "title": "3  NumPy arrays",
    "section": "3.2 Creating arrays",
    "text": "3.2 Creating arrays\nIn the NumPy package the data type used for vectors, matrices and higher-dimensional data sets is an array. There are a number of ways to initialize new arrays, for example from\n\na Python list or tuples;\nusing functions that are dedicated to generating numpy arrays, such as arange() and linspace() (we will see those later);\nreading data from files.\n\n\n3.2.1 Lists\nFor example, to create new vector and matrix arrays from Python lists we can use the numpy.array() function. Since we imported NumPy under the alias np, we use np.array() for this.\nTo create a vector, the argument to the array function is a Python list\n\nv = np.array([1,2,3,4]) #Array creation from list [1,2,3,4]\nprint(v)\n\n[1 2 3 4]\n\n\nTo create a matrix, the argument to the array function is a nested Python list. Every element of the outer list is a list corresponding to a row of the matrix. For example, the matrix \nM = \\left[ \\begin{matrix}1 & 2 & 7\\\\ 3 & -4 & 4 \\end{matrix} \\right]\n is created as follows.\n\nM = np.array([[1, 2, 7], [3, -4, 4]])\nprint(M)\n\n[[ 1  2  7]\n [ 3 -4  4]]\n\n\nYou can access the shape (number of rows and columns) , size (number of elements) and number of dimensions (number of axes in matrix) of the array with the shape, size and ndim attributes, respectively. Note that the size is simply the product of the numbers in the shape tuple, and the number of dimensions is the size of the shape tuple.\n\n# Shape of matrix M\nshape_M = M.shape  #np.shape(M) also works\nprint(shape_M) \n\n(2, 3)\n\n\n\n# Size of matrix M\nsize_M = M.size  #np.size(M) also works\nprint(size_M) \n\n6\n\n\n\n# Number of diemenions\nndim_M = M.ndim  #np.ndim(M) also works\nprint(ndim_M) \n\n2\n\n\nNumPy arrays are of the type ndarray (short for n-dimensional array). You can access this type through the type() function.\n\n# Type of matrix M\ntype_M = type(M)\nprint(type_M) \n\n&lt;class 'numpy.ndarray'&gt;\n\n\nSo far a NumPy array looks awfully much like a Python list (or nested list). Why not simply use Python lists for computations instead of creating a new array type?\nThere are several reasons:\n\nPython lists are very general. They can contain any kind of object. They are dynamically typed. They do not support mathematical functions such as matrix and dot multiplications.\nNumpy arrays are statically typed and homogeneous. The type of the elements is determined when the array is created.\nNumpy arrays are memory efficient.\nBecause of the static typing, fast implementation of mathematical functions such as multiplication and addition of numpy arrays can be implemented in a compiled language (C and Fortran are used).\n\nUsing the dtype (data type) attribute of an array, we can see what type the data inside an array has.\n\n# Data type of elements in array\ndtype_M = M.dtype\nprint(dtype_M)\n\nint32\n\n\nIf we want, we can explicitly define the type of the array data when we create it, using the dtype keyword argument:\n\n# Define data as integers\nM = np.array([[1, 2], [3, 4]], dtype=int)\nprint('M = \\n', M)\n\nM = \n [[1 2]\n [3 4]]\n\n\n\n# Define data as floats\nN = np.array([[1, 2], [3, 4]], dtype=float)\nprint('N = \\n', N)\n\nN = \n [[1. 2.]\n [3. 4.]]\n\n\n\n# Define data as complex floats\nO = np.array([[1, 2], [3, 4]], dtype=complex)\nprint('O = \\n', O)\n\nO = \n [[1.+0.j 2.+0.j]\n [3.+0.j 4.+0.j]]\n\n\nCommon data types that can be used with dtype are: int, float, complex, bool, object, etc.\nWe can also explicitly define the bit size of the data types, such as: int64, int16, float128, complex128. For example, int64 allows us to define an integer variable in the range [−264,…,264].\nYou can also change the data type of the elements using the astype() method.\n\nM = np.array([[1,2], [3,4]])\nprint(M.dtype)\n\nint32\n\n\n\n# Define M_float as matrix whose elements are those of \n# the matrix M, but then as floats.\nM_float = M.astype(float)\nprint(M_float)\n\n[[1. 2.]\n [3. 4.]]\n\n\n\nprint(M_float.dtype)\n\nfloat64\n\n\n\n\n3.2.2 Arrays froms functions\nThere are various useful arrays that can be automatically created using functions from the NumPy package. These arrays are typically hard to implement directly as a list.\narange(n): This function creates the array [0,1,2,\\dots,n-1] whose elements range from 0 to n-1.\n\nn = 10\nx = np.arange(n) \n\nprint(x)\n\n[0 1 2 3 4 5 6 7 8 9]\n\n\nIf you want to explicitly define the data type of the elements, you can add the dtype keyword argument (the same applies for all functions that are given below).\n\nn = 10\nx = np.arange(n, dtype=float) \n\nprint(x)\n\n[0. 1. 2. 3. 4. 5. 6. 7. 8. 9.]\n\n\narange(a,b): This function creates the array [a,a+1,a+2,\\dots,b-2,b-1].\n\na, b = 5,11\nx = np.arange(a,b)\n\nprint(x)\n\n[ 5  6  7  8  9 10]\n\n\narange(a,b,step): This function creates the array [a,a+step,a+2\\cdot step,\\dots,b-2\\cdot step,b-step]. That is, the array ranges from a to b (but not including b itself), in steps of size step.\n\na, b, step = 5, 11, 0.3\nx = np.arange(a,b,step)\n\nprint(x)\n\n[ 5.   5.3  5.6  5.9  6.2  6.5  6.8  7.1  7.4  7.7  8.   8.3  8.6  8.9\n  9.2  9.5  9.8 10.1 10.4 10.7]\n\n\nlinspace(a,b,k): Create a discretization of the interval [a,b] containing k evenly spaced points, including a and b as the first and last element of the array.\n\na,b,k = 5,10,20\nx = np.linspace(a,b,k)\n\nprint(x)\n\n[ 5.          5.26315789  5.52631579  5.78947368  6.05263158  6.31578947\n  6.57894737  6.84210526  7.10526316  7.36842105  7.63157895  7.89473684\n  8.15789474  8.42105263  8.68421053  8.94736842  9.21052632  9.47368421\n  9.73684211 10.        ]\n\n\ndiag(x): This function creates a matrix whose diagonal contains the list/vector/array x.\n\nx = np.array([1,2,3])\nD = np.diag(x)\n\nprint(D)\n\n[[1 0 0]\n [0 2 0]\n [0 0 3]]\n\n\nnp.zeros(n): This function create a vector of length n with zeros.\n\nn = 5\nx = np.zeros(n)\n\nprint(x)\n\n[0. 0. 0. 0. 0.]\n\n\nnp.zeros((m,n)): This function create a matrix of size m \\times n with zeros. Note that we have to input the size of the matrix as a tuple (m,n); using np.zero(m,n)\n\nm, n = 2, 5\nM = np.zeros((m,n))\n\nprint(M)\n\n[[0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0.]]\n\n\nnp.ones(n) and np.ones((m,n)): These functions create a vector of length n with ones, and a matrix of size m \\times n with ones, respectively.\n\nm, n = 2, 5\nx = np.ones(n)\n\nprint(x)\n\n[1. 1. 1. 1. 1.]\n\n\n\nM = np.ones((m,n))\n\nprint(M)\n\n[[1. 1. 1. 1. 1.]\n [1. 1. 1. 1. 1.]]\n\n\nmgrid[a:b,c:d]: This function can be used to generate a “grid” of integer points in [a,b-1] \\times [c,d-1] for a,b,c,d, \\in \\mathbb{N}.\nIn the execution below, the idea is that the function generates two matrices x and y, so that points (x[i][j],y[i][j]) correponds to a grid point (a+i,c+j) for i = 0,\\dots,a-(b-1) and j = 0,\\dots,c - (d-1). More generally, for a given grid point (a+i,c+j), the matrix x stores the first coordinate a+i, and y the second coordinate c+j.\n\na,b = 0,5\nc,d = 2,6\nx, y = np.mgrid[a:b, c:d]\n\n\nprint(x)\n\n[[0 0 0 0]\n [1 1 1 1]\n [2 2 2 2]\n [3 3 3 3]\n [4 4 4 4]]\n\n\n\nprint(y)\n\n[[2 3 4 5]\n [2 3 4 5]\n [2 3 4 5]\n [2 3 4 5]\n [2 3 4 5]]\n\n\n\n\n3.2.3 Reading data from files\nThe third option, which you might use most often in a professional context, is to read in data from a file directly into a NumPy array. You can do this using the loadtxt() function.\nIf you want to try this yourself, download the file numerical_data.dat here and store it in the same folder as where you are storing the Python script in which you execute the code snippet below.\n\n# Load data into NumPy array\ndata_dat = np.loadtxt('numerical_data.dat')\n\n# Print the data\nprint(data_dat)\n\n[[ 1.   5.   4.  -9.   1. ]\n [ 3.   5.   6.   7.   7. ]\n [ 4.   3.   2.   1.   0.5]]\n\n\nPython puts every row in the data (DAT) file into a separate row of the NumPy array; note that the numbers in the data file are separated by a whitespace character.\nWe can also save data from a Numpy array into a DAT-file using the savetxt() function. The first argument of this function is the name of the file in which you want to store the array, and the second argument is the array to be stored.\n\n# Matrix M\nM = np.array([[1,2,3],[5,6,7],[10,11,12],[14,15,16]])\n\n# Save matrix to DAT file\nnp.savetxt('matrix.dat', M)\n\nThis should have created the file matrix.dat in the same folder as where you stored the Python script that ran the code above. You might notice that the numbers are stored using the scientific notation. For example, the number 1 appears as 1.000000000000000000e+00 in the CSV-file.\nYou can suprress this behaviour by explicitly specifying the data type in which you want the numbers in the matrix to be stored using the fmt keyword argument. For example, fmt = '%i' stores the numbers as integers.\n\n# Matrix M\nM = np.array([[1,2,3],[5,6,7],[10,11,12],[14,15,16]])\n\n# Save matrix to DAT file\nnp.savetxt('matrix_int.dat', M, fmt='%i')\n\nThis should have created the file matrix_int.dat in the same folder as where you stored the Python script that ran the code above.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>NumPy arrays</span>"
    ]
  },
  {
    "objectID": "03-numpy-arrays.html#accessing",
    "href": "03-numpy-arrays.html#accessing",
    "title": "3  NumPy arrays",
    "section": "3.3 Accessing",
    "text": "3.3 Accessing\nIn this section we will describe how you can access, or index, the data in a NumPy array.\nWe can index elements in an array using square brackets and indices, just like as with lists. In NumPy indexing starts at 0, just like with a Python list.\n\nv = np.array([12,4,1,9])\n\n# Element in position 0\nprint(v[0])\n\n# Element in position 2\nprint(v[2])\n\n# Element in position -1 (last element)\nprint(v[-1]) # Same as v[3]\n\n# Element in position -3 (counted backwards)\nprint(v[-3]) # Same as v[1]\n\n12\n1\n9\n4\n\n\n\n3.3.1 Basic indexing\nIf you want to access the element at position (i,j) from a two-dimensional array, you can use the double bracket notation [i][j], but with arrays you can also use the more compact syntax [i,j].\n\nM = np.array([[10,2,6,7], [-15,6,7,-8], [9,10,11,12],[3,10,6,1]])\n\n# Element at position (1,1)\nprint('List syntax:',M[1][1])\n\n# Element at position (1,1)\nprint('Array syntax', M[1,1])\n\nList syntax: 6\nArray syntax 6\n\n\nIf you want to access row i you can use M[i] or M[i,:].\n\nprint(M[2]) # Gives last row\n\nprint(M[2,:]) # Gives last row\n\n[ 9 10 11 12]\n[ 9 10 11 12]\n\n\nIf you want to access column j you can use M[:,j]. Both here and in the previous command, the colon : is used to indicate that we want all the elements in the respective dimension. So M[:,j] should be interpreted as, we want the elements from all rows in the j-th column.\n\n\n3.3.2 Index slicing\nIndex slicing is the technical name for the index syntax that returns a slice, a consecutive part of an array.\n\nv = np.array([12,4,1,9,11,14,17,98])\n\nprint(v)\n\n[12  4  1  9 11 14 17 98]\n\n\nv[lower:upper]: This return the elements in v at positions lower, lower+1,...,upper-1. Note that the element at position upper is not included.\n\n# Returns v[1], v[2], v[3], v[4], v[5]\nprint(v[1:6]) \n\n[ 4  1  9 11 14]\n\n\nYou can also omit the lower or upper value, in which case it is set to be position 0 or the last position -1, respectively.\n\n# Returns v[3],...,v[8]\nprint(v[3:]) \n\n# Returns v[0],...,v[4]\nprint(v[:5]) \n\n[ 9 11 14 17 98]\n[12  4  1  9 11]\n\n\nv[lower:upper:step]: This returns the elements in v at position lower,lower+step,lower+2*step,...(upper-1)-step, (upper-1). It does the same as [lower:upper], but now in steps of size step.\n\nv = np.array([12,4,1,9,11,14,17,98])\n\n# Returns v[1], v[3], v[5]\nprint(v[1:6:2]) \n\n[ 4  9 14]\n\n\nYou can omit any of the three parameters lower,upper and step\n\n# lower, upper, step all take the default values\nprint(v[::])\n\n# Index in step is 2 with lower and upper defaults \nprint(v[::2]) \n\n# Index in steps of size 2 starting at position 3\nprint(v[3::2]) \n\n[12  4  1  9 11 14 17 98]\n[12  1 11 17]\n[ 9 14 98]\n\n\nYou can also use slicing with negative index values.\n\n# The last three elements of v\nprint(v[-3:]) \n\n[14 17 98]\n\n\nFurthermore, the same principles apply to two-dimensional arrays, where you can specify the desired indices for both dimensions\n\nM = np.array([[10,2,6,7], [-15,6,7,-8], [9,10,11,12],[3,10,6,1]])\n\nprint(M)\n\n[[ 10   2   6   7]\n [-15   6   7  -8]\n [  9  10  11  12]\n [  3  10   6   1]]\n\n\n[a:b, c:d]: This returns the submatrix consisting of the rows a,a+1,...,b-1 and rows c,c+1,...,d. You can also combine this with a step argument, i.e., use [a:b:step1, c:d:step2].\n\n# Returns elements in submatrix formed by rows 2,3 (excluding 4)\n# and columns 1,2 (excluding 3)\nprint(M[2:4,1:3]) \n\n[[10 11]\n [10  6]]\n\n\nIf you want to obtain a submatrix whose rows and/or columns do not form a consecutive range, or if you want to specify these list manually, you can use the ix_() function from NumPy. Its arguments should be a list of row indices, and a list of column indices specifying the indices of the desired submatrix.\n\ni = [0,2,3]\nj = [0,3]\n\n# Returns submatrix formed by rows 0,2,3 and columns 0,3\nprint(M[np.ix_(i,j)])\n\n[[10  7]\n [ 9 12]\n [ 3  1]]\n\n\n\n\n3.3.3 Fancy indexing\nFancy indexing is the name for when an array or list is used instead of indices, to access part of an array. For example, if you want to access elements in the locations (0,3), (1,2) and (1,3), you can define a list of row indices [0,1,1] and columns indices [3,2,3] and access the matrix with these lists.\n\ni = [0,1,1]\nj = [3,2,3]\n\n# Returns M[0,3] = 7, M[1,2] = 7, M[1,3] = -8\nprint(M[i,j])\n\n[ 7  7 -8]\n\n\nAnother way of fance indexing is by using a Boolean list, that indicates for every element whether it should be index (True) or not (False). Such a list is sometimes called a mask.\n\nv = np.array([1,6,2,3,9,3,6])\n\n# Tell for every element whether is should be index\nmask = [False, True, True, True, False, True, False]\n\nprint(v[mask])\n\n[6 2 3 3]\n\n\nTypically, the mask is generated from a Boolean statement. For example, suppose we want to select all elements strictly smaller than 3 and greater or equal than 7 from the array v.\nThe following statements achieve this. Recall that you can use & if you want the first AND the second statement to be satisfied, and | if either the first OR the second has to be satisfied (or both).\n\nmask_37 = (v &lt; 3) | (v &gt;= 7)\n\n# Boolean vector indiciating for ever element in v\n# whether the conditions v &lt; 3 and v &gt;= 7 are satisfied\nprint(mask_37)\n\n[ True False  True False  True False False]\n\n\nWe can now access the elements satisfying these conditions by indexing v with this mask\n\nprint(v[mask_37])\n\n[1 2 9]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>NumPy arrays</span>"
    ]
  },
  {
    "objectID": "03-numpy-arrays.html#modifying",
    "href": "03-numpy-arrays.html#modifying",
    "title": "3  NumPy arrays",
    "section": "3.4 Modifying",
    "text": "3.4 Modifying\n\n3.4.1 Elements, rows or columns\nUsing similar ways of indexing as in the previous section, we can also modify the elements of an array\n\nM = np.array([[1,1,1,1], [2,2,2,2], [3,3,3,3],[4,4,4,4]])\n\nprint(M)\n\n[[1 1 1 1]\n [2 2 2 2]\n [3 3 3 3]\n [4 4 4 4]]\n\n\n\n# Modify individual element\nM[0,1] = -1\n\nprint(M)\n\n[[ 1 -1  1  1]\n [ 2  2  2  2]\n [ 3  3  3  3]\n [ 4  4  4  4]]\n\n\n\n# Modify (part of a) row\nM[1,[1,2,3]] = [-2,-2,-2]\n\nprint(M)\n\n[[ 1 -1  1  1]\n [ 2 -2 -2 -2]\n [ 3  3  3  3]\n [ 4  4  4  4]]\n\n\n\n# Modify third column to ones\nM[:,3] = np.ones(4)\n\nprint(M)\n\n[[ 1 -1  1  1]\n [ 2 -2 -2  1]\n [ 3  3  3  1]\n [ 4  4  4  1]]\n\n\n\n\n3.4.2 Broadcasting\nThere does not necessarily have to be a match between the part of the matrix that we index, and the dimensions of the data that we want to overwrite that part with.\n\nM = np.array([[1,1,1,1], [2,2,2,2], [3,3,3,3],[4,4,4,4]])\n\nprint(M)\n\n[[1 1 1 1]\n [2 2 2 2]\n [3 3 3 3]\n [4 4 4 4]]\n\n\nFor example, in order to replace the third column of M by ones, we can also do the command below, instead of using np.ones(4).\n\n# Modify third column to ones\nM[:,3] = 1\n\nprint(M)\n\n[[1 1 1 1]\n [2 2 2 1]\n [3 3 3 1]\n [4 4 4 1]]\n\n\nAlthough there is a mismatch between the indexed part on the left (a column) and the data on the right (single number), Python broadcasts the data to an appopriate format by copying it to the correct size. That is, it copies the 1 to an array [1,1,1,1] of ones, which it then places in the third column.\nThis works similar in higher dimensions. Suppose we want to overwrite the second and third row with [1,6,2,3]. Then the indexed part is a 2 \\times 4 array, but the data a 1 \\times 4 array.\n\n# Modify second and third row\nM[2:4,:] = [1,6,2,3]\n\nprint(M)\n\n[[1 1 1 1]\n [2 2 2 1]\n [1 6 2 3]\n [1 6 2 3]]\n\n\nPython here first copies the data to [[1,6,2,3],[1,6,2,3]] and then modifies M with this array.\n\n\n3.4.3 Transpose\nAnother useful function, in the context of linear algebra, is to take the transpose of a two-dimensional array M, which modifies the entries along the diagonal.\n\nM = np.array([[1,2,3],[3,4,-1]])\n\nprint(M)\n\n[[ 1  2  3]\n [ 3  4 -1]]\n\n\n\ntranspose_M = M.T #np.transpose(M) also works\nprint(transpose_M) \n\n[[ 1  3]\n [ 2  4]\n [ 3 -1]]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>NumPy arrays</span>"
    ]
  },
  {
    "objectID": "03-numpy-arrays.html#repeating-and-stacking",
    "href": "03-numpy-arrays.html#repeating-and-stacking",
    "title": "3  NumPy arrays",
    "section": "3.5 Repeating and stacking",
    "text": "3.5 Repeating and stacking\nWe can also use existing matrices and build new ones from it by stacking them either horizontally or vertically.\ntile(M,(k,r)): This function takes an array M and copies it k times vertically and r times horizontally, resulting in a “tiling” of the original array M.\n\nM = np.array([[1,2],[3,4]])\n\nM_tile = np.tile(M,(2,3))\nprint(M_tile)\n\n[[1 2 1 2 1 2]\n [3 4 3 4 3 4]\n [1 2 1 2 1 2]\n [3 4 3 4 3 4]]\n\n\nIf you do not input a tuples with two arguments, but only a number, then tile() does the tiling only horizontally.\n\nM = np.array([[1,2],[3,4]])\n\nM_tile = np.tile(M,4)\nprint(M_tile)\n\n[[1 2 1 2 1 2 1 2]\n [3 4 3 4 3 4 3 4]]\n\n\nrepeat(M,k): This function takes every element of M, repeats it k times, and puts all these numbers in a one-dimension array.\n\nM = np.array([[1,2],[3,4]])\n\nM_repeat = np.tile(M,3)\nprint(M_repeat)\n\n[[1 2 1 2 1 2]\n [3 4 3 4 3 4]]\n\n\nvstack(a,b): This stacks two arrays a and b vertically, provided they have the correct dimensions to do this.\n\na = np.array([7,8])\nM = np.array([[1,2],[3,4]])\n\nM_a = np.vstack((M,a))\nprint(M_a)\n\n[[1 2]\n [3 4]\n [7 8]]\n\n\nhstack(a,b): This stacks two arrays a and b horizontally, provided they have the correct dimensions to do this.\nNote that in the example below we define a as a 1 \\times 2 array, i.e., a column array, to make sure we can stack it right of M. If we would have kept a = np.array([7,8]) then Python will give an error, because it cannot stack a row vector next to a two-dimensional array.\n\na = np.array([[7],[8]])\nM = np.array([[1,2],[3,4]])\n\nM_a = np.hstack((M,a))\nprint(M_a)\n\n[[1 2 7]\n [3 4 8]]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>NumPy arrays</span>"
    ]
  }
]