<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.52">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>6&nbsp; Nonlinear algebra and optimization – Computational Aspects in Econometrics - Python II module</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<link href="./07-visualization.html" rel="next">
<link href="./05-linear.html" rel="prev">
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="style.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./06-nonlinear.html"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Nonlinear algebra and optimization</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Computational Aspects in Econometrics - Python II module</a> 
        <div class="sidebar-tools-main">
    <a href="./Computational-Aspects-in-Econometrics---Python-II-module.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">About</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-good-coding.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Good coding practices</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-numpy-arrays.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">NumPy arrays</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-vectorization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Vectorization</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-linear.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Linear algebra and optimization</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-nonlinear.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Nonlinear algebra and optimization</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-visualization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Visualization</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-probability.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Probability theory</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09-data-fitting.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Statistics and data fitting</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10-learning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Learning problems</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11-higher-dimensional.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Higher-dimensional arrays</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./A-errata.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Corrections and changes</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./B-function-basics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Function basics</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#root-finding" id="toc-root-finding" class="nav-link active" data-scroll-target="#root-finding"><span class="header-section-number">6.1</span> Root finding</a>
  <ul class="collapse">
  <li><a href="#univariate-function" id="toc-univariate-function" class="nav-link" data-scroll-target="#univariate-function"><span class="header-section-number">6.1.1</span> Univariate function</a></li>
  <li><a href="#multivariate-functions" id="toc-multivariate-functions" class="nav-link" data-scroll-target="#multivariate-functions"><span class="header-section-number">6.1.2</span> Multivariate functions</a></li>
  <li><a href="#least-squares-method" id="toc-least-squares-method" class="nav-link" data-scroll-target="#least-squares-method"><span class="header-section-number">6.1.3</span> Least squares method</a></li>
  </ul></li>
  <li><a href="#nonlinear-optimization" id="toc-nonlinear-optimization" class="nav-link" data-scroll-target="#nonlinear-optimization"><span class="header-section-number">6.2</span> Nonlinear optimization</a>
  <ul class="collapse">
  <li><a href="#univariate-function-1" id="toc-univariate-function-1" class="nav-link" data-scroll-target="#univariate-function-1"><span class="header-section-number">6.2.1</span> Univariate function</a></li>
  <li><a href="#multivariate-function" id="toc-multivariate-function" class="nav-link" data-scroll-target="#multivariate-function"><span class="header-section-number">6.2.2</span> Multivariate function</a></li>
  <li><a href="#constrained-optimization" id="toc-constrained-optimization" class="nav-link" data-scroll-target="#constrained-optimization"><span class="header-section-number">6.2.3</span> Constrained optimization</a></li>
  <li><a href="#remarks" id="toc-remarks" class="nav-link" data-scroll-target="#remarks"><span class="header-section-number">6.2.4</span> Remarks</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-nonlinear" class="quarto-section-identifier"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Nonlinear algebra and optimization</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><link rel="preconnect" href="https://fonts.googleapis.com"> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""> <link href="https://fonts.googleapis.com/css2?family=Fira+Mono&amp;family=Fira+Sans&amp;display=swap" rel="stylesheet"></p>
<p>In this chapter we will see functions for solving systems of nonlinear equations and how to optimize a nonlinear function.</p>
<p>For equation solving, the main goal is to compute an <span class="math inline">x \in \mathbb{R}^n</span> that satisfies the system <span class="math display">
\left\{\begin{array}{c}
f_0(x) = 0\\
f_1(x) = 0\\
\vdots \\
f_{n-1}(x) = 0
\end{array}\right.
</span> where <span class="math inline">f_0,\dots,f_{n-1} : \mathbb{R}^n \rightarrow \mathbb{R}</span> are continuous, <span class="math inline">n</span>-variate functions. That is, we have a systems of <span class="math inline">n</span> equations and <span class="math inline">n</span> variables. We will also see the least squares method for problems in which the number of equations is not equal to the number of variables (i.e., the sytem is under- or overdetermined).</p>
<p>For optimizing a function, we have a single continuous, <span class="math inline">n</span>-variate function <span class="math inline">f : \mathbb{R}^n \rightarrow \mathbb{R}</span>, and the goal is to compute an <span class="math inline">x \in \mathbb{R}^n</span>, that attains <span class="math display">
\min_{x \in \mathbb{R}^n} f(x).
</span></p>
<p>When there is only one (nonlinear) equation in one variable, we will also see ways to specify the interval in which the solution to the respective problems should be searched for.</p>
<p>The Python package <a href="https://lectures.scientific-python.org/">SciPy</a> contains all the functions we will need to achieve these goals, in particular, the <code>optimize</code> submodule. We import it under the alias <code>optimize</code> for convenience, and also import NumPy.</p>
<div id="164a27d5" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.optimize <span class="im">as</span> optimize</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="root-finding" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="root-finding"><span class="header-section-number">6.1</span> Root finding</h2>
<p>In this section we will discuss various root finding methods. We start by introducing various methods for finding the root of a univariate funtion, and then show similar methods for the multivariate case. We end with the least squares method, that finds an approximately optimal solution when a solution might not exist.</p>
<section id="univariate-function" class="level3" data-number="6.1.1">
<h3 data-number="6.1.1" class="anchored" data-anchor-id="univariate-function"><span class="header-section-number">6.1.1</span> Univariate function</h3>
<p>We present three type of methods and information that can be used to find roots of a function. We emphasize that none of these methods guarantee that a root will always be found if it exists, but in many cases they do.</p>
<section id="using-fsolve" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="using-fsolve"><b>Using <code>fsolve()</code></b></h4>
<p>The easiest-to-use function for finding the root of a univariate function <span class="math inline">f : \mathbb{R} \rightarrow \mathbb{R}</span> is <code>fsolve()</code> from the <code>optimize</code> module. It takes two mandatory input arguments:</p>
<ul>
<li>The function we want to find the root of, and</li>
<li>an initial guess for the root.</li>
</ul>
<p>As an example, suppose we want to find the root of the equation <span class="math display">
f(x) = x^2 + 2\cdot x - 1,
</span> that is plotted below. You do not have to look at the code generating this figure (but it is included for completeness).</p>
<style>
.cell-output-display {
  background-color: #ffffff;
}
</style>
<div id="1754c5fa" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Show code generating the plot below</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the x range</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">600</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the function f</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>x <span class="op">-</span><span class="dv">1</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the plot</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>plt.plot(x, f(x), label<span class="op">=</span><span class="st">'$f(x) = x^2 + 2x - 1$'</span>)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Add labels and title</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Plot of the function f on the interval [-3,3]'</span>)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'x'</span>)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'f(x)'</span>)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Add a grid</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Set range</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="op">-</span><span class="dv">3</span>,<span class="dv">3</span>)</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="op">-</span><span class="dv">4</span>,<span class="dv">14</span>)</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Add a legend</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Show the plot</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="06-nonlinear_files/figure-html/cell-3-output-1.png" class="quarto-figure quarto-figure-center figure-img" width="517" height="376"></p>
</figure>
</div>
</div>
</div>
<p><br></p>
<p>Our initial guess will be <code>guess = 3</code>. There are various ways in which you can input the function and initial guess. Either as</p>
<ul>
<li><b>Keyword arguments</b>: Use <code>func</code> for the function and <code>x0</code> for the initial guess.</li>
<li><b>Positional arguments</b>: Input function followed by initial guess, without keywords.</li>
</ul>
<div id="c49053f4" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>x <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>guess <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>x_root <span class="op">=</span> optimize.fsolve(f,x0<span class="op">=</span>guess) </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Also works:</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co"># x_root = optimize.fsolve(func=f,x0=guess) </span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co"># x_root = optimize.fsolve(x0=guess, func=f) </span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co"># x_root = optimize.fsolve(f,guess), here the order matters!</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Does not work</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co"># x_root = optimize.fsolve(x0=guess,f), f is positional, order matters!</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="co"># x_root = optimize.fsolve(guess,f), order matters!</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"A root of the function f is given by"</span>, x_root)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="co"># x_root is an array one one element; </span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="co"># can access index 0 to only get value</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"A root of the function f is given by"</span>, x_root[<span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>A root of the function f is given by [0.41421356]
A root of the function f is given by 0.41421356237309503</code></pre>
</div>
</div>
<p>For any function, in SciPy and beyond, you should look at the order of the required arguments of a function in its documentation.</p>
<blockquote class="blockquote">
<p>Because different root finding and optimization methods use a different keyword argument for the function of interest (e.g., <code>func</code>, <code>fun</code>, <code>f</code>), we will introduce the convention in this chapter that the first input argument of any SciPy function that we use is the function we want to find the root of, or optimize over, and all other input arguments will have a keyword (such as <code>x0</code>). The order of the keyword input arguments is not relevant, as long as they come after the function, which is the first input argument.</p>
</blockquote>
<p>The choice of initial guess can determine which root we end up in. The function <span class="math inline">f</span> has two roots as can be seen from the figure. If we start with another initial guess, such as <code>guess=4</code>, we find the other root of <span class="math inline">f</span>.</p>
<div id="c6603bea" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>x <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>guess <span class="op">=</span> <span class="op">-</span><span class="dv">4</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>x_root <span class="op">=</span> optimize.fsolve(f,x0<span class="op">=</span>guess) </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Another root of the function f is given by"</span>, x_root)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Another root of the function f is given by [-2.41421356]</code></pre>
</div>
</div>
<p>If the function <span class="math inline">f</span> would have had multiple input arguments, than <code>fsolve()</code> interprets the first argument of <span class="math inline">f</span> as being the unknown variable that it needs to compute. Any remaining arguments of <span class="math inline">f</span> should be specified in the <code>args</code> keyword argument.</p>
<p>For example, suppose that we would have defined <span class="math inline">g(x,a,b,c) = a\cdot x^2 + b\cdot x + c</span>. Then executing <code>x_root = optimize.fsolve(g,x0=guess)</code> will result in an error because <code>fsolve()</code> cannot determine a root <span class="math inline">x</span> if it does not know the values of <span class="math inline">a,b</span> and <span class="math inline">c</span>. Therefore, we need to specify these additional inputs in the <code>args</code> keyword argument of <code>fsolve()</code>.</p>
<div id="9512cf1d" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> g(x,a,b,c):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a<span class="op">*</span>x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> b<span class="op">*</span>x <span class="op">+</span> c</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>a, b, c <span class="op">=</span> <span class="dv">1</span>, <span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>guess <span class="op">=</span> <span class="op">-</span><span class="dv">4</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>x_root <span class="op">=</span> optimize.fsolve(g,x0<span class="op">=</span>guess,args<span class="op">=</span>(a,b,c))</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"A root of the function g is given by"</span>, x_root)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>A root of the function g is given by [-2.41421356]</code></pre>
</div>
</div>
<p>We could have also stored the parameters <span class="math inline">a,b,c</span> in an array so that <span class="math inline">g</span> would have only had one additional input argument. This is illustrated below.</p>
<div id="c4f50ef3" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> g(x,coeff):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> coeff[<span class="dv">0</span>]<span class="op">*</span>x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> coeff[<span class="dv">1</span>]<span class="op">*</span>x <span class="op">+</span> coeff[<span class="dv">2</span>]</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>coeff <span class="op">=</span> np.array([<span class="dv">1</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>guess <span class="op">=</span> <span class="op">-</span><span class="dv">4</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>x_root <span class="op">=</span> optimize.fsolve(g, x0<span class="op">=</span>guess, args<span class="op">=</span>(coeff))</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"A root of the function g is given by"</span>, x_root)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>A root of the function g is given by [-2.41421356]</code></pre>
</div>
</div>
<!--
We emphasize that the order of the input arguments is important here. The function and the initial guess are <i>positional arguments</i> meaning that `fsolve()` expects them to be the first and second input argument, respectively. Keyword arguments, like `args`, always come after the positional arguments, but can occur in any order.
-->
</section>
<section id="bracket-information" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="bracket-information"><b>Bracket information</b></h4>
<p>Another function that can find the root of a univariate function is <code>root_scalar()</code> from the <code>optimize</code> module.</p>
<p>Whereas <code>fsolve()</code> uses one fixed method in the background to find a root, <code>root_scalar()</code> allows the user to choose from a collection of methods. Some methods might perform better than others, depending on the type of function you are trying to find a root of. You can specify which method you want to use with the <code>method</code> keyword argument. Some methods require additional keyword arguments to be specified; see the <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.root_scalar.html">documentation</a>.</p>
<p>One such additional keyword argument is <code>bracket</code>, that allows you to specify the interval, or bracket, <span class="math inline">[a,b]</span> in which the root should be searched for. This does, however, come with the requirement that the function values in the points <span class="math inline">a</span> and <span class="math inline">b</span> should have a different sign: Either <span class="math inline">f(a) &lt; 0 &lt; f(b)</span> or <span class="math inline">f(b) &lt; 0 &lt; f(a)</span>. The reason is that this guarantees, by the <a href="https://en.wikipedia.org/wiki/Intermediate_value_theorem">Intermediate Value Theorem</a>, that there is at least one root in the interval <span class="math inline">[a,b]</span>. If the bracket does not satisfy this condition, then Python will raise an error (try this yourself).</p>
<p>Let us look at an example where we use the <a href="https://en.wikipedia.org/wiki/Bisection_method">Bisection method</a>, called <code>'bisect'</code> in SciPy, with interval <span class="math inline">[0,4]</span>. The order in which you place the keyword argument <code>bracket</code> and <code>method</code> does not matter.</p>
<div id="f75545d2" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>x <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>interval <span class="op">=</span> [<span class="dv">0</span>,<span class="dv">4</span>]</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> optimize.root_scalar(f, bracket<span class="op">=</span>interval, method<span class="op">=</span><span class="st">'bisect'</span>) </span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      converged: True
           flag: 'converged'
 function_calls: 43
     iterations: 41
           root: 0.41421356237151485</code></pre>
</div>
</div>
<p>Note that Python returns a lot of information regarding the root finding process. For example, it tells us whether the process has converged, meaning it found a point that satisfies <span class="math inline">f(x) = 0</span> up to a default precision. You can access these properties with the syntax <code>result.property_name</code> where <code>property_name</code> is the property of interest.</p>
<div id="ca894766" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The root finding process converged:"</span>, result.converged)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The root finding process converged: True</code></pre>
</div>
</div>
<p>For us, the most important property is <code>root</code>, which gives the value of the root.</p>
<div id="1aaca2cc" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"A root of the function f is given by"</span>, result.root)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>A root of the function f is given by 0.41421356237151485</code></pre>
</div>
</div>
</section>
<section id="derivative-information" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="derivative-information"><b>Derivative information</b></h4>
<p>If a function is differentiable, it is also possible to specify its derivative in some methods. This typically results in much faster root finding methods.</p>
<p>Recall, for example, Newton’s method from Section <a href="02-good-coding.html#sec-newton-method" class="quarto-xref"><span>Section 2.4</span></a> that finds a root by iteratively computing better approximations using the formula <span class="math display">
x_{i+1} = x_i - \frac{f(x_i)}{f'(x_i)}
</span> starting from some initial guess <span class="math inline">x_0</span>. The formula to compute the next iterate relies on</p>
<ul>
<li>The derivative <span class="math inline">f'(x)</span>, and</li>
<li>an initial guess <span class="math inline">x_0</span>.</li>
</ul>
<p>Let us look at an example of using Newton’s method. The derivative <span class="math inline">f'</span> should be defined as a function and can be entered in the <code>fprime</code> keyword argument. The initial guess is inputted in the <code>x0</code> keyword argument.</p>
<p>For our function <span class="math inline">f(x) = x^2 + 2x - 1</span> we have <span class="math inline">f'(x) = 2(x+1)</span>.</p>
<div id="23ef86c8" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>x <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f_deriv(x):</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">2</span><span class="op">*</span>(x<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>guess <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> optimize.root_scalar(f,  method<span class="op">=</span><span class="st">'newton'</span>, <span class="op">\</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>                                fprime<span class="op">=</span>f_deriv, x0 <span class="op">=</span> guess) </span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      converged: True
           flag: 'converged'
 function_calls: 14
     iterations: 7
           root: 0.41421356237309503</code></pre>
</div>
</div>
<p>Although it is a little bit like comparing apples and pears, the number of function calls and iterations (determining how long a method needs to converge) of Newton’s method is much lower than that of the Bisection method.</p>
<p>Finally, we remark that the <code>args</code> keyword argument to specify additional input parameters can also be used in combination with methods that use bracket or derivative information.</p>
</section>
</section>
<section id="multivariate-functions" class="level3" data-number="6.1.2">
<h3 data-number="6.1.2" class="anchored" data-anchor-id="multivariate-functions"><span class="header-section-number">6.1.2</span> Multivariate functions</h3>
<section id="using-fsolve-1" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="using-fsolve-1"><b>Using <code>fsolve()</code></b></h4>
<p>The <code>fsolve()</code> function can also be used to compute a root of a system of <span class="math inline">n</span> functions with <span class="math inline">n</span> unknown variables. It again takes two input arguments:</p>
<ul>
<li>The system of function equations to be solved, and</li>
<li>an initial guess for the (unknown) root.</li>
</ul>
<p>The system of equations should be modelled as a Python function, i.e., we need a function that takes as input an array <span class="math inline">x = [x_0,\dots,x_{n-1}]</span> and outputs the array <span class="math inline">f(x) = [f_{0}(x),\dots,f_{n-1}(x)]</span>. This function will then be the input for <code>fsolve()</code>.</p>
<p>As an example for <span class="math inline">n = 2</span>, suppose we want to solve the system</p>
<p><span class="math display">
\left\{\begin{array}{rll}
x_0^2 + x_1^2 &amp;=&amp; 4 \\
x_0 + x_1 &amp;=&amp; 1 \\
\end{array}\right..
</span></p>
<p>That is, we have <span class="math inline">f_0(x_0,x_1) = x_0^2 + x_1^2 -4</span> and <span class="math inline">f_1(x_0,x_1) = x_0 + x_1  - 1</span>, and want to solve <span class="math inline">f_0(x) = 0, f_1(x) = 0</span>. The array <span class="math inline">[f_0(x),f_1(x)]</span> can be defined as a function in the following way.</p>
<div id="6e405a60" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Input  : Array x = [x_0, x_1]</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Output : Array f = [f_0(x), f_1(x)]</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    f <span class="op">=</span> np.array([x[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">4</span>, x[<span class="dv">0</span>] <span class="op">+</span> x[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>]) </span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> f</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We emphasize that here the array <span class="math inline">x = [x_0,x_1]</span> is the input of the function, and not <span class="math inline">x_0</span> and <span class="math inline">x_1</span> separately. If we would define <span class="math inline">f</span> as a function of two inputs, i.e., <code>f(x_0,x_1)</code>, then <code>fsolve()</code> would want to find a root with respect to its first argument <code>x_0</code> only, which is not what we want.</p>
<p>Using <code>fsolve()</code> to do the root finding gives us the following solution.</p>
<div id="22f68901" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>guess <span class="op">=</span> np.array([<span class="dv">1</span>,<span class="dv">1</span>]) <span class="co"># Our initial guess</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>root <span class="op">=</span> optimize.fsolve(f, x0<span class="op">=</span>guess)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(root)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[ 1.82287566 -0.82287566]</code></pre>
</div>
</div>
<p>Note that the initial guess is an array in <span class="math inline">\mathbb{R}^2</span> this time, as we are considering a function with two variables.</p>
<p>Also here we can use the <code>args</code> keyword argument to specify additional input parameters. Suppose we want to solve, for <span class="math inline">a = 2</span> and <span class="math inline">b = 4</span>, the system</p>
<p><span class="math display">
\left\{\begin{array}{rll}
a\cdot x_0^2 + x_1^2 &amp;=&amp; 4 \\
x_0 + b\cdot x_1 &amp;=&amp; 1 \\
\end{array}\right..
</span></p>
<div id="d810d365" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x,a,b):</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([a<span class="op">*</span>x[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">4</span>, x[<span class="dv">0</span>] <span class="op">+</span> b<span class="op">*</span>x[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>]) </span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>guess <span class="op">=</span> np.array([<span class="dv">1</span>,<span class="dv">1</span>]) <span class="co"># Our initial guess</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>a, b <span class="op">=</span> <span class="dv">2</span>, <span class="dv">4</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>x_root <span class="op">=</span> optimize.fsolve(f, x0<span class="op">=</span>guess, args<span class="op">=</span>(a,b))</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(x_root)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[ 1.41233385 -0.10308346]</code></pre>
</div>
</div>
<p>You can double-check that the root <span class="math inline">x^*</span> you found is indeed a root by plugging the solution into the system of equations, i.e., checking if it satisfies <span class="math display">
f(x^*) = [f_0(x^*), \dots,  f_{n-1}(x^*)] = [0,\dots,0].
</span></p>
<div id="262b00e3" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(f(x_root,a,b)) <span class="co"># Both coordinates approximately equal to zero</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[9.59232693e-14 0.00000000e+00]</code></pre>
</div>
</div>
</section>
<section id="derivative-information-1" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="derivative-information-1"><b>Derivative information</b></h4>
<p>Just as in the univariate case, it is also possible to use other function for finding a root. The analogue of <code>root_scalar()</code> is the function <code>root()</code>. Although it is not possible to input bracket information for this function, it does have methods that use derivate information. These methods are typically faster than <code>fsolve()</code>.</p>
<p>Consider again the system</p>
<p><span class="math display">
\left\{\begin{array}{rll}
x_0^2 + x_1^2 - 4 &amp;=&amp; 0 \\
x_0 + x_1 -1 &amp;=&amp; 0 \\
\end{array}\right..
</span></p>
<p>The “derivative” of the function <span class="math inline">f : \mathbb{R}^n \rightarrow \mathbb{R}^n</span> given by <span class="math inline">f(x) = [f_0(x),\dots,f_{n-1}(x)]</span> is the Jacobian matrix</p>
<p><span class="math display">
J(f) =
\frac{\partial (f_0, \cdots,f_{n-1})}{\partial (x_0,\cdots,x_{n-1})} =
\begin{bmatrix}
\frac{\partial f_0}{\partial x_0} &amp; \frac{\partial f_0}{\partial x_1} &amp; \cdots &amp; \frac{\partial f_0}{\partial x_n} \\[1ex]
\frac{\partial f_1}{\partial x_1} &amp; \frac{\partial f_1}{\partial x_1} &amp; \cdots &amp; \frac{\partial f_1}{\partial x_{n-1}} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots                          \\
\frac{\partial f_{n-1}}{\partial x_0} &amp; \frac{\partial f_{n-1}}{\partial x_1} &amp; \cdots &amp; \frac{\partial f_{n-1}}{\partial x_{n-1}}
\end{bmatrix}.
</span></p>
<p>For the two equations at hand, we have</p>
<p><span class="math display">
J(f) = \begin{bmatrix} 2x_0 &amp; 2x_1\\ 1 &amp; 1\end{bmatrix}.
</span></p>
<p>Just as in the univariate case when using Newton’s method, we need to input an initial guess and the Jacobian matrix, where the latter should be defined as a function. The Jacobian is inputted in the <code>jac</code> keyword argument; the initial guess in <code>x0</code>.</p>
<div id="687f957b" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):    </span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([x[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">4</span>, x[<span class="dv">0</span>] <span class="op">+</span> x[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>]) </span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> jac_f(x):</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    J <span class="op">=</span> np.array([[<span class="dv">2</span><span class="op">*</span>x[<span class="dv">0</span>], <span class="dv">2</span><span class="op">*</span>x[<span class="dv">1</span>]],[<span class="dv">1</span>,<span class="dv">1</span>]])</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> J</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>guess <span class="op">=</span> np.array([<span class="dv">1</span>,<span class="dv">1</span>]) <span class="co"># Our initial guess</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> optimize.root(f, jac<span class="op">=</span>jac_f,x0<span class="op">=</span>guess)</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> message: The solution converged.
 success: True
  status: 1
     fun: [ 0.000e+00  0.000e+00]
       x: [ 1.823e+00 -8.229e-01]
    nfev: 27
    njev: 2
    fjac: [[-9.745e-01 -2.243e-01]
           [-2.243e-01  9.745e-01]]
       r: [-4.458e+00  6.983e-01  1.187e+00]
     qtf: [ 1.848e-10  4.255e-11]</code></pre>
</div>
</div>
<p>We can access the properties of the result of the root finding procedure with the syntax <code>result.property_name</code> where <code>property_name</code> is the property of interest. Here the root is given by the property <code>x</code>.</p>
<div id="9d3c693f" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"A root of the function f is given by"</span>, result.x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>A root of the function f is given by [ 1.82287566 -0.82287566]</code></pre>
</div>
</div>
<p>Note that this is the same root that we found with <code>fsolve()</code>.</p>
</section>
</section>
<section id="least-squares-method" class="level3" data-number="6.1.3">
<h3 data-number="6.1.3" class="anchored" data-anchor-id="least-squares-method"><span class="header-section-number">6.1.3</span> Least squares method</h3>
<p>If the number of functions is not equal to the number of variables, or if the system does not have a solution, the least squares method <code>optimize.least_squares</code> is your best pick to find a root.</p>
<p>The function (when using the default settings) tries to compute a point <span class="math inline">x</span> that attains the minimum of the <i>residual function</i> <span class="math display">
R(f_0,\dots,f_{n-1}) = \min_{x \in \mathbb{R}^n}  \sum_{i=1}^{n-1} f_i(x)^2,
</span> It should be observed that <span class="math inline">R(f_0,\dots,f_{n-1})  \geq 0</span> and <span class="math inline">R(f_0,\dots,f_{n-1}) = 0</span> if and only if the system <span class="math inline">f_0(x) = 0,\dots, f_{n-1}(x)=0</span> has a root.</p>
<p>The function <code>optimize.least_squares</code> takes just like <code>fsolve()</code> two input arguments: The system of equations and an initial guess.</p>
<p>Let’s look at an example. Consider the system <span class="math display">
\left\{
\begin{array}{lllll}
f_0(x)&amp; =&amp; \sin(x) &amp;=&amp; 0 \\
f_1(x)&amp; =&amp; (x - \pi + 0.1)^2 &amp;=&amp; 0 \\
f_2(x)&amp; =&amp; (x - \pi) &amp;=&amp; 0
\end{array}\right..
</span> Without the <span class="math inline">0.1</span>-term, this system would have the unique solution <span class="math inline">x = \pi</span>, but this small perturbation causes it to become infeasible. We can still find an approximately optimal solution with the least squares method. The number <span class="math inline">\pi</span> can be accessed in NumPy using <code>np.pi</code>.</p>
<div id="673a923e" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> system(x):</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([np.sin(x[<span class="dv">0</span>]), (x[<span class="dv">0</span>]<span class="op">-</span>np.pi <span class="op">+</span> <span class="fl">0.1</span>)<span class="op">**</span><span class="dv">2</span>, x[<span class="dv">0</span>] <span class="op">-</span> np.pi])</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>guess <span class="op">=</span> <span class="dv">1</span>    </span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> optimize.least_squares(system,x0<span class="op">=</span>guess)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Least squares solution found is x = "</span>, result.x) <span class="co"># Close to pi</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Least squares solution found is x =  [3.1406215]</code></pre>
</div>
</div>
<p>Although <code>optimize.least_squares</code> often works well, it does not necessarily compute a root of the function even if one exists. What it actually does, is compute a local minimum of the residual function.</p>
<p>Let us illustrate this with an example. Consider the function <span class="math inline">f(x) = x^4 + 0.3x^3 - 2.5x^2 + 1.5</span>, which has two (real) roots as can be seen from the figure below.</p>
<style>
.cell-output-display {
  background-color: #ffffff;
}
</style>
<div id="86ed2da1" class="cell" data-execution_count="18">
<details class="code-fold">
<summary>Show code generating the plot below</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the x range</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">600</span>)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the function f</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">**</span><span class="dv">4</span> <span class="op">+</span> <span class="fl">0.3</span><span class="op">*</span>x<span class="op">**</span><span class="dv">3</span> <span class="op">-</span> <span class="fl">2.5</span><span class="op">*</span>x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="fl">1.5</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the plot</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>plt.plot(x, f(x), label<span class="op">=</span><span class="st">'$f(x) = x^4 + 0.3x^3 - 2.5x^2 + 1.5$'</span>)</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Add labels and title</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Plot of the function f on the interval [-2,2]'</span>)</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'x'</span>)</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'f(x)'</span>)</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Add a grid</span></span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Set range</span></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="op">-</span><span class="dv">1</span>,<span class="dv">3</span>)</span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Add a legend</span></span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Show the plot</span></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="06-nonlinear_files/figure-html/cell-19-output-1.png" class="quarto-figure quarto-figure-center figure-img" width="536" height="376"></p>
</figure>
</div>
</div>
</div>
<p><br></p>
<p>We execute both Newton’s and the least squares method with the same initial guess.</p>
<div id="8fed14ed" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Function f</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (x<span class="op">**</span><span class="dv">4</span> <span class="op">+</span> <span class="fl">0.3</span><span class="op">*</span>x<span class="op">**</span><span class="dv">3</span> <span class="op">-</span> <span class="fl">2.5</span><span class="op">*</span>x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="fl">1.5</span>)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Derivative of f    </span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f_deriv(x):</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">4</span><span class="op">*</span>x<span class="op">**</span><span class="dv">3</span> <span class="op">+</span> <span class="fl">0.9</span><span class="op">*</span>x<span class="op">**</span><span class="dv">2</span> <span class="op">-</span><span class="dv">5</span><span class="op">*</span>x</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>guess <span class="op">=</span> <span class="fl">1.5</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Newton's method</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> optimize.root_scalar(f,  method<span class="op">=</span><span class="st">'newton'</span>, <span class="op">\</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>                                fprime<span class="op">=</span>f_deriv, x0 <span class="op">=</span> guess) </span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Root found by Newton's method: </span><span class="ch">\n</span><span class="st"> x ="</span>, result.root,  </span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>        <span class="ss">f"with f(x) ="</span>, f(result.root))</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Least squares method</span></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>result_ls <span class="op">=</span> optimize.least_squares(f, x0<span class="op">=</span>guess) </span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Root found by least squares method: </span><span class="ch">\n</span><span class="st"> x ="</span>, result_ls.x,  </span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>        <span class="ss">f"with f(x) ="</span>, f(result_ls.x))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Root found by Newton's method: 
 x = -1.5180670079327394 with f(x) = -8.881784197001252e-16
Root found by least squares method: 
 x = [1.01118148] with f(x) = [0.29943799]</code></pre>
</div>
</div>
<p>As you can see, the least squares method does not find a root, because the function value in the computed point is almost <span class="math inline">0.3</span>. What goes wrong here? Consider the residual problem <span class="math display">
R(f) = \min_x (x^4 + 0.3x^3 - 2.5x^2 + 1.5)^2.
</span></p>
<p>The function <span class="math inline">g(x) = f(x)^2 = (x^4 + 0.3x^3 - 2.5x^2 + 1.5)^2</span> is plotted below. As you can see, it has a local minimum around <span class="math inline">1</span>. Because we started out with the initial guess <span class="math inline">1.5</span>, the least squares method gets stuck in this local minimum.</p>
<style>
.cell-output-display {
  background-color: #ffffff;
}
</style>
<div id="b8f17e95" class="cell" data-execution_count="20">
<details class="code-fold">
<summary>Show code generating the plot below</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the x range</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">600</span>)</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the function f</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (x<span class="op">**</span><span class="dv">4</span> <span class="op">+</span> <span class="fl">0.3</span><span class="op">*</span>x<span class="op">**</span><span class="dv">3</span> <span class="op">-</span> <span class="fl">2.5</span><span class="op">*</span>x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="fl">1.5</span>)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the plot</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>plt.plot(x, f(x), label<span class="op">=</span><span class="st">'$f(x)^2 = (x^4 + 0.3x^3 - 2.5x^2 + 1.5)^2$'</span>)</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Add labels and title</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Plot of the function f on the interval [-2,2]'</span>)</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'x'</span>)</span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'f(x)'</span>)</span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Add a grid</span></span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Set range</span></span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="op">-</span><span class="dv">1</span>,<span class="dv">3</span>)</span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Add a legend</span></span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Show the plot</span></span>
<span id="cb35-31"><a href="#cb35-31" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="06-nonlinear_files/figure-html/cell-21-output-1.png" class="quarto-figure quarto-figure-center figure-img" width="536" height="376"></p>
</figure>
</div>
</div>
</div>
<p><br> To close this section, we again emphasize that no method is guaranteed to always find a root for every function. For example, <code>fsolve()</code> is also not able to find a root of the function <span class="math inline">f</span> in this section (try this yourself).</p>
<!--

::: {#296a8b0c .cell execution_count=21}
``` {.python .cell-code}
# Function f
def f(x):
    return (x**4 + 0.3*x**3 - 2.5*x**2 + 1.5)

# Derivative of f    
def f_deriv(x):
    return 4*x**3 + 0.9*x**2 -5*x

guess = 1.5

# fsolve()
result = optimize.fsolve(f, x0 = guess) 
print("Root found by fsolve(): \n x =", result,  
        f"with f(x) =", f(result))
```

::: {.cell-output .cell-output-stdout}
```
Root found by fsolve(): 
 x = [1.01135492] with f(x) = [0.29943813]
```
:::

::: {.cell-output .cell-output-stderr}
```
C:\Users\pskleer\AppData\Local\anaconda3\lib\site-packages\scipy\optimize\_minpack_py.py:178: RuntimeWarning:

The iteration is not making good progress, as measured by the 
  improvement from the last five Jacobian evaluations.

```
:::
:::


-->
<p>Therefore, always check whether a found solution is actually a root by evaluating the function in the solution found and checking if the resulting value is (almost) zero.</p>
</section>
</section>
<section id="nonlinear-optimization" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="nonlinear-optimization"><span class="header-section-number">6.2</span> Nonlinear optimization</h2>
<p>In this section we consider the minimization problem <span class="math display">
\min_{x \in \mathbb{R}^n} f(x).
</span> for a function <span class="math inline">f : \mathbb{R}^n \rightarrow \mathbb{R}</span>. Note that maximization can be done by considering the function <span class="math inline">-f</span>.</p>
<p>We again start with univariate functions and then switch to multivariate functions later on. In the last section we will also see some examples of constrained optimization, where the domain of <span class="math inline">f</span> is a subset of <span class="math inline">\mathbb{R}^n</span>. The syntax for using minimization functions from SciPy will be similar to the syntax we saw for root finding methods.</p>
<p>In particular, also here we can use the <code>args</code> keyword argument to specify any additional input arguments of the function we want to minimize over, so that the optimization can happen with respect to the unknown first input argument of the function.</p>
<section id="univariate-function-1" class="level3" data-number="6.2.1">
<h3 data-number="6.2.1" class="anchored" data-anchor-id="univariate-function-1"><span class="header-section-number">6.2.1</span> Univariate function</h3>
<p>If <span class="math inline">f : \mathbb{R} \rightarrow \mathbb{R}</span> is a univariate function then the easiest-to-use functions for minimization are <code>fmin()</code> and <code>minimize_scalar()</code> from the <code>optimize</code> module. We emphasize that these functions find a local minimum of the function <span class="math inline">f</span>, which might or might not be a global minimum.</p>
<p>The function <code>fmin()</code> works similar as <code>fsolve()</code> in that it requires an initial guess.</p>
<div id="e1d78f10" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">**</span><span class="dv">4</span> <span class="op">+</span> <span class="fl">0.3</span><span class="op">*</span>x<span class="op">**</span><span class="dv">3</span> <span class="op">-</span> <span class="fl">2.5</span><span class="op">*</span>x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="fl">1.5</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>guess<span class="op">=</span><span class="fl">1.5</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>x_min <span class="op">=</span> optimize.fmin(f,x0<span class="op">=</span>guess)</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The minimum found is x ="</span>, x_min) <span class="co"># Local minimum</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Optimization terminated successfully.
         Current function value: 0.299438
         Iterations: 15
         Function evaluations: 30
The minimum found is x = [1.01118164]</code></pre>
</div>
</div>
<p>With a different initial guess the method is able to find the global minimum; see the figure in the previous section. Furthermore, you can suppress the output message of <code>fmin()</code> by setting the keyword argument <code>disp=False</code>; see the <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fmin.html">documentation</a> of <code>fmin()</code>.</p>
<div id="041ab386" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>guess<span class="op">=-</span><span class="fl">1.5</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>x_min <span class="op">=</span> optimize.fmin(f,x0<span class="op">=</span>guess,disp<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The minimum found is x ="</span>, x_min) <span class="co"># Local minimum</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The minimum found is x = [-1.23618164]</code></pre>
</div>
</div>
<p>The function <code>minimize_scalar()</code> gives more flexibility in terms of input arguments. First of all, we can execute it without any additional arguments, but then it more easily gets stuck in a local minimum.</p>
<div id="7a55cf51" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> optimize.minimize_scalar(f)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="co"># We access root with result.x </span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The minimum found  is x ="</span>, result.x) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> message: 
          Optimization terminated successfully;
          The returned value satisfies the termination criteria
          (using xtol = 1.48e-08 )
 success: True
     fun: 0.29943799106751934
       x: 1.011179780213775
     nit: 11
    nfev: 14
The minimum found  is x = 1.011179780213775</code></pre>
</div>
</div>
<p>We can also set an interval in which we want to find a minimum using the <code>bounds</code> keyword argument. Note that in the example below, the function <code>minimize_scalar()</code> does not get stuck in the local minimum around <span class="math inline">1</span>.</p>
<div id="26130a91" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>interval <span class="op">=</span> [<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>]</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> optimize.minimize_scalar(f,bounds<span class="op">=</span>interval)</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The minimum found  is x ="</span>, result.x) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The minimum found  is x = -1.2361799028533706</code></pre>
</div>
</div>
<p>For more options and different methods that can be used with the <code>method</code> keyword argument, see the <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize_scalar.html">documentation</a> of <code>minimize_scalar</code>.</p>
</section>
<section id="multivariate-function" class="level3" data-number="6.2.2">
<h3 data-number="6.2.2" class="anchored" data-anchor-id="multivariate-function"><span class="header-section-number">6.2.2</span> Multivariate function</h3>
<p>For multivariate functions, we can use the <code>minimize()</code> function from <code>optimize</code>, being the analogue of <code>root()</code> for root finding. This function can take into account derivative, or gradient, information with certain methods. The gradient of <span class="math inline">f</span> is given by <span class="math display">
\nabla f(x) = \left[\frac{\partial f}{\partial x_0}, \dots, \frac{\partial f}{\partial x_{n-1}} \right].
</span> We can input the gradient again with the keyword argument <code>jac</code>. The default method that <code>minimize()</code> uses is <code>'BFGS'</code> and this method can use gradient information. You can choose your own method with the <code>method</code> keyword argument; see the <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">documentation</a>.</p>
<div id="90dc172c" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the function</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (x[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">3</span>)<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> (x[<span class="dv">1</span>] <span class="op">+</span> <span class="dv">4</span>)<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the gradient</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> grad_f(x):</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([<span class="dv">2</span> <span class="op">*</span> (x[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">3</span>), <span class="dv">2</span> <span class="op">*</span> (x[<span class="dv">1</span>] <span class="op">+</span> <span class="dv">4</span>)])</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial guess</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>guess <span class="op">=</span> np.array([<span class="fl">0.0</span>, <span class="fl">0.0</span>])</span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Minimization with gradient information</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> optimize.minimize(f, x0<span class="op">=</span>guess, jac<span class="op">=</span>grad_f)</span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the result</span></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The minimum found is:"</span>, result.x)</span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Function value at minimum:"</span>, result.fun)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The minimum found is: [ 3. -4.]
Function value at minimum: -1.0</code></pre>
</div>
</div>
</section>
<section id="constrained-optimization" class="level3" data-number="6.2.3">
<h3 data-number="6.2.3" class="anchored" data-anchor-id="constrained-optimization"><span class="header-section-number">6.2.3</span> Constrained optimization</h3>
<p>Just as with <code>minimize_scalar()</code> the function <code>minimize()</code> can also include interval information using the <code>bounds</code> keyword argument. The syntax for this argument is a list of tuples that for every variable in <span class="math inline">x = [x_0,\dots,x_{n-1}]</span> contains the lower and upper bound value for the variable. Recall that this is the same way how variable bounds were specified in the <code>linprog</code> package for solving (integer) linear optimization problems.</p>
<p>That is, if we have the constraints <span class="math inline">\ell_i \leq x_i \leq u_i</span> for <span class="math inline">i = 0,\dots,n-1</span>, then the input for <code>bounds</code> is <code>[(l_0, u_0), (l_1, u_1), ..., (l_{n-1},u_{n-1})]</code>. Just as in <code>linprog</code> you can set an upper or lower bound equal to <code>None</code> to model that the lower bound is <span class="math inline">-\infty</span>, or that the upper bound is <span class="math inline">+\infty</span>.</p>
<div id="f803e547" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the function</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (x[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">3</span>)<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> (x[<span class="dv">1</span>] <span class="op">+</span> <span class="dv">4</span>)<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the gradient</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> grad_f(x):</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array([<span class="dv">2</span> <span class="op">*</span> (x[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">3</span>), <span class="dv">2</span> <span class="op">*</span> (x[<span class="dv">1</span>] <span class="op">+</span> <span class="dv">4</span>)])</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial guess</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>guess <span class="op">=</span> np.array([<span class="fl">0.0</span>, <span class="fl">0.0</span>])</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>intervals <span class="op">=</span> [(<span class="va">None</span>,<span class="dv">2</span>), (<span class="op">-</span><span class="dv">2</span>,<span class="va">None</span>)] <span class="co"># x_0 &lt;= 2, x_1 &gt;= -2</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Minimization with gradient information</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> optimize.minimize(f, x0<span class="op">=</span>guess, bounds<span class="op">=</span>intervals)</span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the result</span></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The minimum found is:"</span>, result.x)</span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Function value at minimum:"</span>, result.fun)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The minimum found is: [ 2. -2.]
Function value at minimum: 4.0</code></pre>
</div>
</div>
<p>Next to specifying variable bounds, <code>minimize()</code> can also take into account more complex constraints that restrict the domain of <span class="math inline">f</span>, i.e., the search space of <code>minimize()</code>, using the <code>constraints</code> keyword argument.</p>
<p>That is, we can solve the problem</p>
<p><span class="math display">
\begin{array}{lll}
\min_{x \in \mathbb{R}^n} &amp; f(x)  &amp;\\
\text{s.t.} &amp; g_j(x) \geq 0 &amp;  \text{ for } j = 1,\dots,q-1\\
&amp; h_k(x) = 0 &amp; \text{ for } k = 0,\dots,r-1
\end{array}.
</span></p>
<p>The syntax for adding constraints is to use a tuple containing dictionaries, where each dictionary models a constraints with keys</p>
<ul>
<li><code>'type'</code>: Use <code>'ineq'</code> for a <span class="math inline">\geq</span>-constraint and <code>'eq'</code> for an <span class="math inline">=</span>- constraint;</li>
<li><code>'fun'</code> : Python function that describes <span class="math inline">g_j</span> or <span class="math inline">h_k</span>.</li>
</ul>
<p>There is also the optional keyword argument <code>'args'</code> that allows you to specify additional parameters that appear in the function <span class="math inline">g_j</span> or <span class="math inline">h_k</span>.</p>
<p>As an example, suppose we want to solve the problem</p>
<p><span class="math display">
\begin{array}{lll}
\min_{x \in \mathbb{R}^n} &amp; x_0^2 + 5x_1^2  &amp;\\
\text{s.t.} &amp; x_0 + x_1 \geq 5 &amp;  \\
&amp; x_0 - 2x_1 = 3 &amp;
\end{array}
</span></p>
<p>Then we have <span class="math inline">g_0(x) = x_0 + x_1 - 5</span> and <span class="math inline">h_0(x) = x_0 - 2x_1 - 3</span>.</p>
<div id="347da6a1" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define functions of constraints</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> g(x):</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x[<span class="dv">0</span>] <span class="op">+</span> x[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">5</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> h(x):</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>x[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">3</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Define tuple containing constraints as dictionaries</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>cons <span class="op">=</span> ({<span class="st">'type'</span> : <span class="st">'ineq'</span>, <span class="st">'fun'</span> : g}, </span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>        {<span class="st">'type'</span> : <span class="st">'eq'</span>, <span class="st">'fun'</span> : h})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let us now do the optimization using these constraints.</p>
<div id="c116a8e8" class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>guess <span class="op">=</span> np.array([<span class="dv">0</span>,<span class="dv">0</span>]) <span class="co"># minimize() always needs guess</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> optimize.minimize(f, x0<span class="op">=</span>guess, constraints<span class="op">=</span>cons)</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The minimum found is:"</span>, result.x)</span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Function value at minimum:"</span>, result.fun)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The minimum found is: [4.33333333 0.66666667]
Function value at minimum: 19.2222222222229</code></pre>
</div>
</div>
<p>This allows us, for example, to optimize a nonlinear function subject to linear constraints.</p>
</section>
<section id="remarks" class="level3" data-number="6.2.4">
<h3 data-number="6.2.4" class="anchored" data-anchor-id="remarks"><span class="header-section-number">6.2.4</span> Remarks</h3>
<p>Just as in the previous chapter, we remark here that there are various other packages in Python to perform optimization tasks with. For example, there is <code>cvxpy</code> for convex optimization, and you can also couple external solvers with Python, as explained in the last chapter.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/pskleer\.github\.io");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./05-linear.html" class="pagination-link" aria-label="Linear algebra and optimization">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Linear algebra and optimization</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./07-visualization.html" class="pagination-link" aria-label="Visualization">
        <span class="nav-page-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Visualization</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>