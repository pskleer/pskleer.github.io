[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computational Aspects in Econometrics - Python II module",
    "section": "",
    "text": "1 About",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "Computational Aspects in Econometrics - Python II module",
    "section": "1.1 Welcome",
    "text": "1.1 Welcome\nWelcome to the online “book” for the Python II module of Computational Aspects in Econometrics. We will follow the content in this book during the lectures and it is the basis of the material that will appear on the exam, so you should read through this book carefully. Because this book is new, it is likely that we will make some edits throughout the course.\nPlease not that this is an advanced Python module. We assume familiarity with the basics of programming in Python. For students enrolled in the bachelor Econometrics and Operations Research, the topics of the course Programming for EOR is a good example of what I expect you to be familiar with. An online book covering most of these topis can be found here. This book also contains some topics not covered in Programming for EOR.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "index.html#goal",
    "href": "index.html#goal",
    "title": "Computational Aspects in Econometrics - Python II module",
    "section": "1.2 Goal",
    "text": "1.2 Goal\nThe goal of this module is to teach you the basics of scientific computing with Python. Here you should think mostly of implementing algorithmic tasks that you encounter during your Econometrics and Operations Research courses, such as, linear algebra, optimization, statistics and machine learning. We hope that the skills you are taught here can be useful for, e.g., numerical work in your bachelor or (perhaps later) master thesis. Furthermore, many companies nowadays program in Python, so the topics of this module can also be useful in your professional career later in life.\nNext to teaching you how to implement certain mathematical task in a correct manner in Python, we also put emphasis on good coding practices. Especially if you start to write scripts with hundres of lines of code, it is important that you learn how to do this in a structured fasion using efficient Python functionality. Good coding practices are the topic of the next chapter. The idea is that you use these practices when doing the exercises corresponding to every lecture, as well as the group assignment.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "index.html#use-of-spyder",
    "href": "index.html#use-of-spyder",
    "title": "Computational Aspects in Econometrics - Python II module",
    "section": "1.3 Use of Spyder",
    "text": "1.3 Use of Spyder\nThis course document is based on the use of Spyder as integrated development environment (IDE) for creating Python code, i.e., the program that the code is written in. You can also use VS code or any other IDE to do the exercises and/or assignment in. Whenever this book contains screenshots to illustrate something, they will have been taken in Spyder.\nTo install the Anaconda distribution containing Spyder, follow the steps here. This is the installation that was alos recommended in the Python I module.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "02-good-coding.html",
    "href": "02-good-coding.html",
    "title": "2  Good coding practices",
    "section": "",
    "text": "2.1 Efficient computations\nPerhaps the most important topic of this course is that of efficient computation, i.e., to make efficient use of the mathematical functionality that Python has to offer, in particular the functionality of the NumPy package.\nThe way to think of this is as follows: Many of the mathematical tasks and exercises that we will see could, in theory, be solved using for- and/or while-loops, as well as if/else-statements. However, there are often more efficient functions programmed in the NumPy package in Python that can carry out these task in a quicker way using less code!\nLet us look at an example. Suppose I am given a vector x = [x_1,\\dots,x_n] \\in \\mathbb{R}^n, and I want to compute the L^2-norm \n||x||_2 = \\sqrt{\\sum_{i=1}^n x_i^2}\n of this vector. One way to solve this directly would be by using a for-loop to compute the sum inside the square root, and then take the square root of this number. We will illustrate this next for the vector x = [1,2,3,\\dots,300.000].\n# Length of vector\nn = 300000\n\n# Compute inner summation of ||x||_2\ninner_sum = 0\nfor i in range(1,n+1):\n    inner_sum = inner_sum + i**2\n\n# Take square root\ntwo_norm = (inner_sum)**(0.5)\n\n# Print value of two-norm\nprint(two_norm)\n\n94868566.97584295\nAnother way to do this is to define the vector x efficiently making use of the arange() function in Numpy, followed by the linalg.norm() function that can compute the L^2-norm for us directly. We will see these functions in more detail in a subsequent chapter.\nIt is standard convention to import the Numpy package under the alias np.\n#Import Numpy package under the alias np\nimport numpy as np\n\n# Length of vector\nn = 300000\n\n# Define vector x as array using arange() function\nx = np.arange(1,n+1)\n\n# Compute two-norm with built-in function\ntwo_norm = np.linalg.norm(x)\n\n# Print value of two-norm\nprint(two_norm)\n\n94868566.97584295\nThis is a much cleaner, and in fact faster, way to compute the L^2-norm of the vector x. Especially for large values of n, the second piece of code that exploits the Numpy functionality can be much faster! The Python code below (which we will not discuss) illustrates this comparison by timing how long both approaches require to compute the norm for n = 30.000.000 (i.e., thirty million). If you run the code below on your own device, you might get different outputs, but, in general, there should be a significant (multiplicative) difference in execution time.\nCode that times execution of the two approaches above\nimport numpy as np\nimport time\n\n## Computing norm with for-loop\n\n# We determine the time it takes to input the code between start and end\nstart = time.time()\n\n# Length of vector\nn = 30000000\n\n# Compute inner summation of ||x||_2\ninner_sum = 0\nfor i in range(1,n+1):\n    inner_sum = inner_sum + i**2\n\n# Take square root\ntwo_norm = (inner_sum)**(0.5)\n\nend = time.time()\n\n# Time difference\nloop_time = end - start\nprint('%.10f seconds needed for computing norm' % (loop_time), \n      'with for-loop')\n\n## Computing norm with Numpy functions\n\n#We determine the time it takes to input the code between start and end\nstart = time.time()\n\n# Length of vector\nn = 30000000\n\n# Define vector x as array using arange() function\nx = np.arange(1,n+1)\n\n# Compute two-norm with built-in function\ntwo_norm = np.linalg.norm(x)\n\nend = time.time()\n\n# Time difference\nnumpy_time = end - start\nprint('%.10f seconds needed for computing norm' % (numpy_time), \n      'with Numpy functions')\n\n\n#This shows how many times faster Numpy approach is faster than for-loop solution\nif numpy_time != 0:\n    (print('NumPy\\'s approach is %i times more efficient than for-loop approach.'\n            % ((loop_time)/(numpy_time))))\n\n\n19.9974977970 seconds needed for computing norm with for-loop\n0.2253108025 seconds needed for computing norm with Numpy functions\nNumPy's approach is 88 times more efficient than for-loop approach.\nOne important take-away of the above comparison is the following.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Good coding practices</span>"
    ]
  },
  {
    "objectID": "02-good-coding.html#efficient-computations",
    "href": "02-good-coding.html#efficient-computations",
    "title": "2  Good coding practices",
    "section": "",
    "text": "When performing mathematical tasks, avoid the use of for- and while-loops, as well as if/else-statements, by efficient use of Python functionality.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Good coding practices</span>"
    ]
  },
  {
    "objectID": "02-good-coding.html#no-hard-coding",
    "href": "02-good-coding.html#no-hard-coding",
    "title": "2  Good coding practices",
    "section": "2.2 No hard coding",
    "text": "2.2 No hard coding\nSuppose we are given the function f(x) = a \\cdot x^2+ a\\cdot b \\cdot x - a \\cdot b \\cdot c and the goal is to compute f(10) for a = 3, b = 4 and c = -10. One way of doing this would be to plug in all the variables and return the resulting function value.\n\n# Hard coding\nprint(3*(10**2) + 3*4*10 + 4*-2*3)\n\n396\n\n\nHowever, this is inefficient for the following reason: If we would want to change the number x = 10 to, e.g., x = 20, we would have to twice replace 10 by 20. The same is true for the variable a, which appears in even three places. In general, in large scripts, variables can appear in more than a hundred places. To overcome this inefficiency issue, it is always better to separate the input data (the x,a,b and c in this case) from the function execution\n\n# No hard coding\ndef f(x, a, b, c):\n    return a*x**2 + a*b*x + b*c*a\n\nx = 10\na, b, c = 3, 4, -2\nprint(f(x, a, b, c))\n\n396\n\n\nThe take-away of the above comparison is the following.\n\nSeparate input data from the execution of functions and commands.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Good coding practices</span>"
    ]
  },
  {
    "objectID": "02-good-coding.html#dont-repeat-yourself-dry",
    "href": "02-good-coding.html#dont-repeat-yourself-dry",
    "title": "2  Good coding practices",
    "section": "2.3 Don’t repeat yourself (DRY)",
    "text": "2.3 Don’t repeat yourself (DRY)\nIf you have to carry out a piece of code for multiple sets of input data, always avoid copy-pasting the code. As a first step, try to to the repeated execution using a for-loop. For example, suppose we want to print the function values f(x,3,4,-2) for x = 1,2,3,4, with f as in the previous section. We can do this as follows.\n\ndef f(x, a, b, c):\n    return a*x**2 + a*b*x + b*c*a\n\na, b, c = 3, 4, -2\n\n# With repetition\nx = 1\nprint('%.2f' % f(x,a,b,c))\nx = 2\nprint('%.2f' % f(x,a,b,c))\nx = 3\nprint('%.2f' % f(x,a,b,c))\nx = 4\nprint('%.2f' % f(x,a,b,c))\n\n-9.00\n12.00\n39.00\n72.00\n\n\nA more efficient way of typing this, is by using a for-loop that repeatedly executes the print statement.\n\nimport numpy as np\n\na, b, c = 3, 4, -2\nx = [1,2,3,4]\n# Determine all function values with list comprehension\ny = [f(i,a,b,c) for i in x]\n\n# Print values in y (could also print the whole vector y right away)\nfor j in y:\n    print(j)\n\n-9\n12\n39\n72\n\n\nThe take-away of the above comparison is the following.\n\nDon’t carry out the same task on different inputs twice by copy-pasting code, but use, e.g., a for-loop in which you iterate over the inputs.\n\nIn fact, later on in the course we will explain the concept of vectorizing a function, to make sure it can handle multiple input simultaneously. This is another way to avoid unnecessary repetition and in fact also the use of loops.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Good coding practices</span>"
    ]
  },
  {
    "objectID": "02-good-coding.html#single-responsibility",
    "href": "02-good-coding.html#single-responsibility",
    "title": "2  Good coding practices",
    "section": "2.4 Single responsibility",
    "text": "2.4 Single responsibility\nWhen you write larger pieces of codes, it is often useful to split it up in smaller parts that all serve their own purpose. Suppose we want to implement Newton’s method for finding a root x of a function f : \\mathbb{R} \\rightarrow \\mathbb{R}, i.e., a point x that satisfies f(x) = 0.\nNewton’s methods starts with a (suitably chosen) initial guess x_0 \\in \\mathbb{R} and repeatedly computes better approximations using the recursive formula \nx_{i+1} = x_i - \\frac{f(x_i)}{f'(x_i)}\n\nThe goal is to implement this formula for the function f(x) = (x-1)^2 - 1, whose derivative is f'(x) = 2(x-1). The roots of this function are x = 0 and x = 2.\n\n# We implement the function y = x - f(x)/f'(x)\ndef y(x):\n    return x - ((x-1)**2 - 1)/(2*(x-1))\n\nx0 = 3\nx1 = y(x0) \n\nprint(x1)\n\n2.25\n\n\nA clearer way to implement the formula x_{i+1} = x_i - f(x_i)/f'(x_i) is to define separate functions for the evaluation of the functions f and f', and then combine these to create the recursive formula. In this way, we get three functions that are each responsible for one aspect of Newton’s formula, namely implementing the function f, implementing the function f' and computing the recursive formula. This also makes it easier for a user of the code to understand what is happening.\n\n# Single responsibility version\n\n# Define f\ndef f(x):\n    return (x-1)**2 - 1\n\n# Define f'\ndef fprime(x):\n    return 2*(x-1)\n\n# Implement function y = x - f(x)/f'(x)\ndef y(x):\n    return x - f(x)/fprime(x)\n\nx0 = 3\nx1 = y(x0) \n\nprint(x1)\n\n2.25\n\n\nThe take-away of the above comparison is the following.\n\nIf you are implementing a complex mathematical task involving multiple aspects, try to separate these aspects in different functions.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Good coding practices</span>"
    ]
  },
  {
    "objectID": "02-good-coding.html#documentation",
    "href": "02-good-coding.html#documentation",
    "title": "2  Good coding practices",
    "section": "2.5 Documentation",
    "text": "2.5 Documentation\nThe final good coding practice that we discuss is documentation. Ideally, you should always explain inside a function what the inputs and outputs are, and for larger scripts it is good to indicate what every part of the script does. For smaller functions and scripts this is not always necessary. We will next give an example for Newton’s method as in the previous section\n\n## Function that implements Newton's method\ndef newton(f,fprime,x0,iters):\n    \"\"\"\n    This function implements Newton's iterative method \n    x_{i+1} = x_i - f(x_i)/f'(x_i) for finding root of f.\n    \n    Input parameters\n    ----------\n    f : Function f\n    fprime : Derivative of the function f\n    x0 : Initial estimate for root x of f.\n    iters : Number of iterations that we run Newton's method.\n    \n    Returns\n    -------\n    Approximation for x satisfying f(x) = 0.\n    \"\"\"\n    \n    # Initial guess\n    x = x0 \n    \n    # Repeatedly compute the recursive formula \n    # by overwriting x for 'iters' iterations\n    for i in range(iters):\n        x_new = x - f(x)/fprime(x) \n        x = x_new\n    return x\n    \n## An example of Newton's method as implemented above\n\n# Define f\ndef f(x):\n    return (x-1)**2 - 1\n\n# Define f'\ndef fprime(x):\n    return 2*(x-1)\n    \n# Define intial guess and number of iterations\nx0 = 10\niters = 6   \n\n# Run Newton's method\nroot = newton(f,fprime,x0,iters)\n\n# Print output and explain what has been computed\nprint('Running Newton\\'s method for %.i iterations with initial' % iters,\n       'estimate %.2f' % x0,'\\n','gives (estimated) root x = %.7f' % root, \n       'with f(x) = %.7f' % f(root))\n\nRunning Newton's method for 6 iterations with initial estimate 10.00 \n gives (estimated) root x = 2.0000013 with f(x) = 0.0000025\n\n\nThe following is a set of guidelines regarding how to add documentation to a function.\n\nTry to adhere to the following documention rules when writing complex functions:  1. Function documentation between triple double-quote characters. 2. Clearly describe what a function does and what its input and output arguments are. 3. Choose descriptive variable names, lines not longer than 80 characters. 4. Don’t add comments for every line. Add comments for main ideas and complex parts.  5. A comment should not repeat the code as text (e.g. “time = time + 1 # increase time by one).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Good coding practices</span>"
    ]
  },
  {
    "objectID": "03-numpy-arrays.html",
    "href": "03-numpy-arrays.html",
    "title": "3  NumPy arrays",
    "section": "",
    "text": "3.1 Introduction\nThe NumPy package (module) is used in almost all numerical computations using Python. It is a package that provides high-performance vector, matrix and higher-dimensional data structures for Python. High-performance here refers to the fact that Python can perform computations on such data structures very quickly if appropriate functions are used for this.\nTo use NumPy you need to import the numpy module. This is typically done under the alias np so that you don’t have to type numpy all the time when using a function from the module.\nimport numpy as np\nWe emphasize at this point that there is often not a unique way or command to achieve a certain outcome. When doing the exercises corresponding to the theory given in this chapter, it is, however, recommended to find a solution using the presented functionality.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>NumPy arrays</span>"
    ]
  },
  {
    "objectID": "03-numpy-arrays.html#creating-arrays",
    "href": "03-numpy-arrays.html#creating-arrays",
    "title": "3  NumPy arrays",
    "section": "3.2 Creating arrays",
    "text": "3.2 Creating arrays\nIn the NumPy package the data type used for vectors, matrices and higher-dimensional data sets is an array. There are a number of ways to initialize new arrays, for example from\n\na Python list or tuples;\nusing functions that are dedicated to generating numpy arrays, such as arange() and linspace() (we will see those later);\nreading data from files.\n\n\n3.2.1 Lists\nFor example, to create new vector and matrix arrays from Python lists we can use the numpy.array() function. Since we imported NumPy under the alias np, we use np.array() for this.\nTo create a vector, the argument to the array function is a Python list\n\nv = np.array([1,2,3,4]) #Array creation from list [1,2,3,4]\nprint(v)\n\n[1 2 3 4]\n\n\nTo create a matrix, the argument to the array function is a nested Python list. Every element of the outer list is a list corresponding to a row of the matrix. For example, the matrix \nM = \\left[ \\begin{matrix}1 & 2 & 7\\\\ 3 & -4 & 4 \\end{matrix} \\right]\n is created as follows.\n\nM = np.array([[1, 2, 7], [3, -4, 4]])\nprint(M)\n\n[[ 1  2  7]\n [ 3 -4  4]]\n\n\nYou can access the shape (number of rows and columns) , size (number of elements) and number of dimensions (number of axes in matrix) of the array with the shape, size and ndim attributes, respectively. Note that the size is simply the product of the numbers in the shape tuple, and the number of dimensions is the size of the shape tuple.\n\n# Shape of matrix M\nshape_M = M.shape  #np.shape(M) also works\nprint(shape_M) \n\n(2, 3)\n\n\n\n# Size of matrix M\nsize_M = M.size  #np.size(M) also works\nprint(size_M) \n\n6\n\n\n\n# Number of diemenions\nndim_M = M.ndim  #np.ndim(M) also works\nprint(ndim_M) \n\n2\n\n\nNumPy arrays are of the type ndarray (short for n-dimensional array). You can access this type through the type() function.\n\n# Type of matrix M\ntype_M = type(M)\nprint(type_M) \n\n&lt;class 'numpy.ndarray'&gt;\n\n\nSo far a NumPy array looks awfully much like a Python list (or nested list). Why not simply use Python lists for computations instead of creating a new array type?\nThere are several reasons:\n\nPython lists are very general. They can contain any kind of object. They are dynamically typed. They do not support mathematical functions such as matrix and dot multiplications.\nNumpy arrays are statically typed and homogeneous. The type of the elements is determined when the array is created.\nNumpy arrays are memory efficient.\nBecause of the static typing, fast implementation of mathematical functions such as multiplication and addition of numpy arrays can be implemented in a compiled language (C and Fortran are used).\n\nUsing the dtype (data type) attribute of an array, we can see what type the data inside an array has.\n\n# Data type of elements in array\ndtype_M = M.dtype\nprint(dtype_M)\n\nint32\n\n\nIf we want, we can explicitly define the type of the array data when we create it, using the dtype keyword argument:\n\n# Define data as integers\nM = np.array([[1, 2], [3, 4]], dtype=int)\nprint('M = \\n', M)\n\nM = \n [[1 2]\n [3 4]]\n\n\n\n# Define data as floats\nN = np.array([[1, 2], [3, 4]], dtype=float)\nprint('N = \\n', N)\n\nN = \n [[1. 2.]\n [3. 4.]]\n\n\n\n# Define data as complex floats\nO = np.array([[1, 2], [3, 4]], dtype=complex)\nprint('O = \\n', O)\n\nO = \n [[1.+0.j 2.+0.j]\n [3.+0.j 4.+0.j]]\n\n\nCommon data types that can be used with dtype are: int, float, complex, bool, object, etc.\nWe can also explicitly define the bit size of the data types, such as: int64, int16, float128, complex128. For example, int64 allows us to define an integer variable in the range [−264,…,264].\nYou can also change the data type of the elements using the astype() method.\n\nM = np.array([[1,2], [3,4]])\nprint(M.dtype)\n\nint32\n\n\n\n# Define M_float as matrix whose elements are those of \n# the matrix M, but then as floats.\nM_float = M.astype(float)\nprint(M_float)\n\n[[1. 2.]\n [3. 4.]]\n\n\n\nprint(M_float.dtype)\n\nfloat64\n\n\n\n\n3.2.2 Arrays froms functions\nThere are various useful arrays that can be automatically created using functions from the NumPy package. These arrays are typically hard to implement directly as a list.\narange(n): This function creates the array [0,1,2,\\dots,n-1] whose elements range from 0 to n-1.\n\nn = 10\nx = np.arange(n) \n\nprint(x)\n\n[0 1 2 3 4 5 6 7 8 9]\n\n\nIf you want to explicitly define the data type of the elements, you can add the dtype keyword argument (the same applies for all functions that are given below).\n\nn = 10\nx = np.arange(n, dtype=float) \n\nprint(x)\n\n[0. 1. 2. 3. 4. 5. 6. 7. 8. 9.]\n\n\narange(a,b): This function creates the array [a,a+1,a+2,\\dots,b-2,b-1].\n\na, b = 5,11\nx = np.arange(a,b)\n\nprint(x)\n\n[ 5  6  7  8  9 10]\n\n\narange(a,b,step): This function creates the array [a,a+step,a+2\\cdot step,\\dots,b-2\\cdot step,b-step]. That is, the array ranges from a to b (but not including b itself), in steps of size step.\n\na, b, step = 5, 11, 0.3\nx = np.arange(a,b,step)\n\nprint(x)\n\n[ 5.   5.3  5.6  5.9  6.2  6.5  6.8  7.1  7.4  7.7  8.   8.3  8.6  8.9\n  9.2  9.5  9.8 10.1 10.4 10.7]\n\n\nlinspace(a,b,k): Create a discretization of the interval [a,b] containing k evenly spaced points, including a and b as the first and last element of the array.\n\na,b,k = 5,10,20\nx = np.linspace(a,b,k)\n\nprint(x)\n\n[ 5.          5.26315789  5.52631579  5.78947368  6.05263158  6.31578947\n  6.57894737  6.84210526  7.10526316  7.36842105  7.63157895  7.89473684\n  8.15789474  8.42105263  8.68421053  8.94736842  9.21052632  9.47368421\n  9.73684211 10.        ]\n\n\ndiag(x): This function creates a matrix whose diagonal contains the list/vector/array x.\n\nx = np.array([1,2,3])\nD = np.diag(x)\n\nprint(D)\n\n[[1 0 0]\n [0 2 0]\n [0 0 3]]\n\n\nnp.zeros(n): This function create a vector of length n with zeros.\n\nn = 5\nx = np.zeros(n)\n\nprint(x)\n\n[0. 0. 0. 0. 0.]\n\n\nnp.zeros((m,n)): This function create a matrix of size m \\times n with zeros. Note that we have to input the size of the matrix as a tuple (m,n); using np.zero(m,n)\n\nm, n = 2, 5\nM = np.zeros((m,n))\n\nprint(M)\n\n[[0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0.]]\n\n\nnp.ones(n) and np.ones((m,n)): These functions create a vector of length n with ones, and a matrix of size m \\times n with ones, respectively.\n\nm, n = 2, 5\nx = np.ones(n)\n\nprint(x)\n\n[1. 1. 1. 1. 1.]\n\n\n\nM = np.ones((m,n))\n\nprint(M)\n\n[[1. 1. 1. 1. 1.]\n [1. 1. 1. 1. 1.]]\n\n\nmgrid[a:b,c:d]: This function can be used to generate a “grid” of integer points in [a,b-1] \\times [c,d-1] for a,b,c,d, \\in \\mathbb{N}.\nIn the execution below, the idea is that the function generates two matrices x and y, so that points (x[i][j],y[i][j]) correponds to a grid point (a+i,c+j) for i = 0,\\dots,a-(b-1) and j = 0,\\dots,c - (d-1). More generally, for a given grid point (a+i,c+j), the matrix x stores the first coordinate a+i, and y the second coordinate c+j.\n\na,b = 0,5\nc,d = 2,6\nx, y = np.mgrid[a:b, c:d]\n\n\nprint(x)\n\n[[0 0 0 0]\n [1 1 1 1]\n [2 2 2 2]\n [3 3 3 3]\n [4 4 4 4]]\n\n\n\nprint(y)\n\n[[2 3 4 5]\n [2 3 4 5]\n [2 3 4 5]\n [2 3 4 5]\n [2 3 4 5]]\n\n\n\n\n3.2.3 Reading data from files\nThe third option, which you might use most often in a professional context, is to read in data from a file directly into a NumPy array. You can do this using the loadtxt() function.\nIf you want to try this yourself, download the file numerical_data.dat here and store it in the same folder as where you are storing the Python script in which you execute the code snippet below.\n\n# Load data into NumPy array\ndata_dat = np.loadtxt('numerical_data.dat')\n\n# Print the data\nprint(data_dat)\n\n[[ 1.   5.   4.  -9.   1. ]\n [ 3.   5.   6.   7.   7. ]\n [ 4.   3.   2.   1.   0.5]]\n\n\nPython puts every row in the data (DAT) file into a separate row of the NumPy array; note that the numbers in the data file are separated by a whitespace character.\nWe can also save data from a Numpy array into a DAT-file using the savetxt() function. The first argument of this function is the name of the file in which you want to store the array, and the second argument is the array to be stored.\n\n# Matrix M\nM = np.array([[1,2,3],[5,6,7],[10,11,12],[14,15,16]])\n\n# Save matrix to DAT file\nnp.savetxt('matrix.dat', M)\n\nThis should have created the file matrix.dat in the same folder as where you stored the Python script that ran the code above. You might notice that the numbers are stored using the scientific notation. For example, the number 1 appears as 1.000000000000000000e+00 in the CSV-file.\nYou can suprress this behaviour by explicitly specifying the data type in which you want the numbers in the matrix to be stored using the fmt keyword argument. For example, fmt = '%i' stores the numbers as integers.\n\n# Matrix M\nM = np.array([[1,2,3],[5,6,7],[10,11,12],[14,15,16]])\n\n# Save matrix to DAT file\nnp.savetxt('matrix_int.dat', M, fmt='%i')\n\nThis should have created the file matrix_int.dat in the same folder as where you stored the Python script that ran the code above.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>NumPy arrays</span>"
    ]
  },
  {
    "objectID": "03-numpy-arrays.html#accessing",
    "href": "03-numpy-arrays.html#accessing",
    "title": "3  NumPy arrays",
    "section": "3.3 Accessing",
    "text": "3.3 Accessing\nIn this section we will describe how you can access, or index, the data in a NumPy array.\nWe can index elements in an array using square brackets and indices, just like as with lists. In NumPy indexing starts at 0, just like with a Python list.\n\nv = np.array([12,4,1,9])\n\n# Element in position 0\nprint(v[0])\n\n# Element in position 2\nprint(v[2])\n\n# Element in position -1 (last element)\nprint(v[-1]) # Same as v[3]\n\n# Element in position -3 (counted backwards)\nprint(v[-3]) # Same as v[1]\n\n12\n1\n9\n4\n\n\n\n3.3.1 Basic indexing\nIf you want to access the element at position (i,j) from a two-dimensional array, you can use the double bracket notation [i][j], but with arrays you can also use the more compact syntax [i,j].\n\nM = np.array([[10,2,6,7], [-15,6,7,-8], [9,10,11,12],[3,10,6,1]])\n\n# Element at position (1,1)\nprint('List syntax:',M[1][1])\n\n# Element at position (1,1)\nprint('Array syntax', M[1,1])\n\nList syntax: 6\nArray syntax 6\n\n\nIf you want to access row i you can use M[i] or M[i,:].\n\nprint(M[2]) # Gives last row\n\nprint(M[2,:]) # Gives last row\n\n[ 9 10 11 12]\n[ 9 10 11 12]\n\n\nIf you want to access column j you can use M[:,j]. Both here and in the previous command, the colon : is used to indicate that we want all the elements in the respective dimension. So M[:,j] should be interpreted as, we want the elements from all rows in the j-th column.\n\n\n3.3.2 Index slicing\nIndex slicing is the technical name for the index syntax that returns a slice, a consecutive part of an array.\n\nv = np.array([12,4,1,9,11,14,17,98])\n\nprint(v)\n\n[12  4  1  9 11 14 17 98]\n\n\nv[lower:upper]: This return the elements in v at positions lower, lower+1,...,upper-1. Note that the element at position upper is not included.\n\n# Returns v[1], v[2], v[3], v[4], v[5]\nprint(v[1:6]) \n\n[ 4  1  9 11 14]\n\n\nYou can also omit the lower or upper value, in which case it is set to be position 0 or the last position -1, respectively.\n\n# Returns v[3],...,v[8]\nprint(v[3:]) \n\n# Returns v[0],...,v[4]\nprint(v[:5]) \n\n[ 9 11 14 17 98]\n[12  4  1  9 11]\n\n\nv[lower:upper:step]: This returns the elements in v at position lower,lower+step,lower+2*step,...(upper-1)-step, (upper-1). It does the same as [lower:upper], but now in steps of size step.\n\nv = np.array([12,4,1,9,11,14,17,98])\n\n# Returns v[1], v[3], v[5]\nprint(v[1:6:2]) \n\n[ 4  9 14]\n\n\nYou can omit any of the three parameters lower,upper and step\n\n# lower, upper, step all take the default values\nprint(v[::])\n\n# Index in step is 2 with lower and upper defaults \nprint(v[::2]) \n\n# Index in steps of size 2 starting at position 3\nprint(v[3::2]) \n\n[12  4  1  9 11 14 17 98]\n[12  1 11 17]\n[ 9 14 98]\n\n\nYou can also use slicing with negative index values.\n\n# The last three elements of v\nprint(v[-3:]) \n\n[14 17 98]\n\n\nFurthermore, the same principles apply to two-dimensional arrays, where you can specify the desired indices for both dimensions\n\nM = np.array([[10,2,6,7], [-15,6,7,-8], [9,10,11,12],[3,10,6,1]])\n\nprint(M)\n\n[[ 10   2   6   7]\n [-15   6   7  -8]\n [  9  10  11  12]\n [  3  10   6   1]]\n\n\n[a:b, c:d]: This returns the submatrix consisting of the rows a,a+1,...,b-1 and rows c,c+1,...,d. You can also combine this with a step argument, i.e., use [a:b:step1, c:d:step2].\n\n# Returns elements in submatrix formed by rows 2,3 (excluding 4)\n# and columns 1,2 (excluding 3)\nprint(M[2:4,1:3]) \n\n[[10 11]\n [10  6]]\n\n\nIf you want to obtain a submatrix whose rows and/or columns do not form a consecutive range, or if you want to specify these list manually, you can use the ix_() function from NumPy. Its arguments should be a list of row indices, and a list of column indices specifying the indices of the desired submatrix.\n\ni = [0,2,3]\nj = [0,3]\n\n# Returns submatrix formed by rows 0,2,3 and columns 0,3\nprint(M[np.ix_(i,j)])\n\n[[10  7]\n [ 9 12]\n [ 3  1]]\n\n\n\n\n3.3.3 Fancy indexing\nFancy indexing is the name for when an array or list is used instead of indices, to access part of an array. For example, if you want to access elements in the locations (0,3), (1,2) and (1,3), you can define a list of row indices [0,1,1] and columns indices [3,2,3] and access the matrix with these lists.\n\ni = [0,1,1]\nj = [3,2,3]\n\n# Returns M[0,3] = 7, M[1,2] = 7, M[1,3] = -8\nprint(M[i,j])\n\n[ 7  7 -8]\n\n\nAnother way of fance indexing is by using a Boolean list, that indicates for every element whether it should be index (True) or not (False). Such a list is sometimes called a mask.\n\nv = np.array([1,6,2,3,9,3,6])\n\n# Tell for every element whether is should be index\nmask = [False, True, True, True, False, True, False]\n\nprint(v[mask])\n\n[6 2 3 3]\n\n\nTypically, the mask is generated from a Boolean statement. For example, suppose we want to select all elements strictly smaller than 3 and greater or equal than 7 from the array v.\nThe following statements achieve this. Recall that you can use & if you want the first AND the second statement to be satisfied, and | if either the first OR the second has to be satisfied (or both).\n\nmask_37 = (v &lt; 3) | (v &gt;= 7)\n\n# Boolean vector indiciating for ever element in v\n# whether the conditions v &lt; 3 and v &gt;= 7 are satisfied\nprint(mask_37)\n\n[ True False  True False  True False False]\n\n\nWe can now access the elements satisfying these conditions by indexing v with this mask\n\nprint(v[mask_37])\n\n[1 2 9]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>NumPy arrays</span>"
    ]
  },
  {
    "objectID": "03-numpy-arrays.html#modifying",
    "href": "03-numpy-arrays.html#modifying",
    "title": "3  NumPy arrays",
    "section": "3.4 Modifying",
    "text": "3.4 Modifying\n\n3.4.1 Elements, rows or columns\nUsing similar ways of indexing as in the previous section, we can also modify the elements of an array\n\nM = np.array([[1,1,1,1], [2,2,2,2], [3,3,3,3],[4,4,4,4]])\n\nprint(M)\n\n[[1 1 1 1]\n [2 2 2 2]\n [3 3 3 3]\n [4 4 4 4]]\n\n\n\n# Modify individual element\nM[0,1] = -1\n\nprint(M)\n\n[[ 1 -1  1  1]\n [ 2  2  2  2]\n [ 3  3  3  3]\n [ 4  4  4  4]]\n\n\n\n# Modify (part of a) row\nM[1,[1,2,3]] = [-2,-2,-2]\n\nprint(M)\n\n[[ 1 -1  1  1]\n [ 2 -2 -2 -2]\n [ 3  3  3  3]\n [ 4  4  4  4]]\n\n\n\n# Modify third column to ones\nM[:,3] = np.ones(4)\n\nprint(M)\n\n[[ 1 -1  1  1]\n [ 2 -2 -2  1]\n [ 3  3  3  1]\n [ 4  4  4  1]]\n\n\n\n\n3.4.2 Broadcasting\nThere does not necessarily have to be a match between the part of the matrix that we index, and the dimensions of the data that we want to overwrite that part with.\n\nM = np.array([[1,1,1,1], [2,2,2,2], [3,3,3,3],[4,4,4,4]])\n\nprint(M)\n\n[[1 1 1 1]\n [2 2 2 2]\n [3 3 3 3]\n [4 4 4 4]]\n\n\nFor example, in order to replace the third column of M by ones, we can also do the command below, instead of using np.ones(4).\n\n# Modify third column to ones\nM[:,3] = 1\n\nprint(M)\n\n[[1 1 1 1]\n [2 2 2 1]\n [3 3 3 1]\n [4 4 4 1]]\n\n\nAlthough there is a mismatch between the indexed part on the left (a column) and the data on the right (single number), Python broadcasts the data to an appopriate format by copying it to the correct size. That is, it copies the 1 to an array [1,1,1,1] of ones, which it then places in the third column.\nThis works similar in higher dimensions. Suppose we want to overwrite the second and third row with [1,6,2,3]. Then the indexed part is a 2 \\times 4 array, but the data a 1 \\times 4 array.\n\n# Modify second and third row\nM[2:4,:] = [1,6,2,3]\n\nprint(M)\n\n[[1 1 1 1]\n [2 2 2 1]\n [1 6 2 3]\n [1 6 2 3]]\n\n\nPython here first copies the data to [[1,6,2,3],[1,6,2,3]] and then modifies M with this array.\n\n\n3.4.3 Transpose\nAnother useful function, in the context of linear algebra, is to take the transpose of a two-dimensional array M, which modifies the entries along the diagonal.\n\nM = np.array([[1,2,3],[3,4,-1]])\n\nprint(M)\n\n[[ 1  2  3]\n [ 3  4 -1]]\n\n\n\ntranspose_M = M.T #np.transpose(M) also works\nprint(transpose_M) \n\n[[ 1  3]\n [ 2  4]\n [ 3 -1]]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>NumPy arrays</span>"
    ]
  },
  {
    "objectID": "03-numpy-arrays.html#repeating-and-stacking",
    "href": "03-numpy-arrays.html#repeating-and-stacking",
    "title": "3  NumPy arrays",
    "section": "3.5 Repeating and stacking",
    "text": "3.5 Repeating and stacking\nWe can also use existing matrices and build new ones from it by stacking them either horizontally or vertically.\ntile(M,(k,r)): This function takes an array M and copies it k times vertically and r times horizontally, resulting in a “tiling” of the original array M.\n\nM = np.array([[1,2],[3,4]])\n\nM_tile = np.tile(M,(2,3))\nprint(M_tile)\n\n[[1 2 1 2 1 2]\n [3 4 3 4 3 4]\n [1 2 1 2 1 2]\n [3 4 3 4 3 4]]\n\n\nIf you do not input a tuples with two arguments, but only a number, then tile() does the tiling only horizontally.\n\nM = np.array([[1,2],[3,4]])\n\nM_tile = np.tile(M,4)\nprint(M_tile)\n\n[[1 2 1 2 1 2 1 2]\n [3 4 3 4 3 4 3 4]]\n\n\nrepeat(M,k): This function takes every element of M, repeats it k times, and puts all these numbers in a one-dimension array.\n\nM = np.array([[1,2],[3,4]])\n\nM_repeat = np.repeat(M,3)\nprint(M_repeat)\n\n[1 1 1 2 2 2 3 3 3 4 4 4]\n\n\nvstack((a,b)): This stacks two arrays a and b vertically, provided they have the correct dimensions to do this. Note that a and b should be inputted as a tuple (a,b).\n\na = np.array([7,8])\nM = np.array([[1,2],[3,4]])\n\nM_a = np.vstack((M,a))\nprint(M_a)\n\n[[1 2]\n [3 4]\n [7 8]]\n\n\nhstack((a,b)): This stacks two arrays a and b horizontally, provided they have the correct dimensions to do this.\nNote that in the example below we define a as a 1 \\times 2 array, i.e., a column array, to make sure we can stack it right of M. If we would have kept a = np.array([7,8]) then Python will give an error, because it cannot stack a row vector next to a two-dimensional array.\n\na = np.array([[7],[8]])\nM = np.array([[1,2],[3,4]])\n\nM_a = np.hstack((M,a))\nprint(M_a)\n\n[[1 2 7]\n [3 4 8]]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>NumPy arrays</span>"
    ]
  },
  {
    "objectID": "03-numpy-arrays.html#reshaping",
    "href": "03-numpy-arrays.html#reshaping",
    "title": "3  NumPy arrays",
    "section": "3.6 Reshaping",
    "text": "3.6 Reshaping\nIt is possible to adjust the shape of an array, while keeping the data of the array the same. For example, consider the x = [1,2,3,\\dots,12].\n\nx = np.arange(1,13)\n\nprint(x)\n\n[ 1  2  3  4  5  6  7  8  9 10 11 12]\n\n\nWe can reshape it into the 3 \\times 4 matrix \nM = \\left[ \\begin{matrix} 1 & 2 & 3 & 4\\\\ 5 & 6 &7 & 8 \\\\ 11 & 10 & 11 & 12 \\end{matrix}\\right]\n by using the reshape(a,b) method. It reshapes x to an a \\times b array provided that a \\cdot b equal the size (i.e., number of elements) of x.\n\n# Reshape x to a 3-by-4 matrix\nM = x.reshape(3,4)\n\nprint(M)\n\n[[ 1  2  3  4]\n [ 5  6  7  8]\n [ 9 10 11 12]]\n\n\nWe can also reshape two-dimensional arrays, for example, we can reshape M again to a 2 \\times 6 matrix.\n\n# Reshape M to a 2-by-6 matrix\nN = M.reshape(2,6)\n\nprint(N)\n\n[[ 1  2  3  4  5  6]\n [ 7  8  9 10 11 12]]\n\n\nYou should observe that Python does the reshaping in a very specific way: When we transform x to M above, Python fills the matrix M in a row-by-row fashion (instead of column-by-column). This is because of what is called the largest (axis) index changest fastest principle.\nTo understand this idea, recall that we can access the element at position (i,j) of a matrix M with M[i,j]. Here i is the row-index at position 0 of the index list [i,j], and j is the column index at position 1 of the index list [i,j]. We said that the row indices form the 0-axis of the matrix, and the column indices the 1-axis.\n\n\n\nAxes of a two-dimensional array\n\n\nLargest (axis) index changing fastest means that an m \\times n matrix gets filled first along the 1-axis, i.e., it fills the positions (0,0), (0,1), ..., (0,n) while keeping the row index 0 fixed. It then moves up one row index, i.e., one position along the 0-axis and fills the elements (1,0),(1,1),..., (1,n), i.e., the elements along the 1-axis. It continues in this fashion until the complete matrix is full.\nAnother convenient method for reshaping is flatten(), which turns a matrix of any size into a one-dimensional array.\n\n# Define 2-by-3 matrix\nM = np.array([[9,1,3],[2,4,3]])\n\n# Turn into one-dimensional array\nx = M.flatten()\nprint(x)\n\n[9 1 3 2 4 3]\n\n\nIf you want to turn a one-dimensional array x = [x_0,\\dots,x_{n-1}] into a column array of shape (n,1), you can do this as follows.\n\nx = np.array([1,2,4,3,8])\nn = np.size(x)\n\nx = x.reshape(n,1)\nprint(x)\n\n[[1]\n [2]\n [4]\n [3]\n [8]]\n\n\nA more direct way of doing this, is by using x[:,None].\n\nx = np.array([1,2,4,3,8])\nx = x[:,None] # Turns x into column array of shape (n,1)\n\nprint(x)\n\n[[1]\n [2]\n [4]\n [3]\n [8]]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>NumPy arrays</span>"
    ]
  },
  {
    "objectID": "03-numpy-arrays.html#copy-vs.-view",
    "href": "03-numpy-arrays.html#copy-vs.-view",
    "title": "3  NumPy arrays",
    "section": "3.7 Copy vs. view",
    "text": "3.7 Copy vs. view\nIn the last sections we have seen various ways of using arrays to create other arrays. One point of caution here is whether or not the new array is a view or a copy of the original array.\n\n3.7.1 View\nA view y of an array x is another array that simply displays the elements of the array x in a different array, but the elements will always be the same. This means that if we would change an element in the array x, the same element will change in y and vice versa.\n\nx = np.array([[4,2,6],[7,11,0]])\ny = x # This create a view of x\n\nprint('y = \\n', y)\n\ny = \n [[ 4  2  6]\n [ 7 11  0]]\n\n\nWe next change an element in x. Note that the same element changes in y.\n\n# Change element in x\nx[0,2] = -30\n\n# y now also changes in that position\nprint('y = \\n',y)\n\ny = \n [[  4   2 -30]\n [  7  11   0]]\n\n\nThe same happens the other way around: If we change an element in y, then the corresponding element in x also changes.\n\n# Change element in y\ny[1,1] = 100\n\n# x now also changes in that position\nprint('x = \\n', x)\n\nx = \n [[  4   2 -30]\n [  7 100   0]]\n\n\nNote that the same behaviour occurs in we apply the reshape() method.\n\n# Define x = [1,2,...,12]\nx = np.arange(1,13)\n\n# Reshape x to a 3-by-4 matrix\nM = x.reshape(3,4) # Creates view of x\n\nprint(M)\n\n[[ 1  2  3  4]\n [ 5  6  7  8]\n [ 9 10 11 12]]\n\n\nIf we now change an element in M, then the corresponding element changes in x. This mean that M is a view of the original array x.\n\n# Change element in M\nM[1,3] = 50\n\n# x now also changes in that position\nprint(x)\n\n[ 1  2  3  4  5  6  7 50  9 10 11 12]\n\n\n\n\n3.7.2 Copy\nA copy of an array x is an array z that is completely new and independent of x, meaning that if we change an element in x, then the corresponding element in z does not change, and vice versa. To obtain a copy of x, we can simply apply the copy() method to it.\n\n# Define x = [1,2,...,12]\nx = np.arange(1,13)\n\nz = x.copy() # Create copy of x\nz[0] = -10 # Change element of z\n\nprint('z = \\n', z)\nprint('x = \\n', x) # x has not changed\n\nz = \n [-10   2   3   4   5   6   7   8   9  10  11  12]\nx = \n [ 1  2  3  4  5  6  7  8  9 10 11 12]\n\n\nNote that in the above example, x remains unchanged when we modify the element of z at position 0.\nSimilarly, to turn a reshaped array into a copy, we can apply the copy() method to it.\n\n# Define x = [1,2,...,12]\nx = np.arange(1,13)\n\n# Reshape x to a 3-by-4 matrix\nM = x.reshape(3,4).copy() # Create copy \nM[0,0] = -10 # Change element of x\n\nprint('M = \\n', M)\nprint('x = \\n', x) # x has not changed\n\nM = \n [[-10   2   3   4]\n [  5   6   7   8]\n [  9  10  11  12]]\nx = \n [ 1  2  3  4  5  6  7  8  9 10 11 12]\n\n\nThe flatten() method actually directly creates a copy of the original array.\n\n# Define 2-by-3 matrix\nM = np.array([[9,1,3],[2,4,3]])\n\n# Turn into one-dimensional array\nx = M.flatten() # Creates copy of M\nx[0] = 100 # Change element in x\n\nprint('x = \\n', x) \nprint('M = \\n', M) # M has not changed\n\nx = \n [100   1   3   2   4   3]\nM = \n [[9 1 3]\n [2 4 3]]\n\n\n\nIt is important to know whether a Python function or command creates a copy or a view of the original array. You can typically look this up in the documentation of Python. Otherwise, experiment with the function or command to be sure how it behaves.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>NumPy arrays</span>"
    ]
  },
  {
    "objectID": "04-vectorization.html",
    "href": "04-vectorization.html",
    "title": "4  Vectorization",
    "section": "",
    "text": "4.1 Arithmetic operations\nAll basic arithmetic operations (addition, substraction, division, multiplication and comparison) are vectorized in Python. We will illustrate this with the addition operation +, but the same commands can be applied to the other arithmetic operations -, /, *, and &gt;=, ==, &lt;=, !=.\nThe addition operation + can be used to add two numbers together, as you well know. It can also add two arrays, i.e., it works as well for one- and two-dimensional arrays if they have the same shape. This is the usual addition operation you learn about when studying linear algebra.\nx = np.array([1,4,7])\ny = np.array([2,4,3])\n\nprint('x + y =\\n',x+y)\n\nx + y =\n [ 3  8 10]\nA = np.array([[1,2],[1,4]])\nN = np.array([[7,9],[3,4]])\n\nprint('A + N = \\n',A+N)\n\nA + N = \n [[ 8 11]\n [ 4  8]]\nPython is also able to handle addition of arrays of different shapes in certain cases, using the concept of broadcasting that we have seen before. For example, we can add a single number to any array, in which case Python adds this number to every element in the array. This can be seen as an instance of vectorization.\nc = 5\n\nprint('A + c =\\n', A+c)\n\nA + c =\n [[6 7]\n [6 9]]\nWe can also add either a one-dimensional array x of size n to an m \\times n matrix A. In this case, the array x gets added to every row of A:\n\\begin{align*}\nA + x  = &\n\\left[\n\\begin{matrix}\na_{00} & a_{01} & \\dots & a_{0(n-1)} \\\\\na_{10} & a_{11} & \\dots & a_{1(n-1)} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{(m-1)0} & a_{(m-1)1} & \\dots & a_{(m-1)(n-1)}\n\\end{matrix}\n\\right] +\n\\left[\n\\begin{matrix}\nx_{0} & x_{1} & \\dots & x_{(n-1)}\n\\end{matrix}\n\\right] \\\\\n= &\n\\left[\n\\begin{matrix}\na_{00} + x_0 & a_{01} + x_1 & \\dots & a_{0(n-1)} + x_{n-1} \\\\\na_{10} + x_0 & a_{11} + x_1 & \\dots & a_{1(n-1)} + x_{n-1}\\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{(m-1)0} + x_0 & a_{m1} + x_1 & \\dots & a_{(m-1)(n-1)} + x_{n-1}\n\\end{matrix}\n\\right]\n\\end{align*}\nIn the example below, we have m = 3 and n = 2.\nx = np.array([10,12])\nprint('Shape of x:', np.shape(x))\n\nA = np.array([[1,2],[1,4],[3,1]])\nprint('Shape of A:', np.shape(A))\n\nprint('A + x = \\n', A + x)\n\nShape of x: (2,)\nShape of A: (3, 2)\nA + x = \n [[11 14]\n [11 16]\n [13 13]]\nAgain, this can be seen as an instance of vectorization, since Python automatically adds x to every row of the matrix A.\nAddition works in the same way if we define x explicitly as an array of shape (1,n).\nx = np.array([[10,12]])\nprint('Shape of x:', np.shape(x))\n\nA = np.array([[1,2],[1,4],[3,1]])\nprint('Shape of A:', np.shape(A))\n\nprint('A + x =\\n', A + x)\n\nShape of x: (1, 2)\nShape of A: (3, 2)\nA + x =\n [[11 14]\n [11 16]\n [13 13]]\nThe same works if we define x = [x_0,\\dots,x_{m-1}]^T as a column array of shape (m,1), in which case it gets added to every column of the matrix A of shape (m,n):\n\\begin{align*}\nA + x  = &  \\left[\n\\begin{matrix}\na_{00}  & a_{01} & \\dots & a_{0(n-1)} \\\\\na_{10}  & a_{11} & \\dots & a_{1(n-1)} \\\\\n\\vdots  & \\vdots & \\ddots & \\vdots \\\\\na_{(m-1)0}  & a_{(m-1)1}  & \\dots & a_{(m-1)(n-1)}\n\\end{matrix}\n\\right]+\n\\left[\n\\begin{matrix}\nx_{0} \\\\ x_{1} \\\\ \\vdots \\\\ x_{(m-1)} \\\\\n\\end{matrix}\n\\right] \\\\\n= &\n\\left[\n\\begin{matrix}\na_{00} + x_0 & a_{01} + x_0& \\dots & a_{0(n-1)} + x_0\\\\\na_{10} + x_1 & a_{11} + x_1& \\dots & a_{1(n-1)} + x_1\\\\\n\\vdots  & \\vdots & \\ddots & \\vdots\\\\\na_{(m-1)0} + x_{m-1} & a_{(m-1)1} + x_{m-1} & \\dots & a_{(m-1)(n-1)} + x_{m-1}\n\\end{matrix}\n\\right]\n\\end{align*}\nx = np.array([[10],[12],[14]])\nprint('Shape of x:', np.shape(x))\n\nA = np.array([[1,2],[1,4],[3,1]])\nprint('Shape of A:', np.shape(A))\n\nprint('A + x =\\n', A + x)\n\nShape of x: (3, 1)\nShape of A: (3, 2)\nA + x =\n [[11 12]\n [13 16]\n [17 15]]\nWe cannot add arrays of any dimensions to each other. For example, if we would try to add a a 2 \\times 2 array to a 4 \\times 2 array, then Python will return ValueError: operands could not be broadcast together with shapes (4,2) (2,2), i.e., Python cannot perform this addition.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Vectorization</span>"
    ]
  },
  {
    "objectID": "04-vectorization.html#arithmetic-operations",
    "href": "04-vectorization.html#arithmetic-operations",
    "title": "4  Vectorization",
    "section": "",
    "text": "Note that the shape of x is (n,) which is the syntax that Python uses to denote that x only has one dimension.  You can define x = [x_0,\\dots,x_{n-1}] explicitly as a row vector of shape (1,n) by defining x = np.array([[x_0,...,x_{n-1}]]), that is, with double brackets. It is sometimes needed to change the shape of an array from (n,) to (1,n) or (n,1) to be able to use a function from NumPy.\n\n\n\n\n\n\n\n\n4.1.1 Multiplication broadcasting\nWe emphasize that the broadcasting concepts above also apply to the multiplication operator *. That is, if x is a column array then A*x multiplies every column of A in a pointwise fashion with the array x. Similarly, for two matrix A and B, the syntax A*B returns a matrix in which all elements of A and B are pointwise multiplied with each other, that is, entry (i,j) contains a_{ij}\\cdot b_{ij}.\nThis is not the same as, e.g., the matrix-vector multiplication Ax in the linear algebra sense, i.e,\n\\begin{align*}\nAx = &  \\left[\n\\begin{matrix}\na_{00}  & a_{01} & \\dots & a_{0(n-1)} \\\\\na_{10}  & a_{11} & \\dots & a_{1(n-1)} \\\\\n\\vdots & \\vdots& \\ddots  & \\vdots\\\\\na_{(m-1)0}  & a_{(m-1)1}  & \\dots & a_{(m-1)(n-1)}\n\\end{matrix}\n\\right]\\left[\n\\begin{matrix}\nx_{0} \\\\ x_{1} \\\\ \\vdots \\\\ x_{(m-1)} \\\\\n\\end{matrix}\n\\right] \\\\\n= &\n\\left[\n\\begin{matrix}\na_{00}x_0 + a_{01}x_1 + \\dots + a_{0(n-1)}x_{n-1}\\\\\na_{10}x_0 + a_{11}x_1 + \\dots + a_{1(n-1)}x_{n-1}\\\\\n\\vdots  \\\\\na_{(m-1)0}x_0 + a_{(m-1)1}x_1 + \\dots + a_{(m-1)(n-1)}x_{n-1}\\\\\n\\end{matrix}\n\\right]\n\\end{align*}\nWe will see matrix-vector and matrix-matrix multiplications in the linear algebra sense later in this book.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Vectorization</span>"
    ]
  },
  {
    "objectID": "04-vectorization.html#mathematical-functions",
    "href": "04-vectorization.html#mathematical-functions",
    "title": "4  Vectorization",
    "section": "4.2 Mathematical functions",
    "text": "4.2 Mathematical functions\nMany mathematical functions in NumPy are also vectorized by default. Here you should think of functions like\n\nTrigonometry: sin(), cos(), tan()\nExponentation and logarithms: exp(), log(), log10(), log2()\nRounding: around(), floor(), ceil()\nDivision with remainder: mod(), divmod()\nPower computation: sqrt(), abs(), power()\n\nYou access them using np.function_name(). Let us look at some examples; you can check out the documentation of the other functions yourself.\n\nx = np.array([2,1,6])\n\n# Compute sin(i) for every element i in x\ny = np.sin(x)\nprint(y)\n\n[ 0.90929743  0.84147098 -0.2794155 ]\n\n\n\nA = np.array([[2,1,6],[1,1,3]])\n\n# Compute e^i for every element i in A\ny = np.exp(A)\nprint(y)\n\n[[  7.3890561    2.71828183 403.42879349]\n [  2.71828183   2.71828183  20.08553692]]\n\n\n\nx = np.array([1.249583, 3.110294, 4.51139])\n\n# Round every number in x to two decimals\nx = np.around(x, decimals=2)\nprint(x)\n\n[1.25 3.11 4.51]\n\n\n\nx = np.array([10,9,4]) \ny = np.array([2,4,5])\n\n# Compute x_i (mod y_i) for all i\n# and output divisor and remainder\nz = np.divmod(x,y)\nprint(z)\n\n(array([5, 2, 0]), array([0, 1, 4]))\n\n\nnp.divmod() outputs two arrays: the divisors and the remainder. For example, looking at x[1] = 9 and y[1] = 4: the number 4 fits twice in 9, after which 1 is left, i.e., 9 = 2 \\cdot 4 + 1. The number 2 appears in the second position of the first array, and the remainder 1 in the second position of the second array.\n\nA = np.array([[2,3,6],[4,2,3]])\nN = np.array([[1,2,3],[1,2,3]])\n\n# Pointwise compute a_{ij}^n_{ij} for all i,j\nP = np.power(A,N)\nprint(P)\n\n[[  2   9 216]\n [  4   4  27]]",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Vectorization</span>"
    ]
  },
  {
    "objectID": "04-vectorization.html#operations-along-array-axes",
    "href": "04-vectorization.html#operations-along-array-axes",
    "title": "4  Vectorization",
    "section": "4.3 Operations along array axes",
    "text": "4.3 Operations along array axes\nAnother efficient way to perform vectorized operations is to exploit the fact that many NumPy functions that perform an operation on a one-dimensional array, can also be used for two-dimensional arrays where the operation is then either performed on every column (i.e., along the 0-axis), or on every row (i.e., along the 1-axis).\n\n\n\nAxes of a two-dimensional array\n\n\nWe will look at some examples of this in the next sections.\n\n4.3.1 Sorting and searching\nThe function sort() can be used to sort the elements in a one-dimensional array in ascending order, i.e., smallest to largest.\n\n\nx = np.array([0.89, 0.5,  0.57, 0.34])\n\n# Sort and print the elements in x\nx_ascending = np.sort(x)\nprint(x_ascending)\n\n[0.34 0.5  0.57 0.89]\n\n\nIt is not possible to use sort() to sort in descending order, i.e., largest to smallest, but this can be accomplished by reversing the sorted array. We can do this using index slicing with a step size of -1, starting at position -1, meaning that Python goes backwards through the array.\n\n# Access x from beginning till end with step size -1\nx_descending = x_ascending[-1::-1] \n\nprint(x_descending)\n\n[0.89 0.57 0.5  0.34]\n\n\nVectorizing the (ascending) sort operation means we want to have a function that can take as input a two-dimensional array, and return for every row (or column) the sorted list of numbers. It turns out that sort() can do this right away, by adding an additional keyword argument axis.\nAdding axis=0 means that Python will sort the numbers in every column, i.e., along the 0-axis, and axis=1 will sort numbers in every row, i.e., along the 1-axis.\n\nA = np.array([\n [0.89, 0.5,  0.57, 0.34],\n [0.61, 0.12, 0.04, 1.  ],\n [0.27, 0.26, 0.28, 0.25],\n [0.9,  0.84, 0.15, 1.  ]])\n\n# Sort elements in every column\nA_col_ordered = np.sort(A,axis=0)\nprint(A_col_ordered)\n\n[[0.27 0.12 0.04 0.25]\n [0.61 0.26 0.15 0.34]\n [0.89 0.5  0.28 1.  ]\n [0.9  0.84 0.57 1.  ]]\n\n\n\n# Sort elements in every row\nA_row_ordered = np.sort(A,axis=1)\nprint(A_row_ordered)\n\n[[0.34 0.5  0.57 0.89]\n [0.04 0.12 0.61 1.  ]\n [0.25 0.26 0.27 0.28]\n [0.15 0.84 0.9  1.  ]]\n\n\nWe remark that sort() creates a copy, and not a view of the original matrix (see Chapter 3.7).\nAnother useful sorting function is argsort() that, for a given array $x = [x_0,,x_{n-1}] outputs an array whose i-th element is the position of the number in x that appears in place i in the ordered array np.sort(x).\n\nx = np.array([0.89, 0.5,  0.57, 0.34])\n\n# Position in original array or elements in ordered list\norder = np.argsort(x) # np.sort(x) = [0.34, 0.5, 0.57, 0.89]\nprint(order)\n\n# Obtaining sort() from argsort()\nprint(x[order])\n\n[3 1 2 0]\n[0.34 0.5  0.57 0.89]\n\n\nIn the example above, in the ordered list np.sort(x) the first number is 0.34, which appears at position 3 in x; the second number is 0.5, which appears at position 1 in x, the third number is 0.57 which appears in position 2 in x; and the fourth number is 0.89, which appears in position 0 in x.\nThis function also works for two-dimensional arrays. For example, determining the relative order of the elements in every column can be done by adding axis=0 (and similarly in every row by using axis=1).\n\nA = np.array([\n [0.89, 0.5,  0.57, 0.34],\n [0.61, 0.12, 0.04, 1.  ],\n [0.27, 0.26, 0.28, 0.25],\n [0.9,  0.84, 0.15, 1.  ]])\n\n# Determine relative order in every column\nN = np.argsort(A,axis=0)\nprint(N)\n\n[[2 1 1 2]\n [1 2 3 0]\n [0 0 2 1]\n [3 3 0 3]]\n\n\n\n\n4.3.2 Summary statistics\nThere are various other mathematical functions that can perform operations along axes by adding the axis keyword argument. Here we list some common ones from NumPy, that yield so-called summary statistics of a (one-dimensional) array:\n\nSum and product: sum(), prod(),\nMean and standard deviation: mean(), std(),\nMaximum and minimum: max(), min().\n\nWe will illustrate the use of these six functions using max(), but the same code applies to all other functions (if the task at hand is mathematically well-defined).\n\nA = np.array([\n[2,3,6],\n[4,2,3]\n])\n\nIf we apply the max() function directly to a (two-dimensional) array, it will give the maximum value in the whole array.\n\n# Gives maximum of all elements in A\nA_max = np.max(A)\n\nprint(A_max)\n\n6\n\n\nIf we add the axis keyword argument, we can either obtain the maximum of every row, or every column.\n\n# Gives maximum of every column\nA_column_max = np.max(A,axis=0)\n\nprint(A_column_max)\n\n[4 3 6]\n\n\n\n# Gives max of every row\nA_row_max = np.max(A,axis=1)\n\nprint(A_row_max)\n\n[6 4]\n\n\nAnother useful function is argmax() than can return the index (position) at which the maximum in an array is attained.\n\n# Gives position of maximum in every column\nA_col_argmax = np.argmax(A,axis=0)\n\nprint(A_col_argmax)\n\n[1 0 0]\n\n\n\n# Gives position of maximum in every row\nA_row_argmax = np.argmax(A,axis=1)\n\nprint(A_row_argmax)\n\n[2 0]\n\n\nNote that the array containing the positions of the maxima is given as a row array. If you want to turn this into a column array (because the rows are ordered vertically in a two-dimensional array), recall you can do this as follows.\n\nA_row_argmax = A_row_argmax[:,None]\n\nprint(A_row_argmax)\n\n[[2]\n [0]]\n\n\nIf we try np.argmax(A) without using the axis keyword argument, then Python first flattens the matrix into a one-dimensional array, after which it returns the position of the maximum in the flattened array. Note that this flattening happens according to the largest index changing fasted principle (so it it places all the rows after each other, and not all the columns under each other).\nAlso note that if the maximum is attained in multiple places, then Python only returns the position of the first element that attains the maximum.\n\n# Gives position of maximum \nN = np.array([\n[2,3,4],\n[4,4,3]\n])\n\nN_argmax = np.argmax(N) # Turns N into [2,3,4,4,4,3];\n                        # returns first position with maximum \n\nprint(N_argmax)\n\n2\n\n\nThere are also more advance functions that give some summative information about an array:\n\nCumulative sum: cumsum(),\nCumulative product: cumprod().\n\nThe function cumsum() return the cumulative sum of a one-dimensional array. As an example, if x = [1,4,2,5], then the cumulative sums will be given by\n\nx_{\\text{cumsum}} = [1, 1 + 4, 1 + 4 + 2, 1 + 4 + 2 + 5] = [1,5,7,12].\n\n\nx = np.array([1,4,2,5])\n\n# Cumulative sum of x\nx_cumsum = np.cumsum(x)\nprint('x_cumsum =', x_cumsum)\n\nx_cumsum = [ 1  5  7 12]\n\n\nThe function can also be vectorized using the axis keyword argument.\nThe function cumprod() returns the cumulative product. Again, if x = [1,4,2,5], then the cumulative products will be given by\n\nx_{\\text{cumprod}} = [1, 1 \\cdot 4, 1 \\cdot 4 \\cdot 2, 1 \\cdot 4 \\cdot 2 \\cdot 5] = [1,4,8,40].\n\n\nx = np.array([1,4,2,5])\n\n# Cumulative product of x\nx_cumprod = np.cumprod(x)\nprint('x_cumprod =', x_cumprod)\n\nx_cumprod = [ 1  4  8 40]\n\n\nThis function can also be vectorized using the axis keyword argument.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Vectorization</span>"
    ]
  },
  {
    "objectID": "05-linear.html",
    "href": "05-linear.html",
    "title": "5  Linear algebra and optimization",
    "section": "",
    "text": "5.1 Linear algebra\nIn this section we will often refer to one-dimensional arrays as row or column vectors, and to two-dimensional arrays as matrices.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Linear algebra and optimization</span>"
    ]
  },
  {
    "objectID": "05-linear.html#linear-algebra",
    "href": "05-linear.html#linear-algebra",
    "title": "5  Linear algebra and optimization",
    "section": "",
    "text": "5.1.1 Matrix multiplications\nRecall from Section 4.1.1 that for an m \\times n matrix A and m \\times 1 column vector x, the command A*x gives a matrix in which every column of A gets pointwise multiplied by the column vector x, that is,\n\\begin{align*}\nA*x  = &  \\left[\n\\begin{matrix}\na_{00}  & a_{01} & \\dots & a_{0(n-1)} \\\\\na_{10}  & a_{11} & \\dots & a_{1(n-1)} \\\\\n\\vdots  & \\vdots & \\ddots & \\vdots \\\\\na_{(m-1)0}  & a_{(m-1)1}  & \\dots & a_{(m-1)(n-1)}\n\\end{matrix}\n\\right]*\\left[\n\\begin{matrix}\nx_{0} \\\\ x_{1} \\\\ \\vdots \\\\ x_{(m-1)} \\\\\n\\end{matrix}\n\\right] \\\\\n= &\n\\left[\n\\begin{matrix}\na_{00} \\cdot x_0 & a_{01} \\cdot  x_0& \\dots & a_{0(n-1)} \\cdot  x_0\\\\\na_{10} \\cdot  x_1 & a_{11} \\cdot  x_1& \\dots & a_{1(n-1)} \\cdot  x_1\\\\\n\\vdots &  \\vdots& \\ddots & \\vdots \\\\\na_{(m-1)0} \\cdot  x_{m-1} & a_{(m-1)1} \\cdot  x_{m-1} & \\dots & a_{(m-1)(n-1)} \\cdot  x_{m-1}\n\\end{matrix}\n\\right]\n\\end{align*}\n\nA = np.array([\n[1,2],\n[3,4]])\n\nx = np.array([1,5])\nx = x[:,None] # Turn x into (2,1) shaped column vector\n\nprint('A = \\n', A)\nprint('x = \\n', x)\nprint('A*x = \\n', A*x)\n\nA = \n [[1 2]\n [3 4]]\nx = \n [[1]\n [5]]\nA*x = \n [[ 1  2]\n [15 20]]\n\n\nIn the linear algebra sense, the multiplication Ax gives an m \\times 1 column vector defined by\n\\begin{align*}\nAx = &  \\left[\n\\begin{matrix}\na_{00}  & a_{01} & \\dots & a_{0(n-1)} \\\\\na_{10}  & a_{11} & \\dots & a_{1(n-1)} \\\\\n\\vdots  & \\vdots & \\ddots & \\vdots\\\\\na_{(m-1)0}  & a_{(m-1)1}  & \\dots & a_{(m-1)(n-1)}\n\\end{matrix}\n\\right]\\left[\n\\begin{matrix}\nx_{0} \\\\ x_{1} \\\\ \\vdots \\\\ x_{(m-1)} \\\\\n\\end{matrix}\n\\right] \\\\\n= &\n\\left[\n\\begin{matrix}\na_{00}x_0 + a_{01}x_1 + \\dots + a_{0(n-1)}x_{n-1}\\\\\na_{10}x_0 + a_{11}x_1 + \\dots + a_{1(n-1)}x_{n-1}\\\\\n\\vdots  \\\\\na_{(m-1)0}x_0 + a_{(m-1)1}x_1 + \\dots + a_{(m-1)(n-1)}x_{n-1}\\\\\n\\end{matrix}\n\\right]\n\\end{align*}\nThis can be achieved in Python with the @ (‘at’) operator, that is, by writing A @ x (the white spaces are not needed; they are included here for readability).\n\nprint('A = \\n', A)\nprint('x = \\n', x)\n\n\nprint('Ax = \\n', A @ x)\n\nA = \n [[1 2]\n [3 4]]\nx = \n [[1]\n [5]]\nAx = \n [[11]\n [23]]\n\n\nIf we talk about matrix multiplication, it will always be clear from context whether we mean A*x or A @ x.\nWe can also use @ to multiply a k \\times m and m \\times n matrix with each other in the linear algebra sense.\n\nA = np.array([\n[1,2],\n[3,4],\n[3,7]])\n\nB = np.array([\n[2,5,1,7],\n[3,4,-1,8]])\n\n# Note that k = 3, m = 2, n = 4\nprint('AB = \\n',A @ B)\n\nAB = \n [[ 8 13 -1 23]\n [18 31 -1 53]\n [27 43 -4 77]]\n\n\nA special case of this is we we multiple a colunm vector\n\nx = \\left[\\begin{matrix} x_0\\\\ x_1 \\\\ \\vdots \\\\x_{n-1} \\end{matrix} \\right]\n\nwith its transpose (being a row vector) resulting in a matrix that contains x_ix_j on position (i,j).\n\nx = np.array([\n[1],\n[2],\n[4]])\n\nprint('xx^T = \\n', x @ x.T)\n\nxx^T = \n [[ 1  2  4]\n [ 2  4  8]\n [ 4  8 16]]\n\n\n\n\n5.1.2 Matrix properties\nUsing the linalg subpackage from NumPy, we can compute various well-known properties of a matrix (that you should recall from your Linear Algebra course).\n\nlinalg.matrix_rank(A): Computes rank of matrix A.\nlinalg.det(A): Computes determinant of square A.\nlinalg.eig(A): Computes eigenvalues and (right) eigenvectors of matrix A, i.e., values \\lambda that satisfy Av = \\lambda v for some (eigen)vector v.\nlinalg.inv(A): Computes the inverse matrix A^{-1} of A, that is, the matrix that satisfies A^{-1}A = AA^{-1} = I, where I is the identity matrix.\nlinalg.norm(A): Computes the norm of matrix (or vector).\n\nWe can access these function with the syntac np.linalg.function_name(A).\nFinally, there is also the trace function trace(A) in NumPy that computes the trace of A, i.e., the sum of the elements on the diagonal. This function is implemented directly in NumPy, so you don’t have to go to the subpackage linalg first.\nLet us look at some examples of these commands.\n\nA = np.array([\n[1,2],\n[3,4]])\n\n\n# Rank of A\nprint('Rank of A: ', np.linalg.matrix_rank(A))\n\nRank of A:  2\n\n\n\n# Determinant of A\nprint('Determinant of A: ', np.linalg.det(A))\n\nDeterminant of A:  -2.0000000000000004\n\n\n\n# Trace of A\nprint('Trace of A: ', np.trace(A))\n\nTrace of A:  5\n\n\n\n# Inverse of A\nprint('Inverse of A: \\n', np.linalg.inv(A))\n\nInverse of A: \n [[-2.   1. ]\n [ 1.5 -0.5]]\n\n\nThe function linalg.eig() is special in that it does not output one, but two arrays.\nThe first array is one-dimensional and contains the eigenvalues [\\lambda_0,\\dots,\\lambda_{n-1}] of A; the second array is two-dimensional, and contains the corresponding eigenvectors v^1,\\dots,v^n as columns of the matrix. The eigenvalues and eigenvectors are paired in the sense that Av^i = \\lambda_iv^i for i = 0,\\dots,n-1.\n\n# Eigenvalues and eigenvectors of A\nlambdas, V = np.linalg.eig(A)\n\nprint('Eigenvalues of A: \\n', lambdas)\nprint('Matrix with eigenvectors of A: \\n', V)\n\nEigenvalues of A: \n [-0.37228132  5.37228132]\nMatrix with eigenvectors of A: \n [[-0.82456484 -0.41597356]\n [ 0.56576746 -0.90937671]]\n\n\nYou can output only the eigenvalues or the eigenvectors by suppressing the other output argment with _.\n\n# Only eigenvalues of A\nlambdas, _ = np.linalg.eig(A)\n\n# Only eigenvectors of A\n_, V = np.linalg.eig(A)\n\nIf you want to recall how you can handle multiple outputs, and suppress the ones that your are not interested, have a look at Appendix B.\nLet us check that the eigenvalues and eigenvectors indeed satsify Av^i = \\lambda_iv^i for i = 0,1.\n\nv0 = V[:,0] \nv1 = V[:,1]\n\nprint('Verify first eigenvector:', A @ v0 - lambdas[0]*v0)\nprint('Verify second eigenvector:', A @ v1 - lambdas[1]*v1)\n\nVerify first eigenvector: [0.00000000e+00 5.55111512e-17]\nVerify second eigenvector: [0. 0.]\n\n\nThe function linalg.norm(A) computes the L^2-norm of a matrix A = (a_{ij})_{i = 1,\\dots,m, j = 1,\\dots,n}, also known as the Frobenius norm. It is defined as\n\n||A||_{\\text{F}} = \\sqrt{\\sum_{i=0}^{m-1} \\sum_{j = 0}^{n-1} a_{ij}^2 }.\n\nIf you apply the function two a row or column vector x = [x_0,\\dots,x_{n-1}], you get the usual L^2-norm defined as\n\n||x||_{2} = \\sqrt{\\sum_{i=0}^{n-1} x_i^2 }.\n\nYou can also use this function in a vectorized manner. For example, if you want to compute the L^2-norm of every row in a matrix, you can use the axis keyword argument.\n\nA = np.array([\n[1,2],\n[3,4],\n[5,6]])\n\nrow_norms = np.linalg.norm(A,axis=1)\n\nprint(row_norms)\n\n[2.23606798 5.         7.81024968]\n\n\n\n\n5.1.3 Equation solving\nFor a given m \\times n matrix A = (a_{ij}) and m \\times 1 column vector b = [b_0,\\dots,b_{m-1}]^T, perhaps the most important question in linear algebra is to compute an x = [x_0,\\dots,x_{n-1}]^T that satisfies Ax = b, i.e., the linear systems of equalities \n\\begin{array}{rrrrcrrrl}\na_{00}x_0 &+& a_{01}x_1 &+& \\dots &+& a_{0(n-1)}x_{n-1} &=& b_0 \\\\\na_{10}x_0 &+& a_{11}x_1 &+& \\dots &+& a_{1(n-1)}x_{n-1} &=& b_1 \\\\\n&&&& \\vdots &&&& \\\\\na_{(m-1)0}x_0 &+& a_{(m-1)1}x_1 &+& \\dots &+& a_{(m-1)(n-1)}x_{n-1} &=& b_{m-1}\n\\end{array}.\n\nIf A is a square, invertible matrix then this can be done with linalg.solve(A,b). This gives the unique solution x = A^{-1}b.\n\nA = np.array([\n[1,2],\n[3,4]])\n\nb = np.array([[1],[4]])\n\nprint('Solution to Ax = b: \\n', np.linalg.solve(A,b))\n\nSolution to Ax = b: \n [[ 2. ]\n [-0.5]]\n\n\nIn fact, you can compute x directly as x = A^{-1}b using the inverse of A that we have seen earlier.\n\nprint('Solution to Ax = b: \\n', np.linalg.inv(A) @ b)\n\nSolution to Ax = b: \n [[ 2. ]\n [-0.5]]\n\n\nIf the system is overdetermined, then there is not necessarily a unique solution. This can happen when there are more constraints than variables, i.e., when m &gt; n. In this case, we can find a solution x that is approximately optimal with the least squares method. It finds a solution x that solves the (non-linear) problem \n\\min_x ||Ax - b||_2.\n The least squares method can be executed with linalg.lstsq(A,b); we will see this method in the next chapter, when we consider non-linear optimization problems. This function can also be used to solve underdetermined systems, where n &gt; m.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Linear algebra and optimization</span>"
    ]
  },
  {
    "objectID": "05-linear.html#linear-optimization",
    "href": "05-linear.html#linear-optimization",
    "title": "5  Linear algebra and optimization",
    "section": "5.2 Linear optimization",
    "text": "5.2 Linear optimization\nRecall that in a linear optimization problem the goal is to compute a vector x = [x_0,\\dots,x_{n-1}] of decision variables that maximizes, or minimizes, a linear objective function subject to a collection of linear constraints, which can either be a \\leq, \\geq or = constraint.\n\nIn this section we will consider a general linear optimization problem of the form \n\\begin{array}{ll}\n\\min & c^Tx \\\\\n{\\rm s.t.} & Ax = b \\\\\n& Wx \\leq z \\\\\n& \\ell \\leq x \\leq u\n\\end{array}\n where c, \\ell, u \\in \\mathbb{R}^n, A \\in \\mathbb{R}^{m \\times n}, b \\in \\mathbb{R}^m, U \\in \\mathbb{R}^{k \\times n}, and z \\in \\mathbb{R}^k are the input data, or input parameters.\nWritten out this means we have a system with m equality constraints, k inequality constraints and upper and lower bounds on the decision variables.\n\n\\begin{array}{rrrcrrlll}\n\\min &  c_1 x_1 &+& \\cdots& + & c_nx_n& & & \\\\\n{\\rm s.t.} &  a_{01}x_0& +& \\cdots& +& a_{0(n-1)} x_{n-1} &= &b_0 &\\\\\n& & & \\vdots & & & & \\\\\n&  a_{(m-1)1}x_0& +& \\cdots& +& a_{(m-1)(n-1)} x_{n-1} &= &b_{m-1}& \\\\\n& w_{01}x_0& +& \\cdots& +& w_{0(n-1)} x_{n-1} &\\leq &z_0 &\\\\\n&  & & \\vdots & & & & &\\\\\n&  w_{(k-1)1}x_0& +& \\cdots& +& w_{(k-1)(n-1)} x_{n-1} &\\leq &z_{k-1} & \\\\\n\\ell_0 \\leq & x_0  &   && &  &  \\leq & u_0&  \\\\\n&   &   & \\ddots & &  &   & &  \\\\\n\\ell_{n-1} \\leq &   &   & & &  x_{n-1} &  \\leq & u_{n-1}&  \\\\\n\\end{array}\n\nYou can model a \\geq constraint by multiplying it with -1, so that it turns into a \\leq constraint.\nIf, in addition, we require that x_i \\in \\mathbb{N} for i = 1,\\dots,n, i.e., that the variables are integral, then we call the above problem an integer linear optimization problem.\nWe will look at two packages that can be used to solve (integer) linear optimization problems. The difference is that the first package linprog allows us to explicitly input the data c, A, B, \\ell and u, whereas the second package pulp allows us to define constraints one-by-one. The latter is more convenient if the input data his not given explicitly.\n\n5.2.1 Explicit input data\nIf the input data is given explicitly, we can solve linear optimization problems quickly with the linprog module, which is part of the optimize package of SciPy. We will see more functionality of SciPy in later chapters of this book.\nWe can import linprog as follows:\n\nfrom scipy.optimize import linprog\n\nThis package is suitable for solving problem of the general form above. We will implement the following example:\n\n\\begin{array}{lrrrrrrl}\n\\text{max } & z  = & 15x_{1} &+ &20x_{2} & & & \\\\\n\\text{s.t.} & & 2x_1 &+ & 2x_2& \\leq & 8\\frac{1}{2} & \\\\\n& & x_1 &+ & 2x_2& \\leq & 6 & \\\\\n&& 12x_1 &+ & 17x_2& = & 51 & \\\\  \n& &x_1 & &  & \\geq & 0 & \\\\\n&  && & x_2 & \\geq & 0 &\n\\end{array}\n\nBecause linprog works with explicitly input data, we first define these. We define all the input data as NumPy arrays, but you can actually also use plain lists for this.\nNote that we multiply the objective function c with -1, so that our maximization problem turns into a minimization problem.\n\n## Define input data\n\n# Coefficients of the objective function\nc = np.array([-15, -20])  # Minimize -15x1 - 20x2\n\n# Coefficients of the equality constraints (Ax = b)\nA = np.array([[12, 17]]) # 12x1 + 17x2 = 51\n\nb = np.array([51])\n\n# Coefficients of the inequality constraints (Ux &lt;= z)\nU = np.array([\n[2, 2],  # 2x1 + 2x2 &lt;= 8.5\n[1, 2]]) # x1 + 2x2 &lt;= 6\n\nz = np.array([[8.5], [6]])\n\nThe bounds on x_i have to be inputted as tuple (\\ell_i,u_i). If the lower or upper bound is not present, meaning either \\ell_i = -\\infty or u_i = + \\infty, you can replace the entry with None.\n\n# Bounds for the variables x1 and x2 (l = 0, u = infinity)\nx1_bounds = (0, None)  # x1 &gt;= 0\nx2_bounds = (0, None)  # x2 &gt;= 0\n\nWe can solve the problem with linprogr() It takes input arguments\n\nc : The vector with objective function coefficients\nA_eq : The constraint matrix for the equality constraints\nb_eq : The right hand side vector of the equality constraints\nA_ub : The constraint matrix for the inequality constraints\nb_ub : The right hand side vector of the inequality constraints\nbounds : List of tuples with each tuple having the upper and lower bound for the corresponding variable\n\nNote that A_eq and b_eq can be left out as input arguments if there are no equality constraints; the same holds for A_ub and b_ub.\n\n# Solve the linear programming problem\n# (You can use \\ to continue command on next line)\nresult = linprog(c, A_eq=A, b_eq= b,  \\\n                    A_ub=U, b_ub=z, \\\n                    bounds=[x1_bounds, x2_bounds])\n\nThe result variable contains various aspects of the solution. The two most important for us are\n\nresult.x : The optimal solution x\nresult.fun : The function value attained by the the optimal solution.\n\n\n# Output the results\nprint('The problem is solved by', result.x, \\\n      'with objective function value', result.fun)\n\nThe problem is solved by [4.25 0.  ] with objective function value -63.75\n\n\nIf we want to solution to be integral, we add the input argument integrality=1. See the documentation to read about this and to find more options.\n\n# Solve the integer linear optimization problem\n# (You can use \\ to continue command on next line)\nresult_integral = linprog(c, A_eq=A, b_eq= b,  \\\n                    A_ub=U, b_ub=z, \\\n                    bounds=[x1_bounds, x2_bounds], \\\n                    integrality=1)\n                    \n# Output the results\nprint('The problem is solved by', result_integral.x, \\\n      'with objective function value', result_integral.fun)\n\nThe problem is solved by [0. 3.] with objective function value -60.0\n\n\nThe complete code of this section can be found below.\n\n\nShow complete code for linear optimization with linprog\nimport numpy as np\nfrom scipy.optimize import linprog\n\n## Define input data\n\n# Coefficients of the objective function\nc = np.array([-15, -20])  # Minimize -15x1 - 20x2\n\n# Coefficients of the equality constraints (Ax = b)\nA = np.array([[12, 17]]) # 12x1 + 17x2 = 51\n\nb = np.array([51])\n\n# Coefficients of the inequality constraints (Ux &lt;= z)\nU = np.array([\n[2, 2],  # 2x1 + 2x2 &lt;= 8.5\n[1, 2]]) # x1 + 2x2 &lt;= 6\n\nz = np.array([[8.5], [6]])\n\n## Bounds for the variables x1 and x2 (l = 0, u = infinity)\nx1_bounds = (0, None)  # x1 &gt;= 0\nx2_bounds = (0, None)  # x2 &gt;= 0\n\n## Solve the linear optimization problem\n## (You can use \\ to continue command on next line)\nresult = linprog(c, A_eq=A, b_eq= b,  \\\n                    A_ub=U, b_ub=z, \\\n                    bounds=[x1_bounds, x2_bounds])\n\n# Output the results\nprint('The linear optimization problem is solved by', result.x, \\\n      'with objective function value', result.fun)\n                    \n##################################                \n## With integrality constraints ##\n##################################  \n\n# Solve the problem\nresult_integral = linprog(c, A_eq=A, b_eq= b,  \\\n                    A_ub=U, b_ub=z, \\\n                    bounds=[x1_bounds, x2_bounds], \\\n                    integrality=1)\n                    \n# Output the results\nprint('The integer linear optimization problem is solved by', result_integral.x, \\\n      'with objective function value', result_integral.fun)\n\n\n\n\n5.2.2 Implicit input data\nIf the constraints are not given explicitly, creating the input data matrices like A and U can be quite tedious. In this case, it works better to define the constraints directly, based on the given problem description.\nIn this section we will consider the maximum weight bipartite matching problem. We are given a (complete) bipartite graph G = (V,W,E) with node sets V = \\{0,\\dots,n-1\\} and W = \\{0,\\dots,n-1\\} and edges ij \\in E = \\{ab : a \\in V, b \\in W\\} connecting the nodes i \\in V with j \\in W. Every such edge has a weight w_{ij}. We want to match up every node in V with a node in W so that the total summed weight of the selected edges is maximal.\nWe introduce (binary) decision variables x_{ij} with the interpretation that x_{ij} = 1 if i and j get matched, and x_{ij} = 0 otherwise. The constraints then mean that every node i \\in V should get matched up with precisely one j \\in W and vice versa.\n\n\\begin{array}{lllll}\n\\max & \\displaystyle \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} w_{ij}x_{ij} & & \\\\\n\\rm{s.t. } & \\displaystyle \\sum_{i=0}^{n-1} x_{ij} & =& 1 & \\text{for } j = 0,\\dots,n-1 \\\\\n&\\displaystyle  \\sum_{j=0}^{n-1} x_{ij} & = &1 & \\text{for } i = 0,\\dots,n-1\\\\\n& x_{ij}  &\\geq & 0 & \\text{for all } i,j = 0,\\dots,n-1 \\\\\n& x_{ij} & \\in & \\{0,1\\} & \\text{for all } i,j = 0,\\dots,n-1\n\\end{array}\n\nIn fact, the last conditions defining the decisions variables to be binary, are redundant: If we leave them out then the optimal solution that is found will satisfy them regardless (you might have seen this in a Combinatorial Optimization course). For now, we will ignore this mathematical fact, and define the decision variables as binary variables.\nDefining the constraint matrix explicitly is quite a hassle, and given that many of its entries are zero, it is not very efficient for Python to store it explicitly, so using linprog here is not very convenient.\nInstead, in this section we will use the pulp package to solve this problem.\n\nimport pulp\n\nWe create some input data (weights) for the problem that we are going to build.\n\n# Size of the node sets\nn = 4\n\n# Weights of the edges ij\nw = np.arange(1,n**2+1).reshape(n,n)\n\nprint(w) \n\n[[ 1  2  3  4]\n [ 5  6  7  8]\n [ 9 10 11 12]\n [13 14 15 16]]\n\n\nProblem instantiation. We first initialize the problem object that we want to solve with LpProblem() that takes as input:\n\nProblem name: String variable\nProblem type: Maximization (pulp.LpMaximize), or minimization (pulp.LpMinimize).\n\n\nprob = pulp.LpProblem(\"Weighted_Bipartite_Matching\", pulp.LpMaximize)\n\nAs opposed to linprog we need to explicitly instantiate the decision variables, so that we can use them later to add constraints to our problem.\nDecision variables. A decision variable y can be instantiated with LpVariable() that takes as input\n\nVariable name: String being name of variable\nVariable category: Keyword argument cat being Binary, Integer or Continuous (default if cat is not specified).\n\n\npulp.LpVariable('y',cat='Binary')\n\nTo initiate our decision variables we need to loop over the indices i and j, which can be done as follows. Note that the syntax f\"y_{i}_{j}\" allows us to incorporate/format the loop indices i and j into the variable name (which is a string).\n\nx = np.zeros((n,n), dtype=object) # Data type of variable is 'object'\nfor i in range(n):\n    for j in range(n):\n        x[i,j] = pulp.LpVariable(f\"x_{i}_{j}\", cat='Binary')      \n\nThis can be done more compactly using list comprehension, which is a quick alternative for doing the for-loops explicitly. Avoiding for-loops altogether here is not possible, because variables cannot be generated in a vectorized manner if we want to give them all a separate name.\n\n# With list comprehension\nx = np.array([[pulp.LpVariable(f\"x_{i}_{j}\", cat='Binary') \\\n               for i in range(n)] for j in range(n)])\n\nIn both cases we have created an n \\times n NumPy array whose elements are decision variables x_{ij}.\n\n# Print names of decision variables\nprint(x)\n\n[[x_0_0 x_0_1 x_0_2 x_0_3]\n [x_1_0 x_1_1 x_1_2 x_1_3]\n [x_2_0 x_2_1 x_2_2 x_2_3]\n [x_3_0 x_3_1 x_3_2 x_3_3]]\n\n\nWe will use these variables to define the objective function and constraints.\nObjective function. We next construct the objective function \n\\begin{array}{lllll}\n\\max & \\displaystyle \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} w_{ij}x_{ij} & &\n\\end{array}\n Because both the weight matrix w and the decision variables x are stored in NumPy arrays, we can do a pointwise multiplication of these arrays, and sum up the elements of the resulting array, to get the objective.\nSumming up decision variables in arrays, in our case the array w*x, can be done using lpSum() within Pulp. To add the objective to the problem, and later constraints, we use the syntax prob += [objective] where [objective] contains the objective function expresssion in terms of the decision variables that we instantiated. You should think of the syntax += as adding something to the instantiated problem prob.\n\nprob += pulp.lpSum(w*x)  \n\nNote that we write lpSum() and not LpSum() with a capital L. This has to do with the fact that lpSum() is a function, whereas LpProblem and LpVariable are classes (that have different naming conventions in Python modules).\n\n# Print objective function\nprint(prob.objective)\n\nx_0_0 + 2*x_0_1 + 3*x_0_2 + 4*x_0_3 + 5*x_1_0 + 6*x_1_1 + 7*x_1_2 + 8*x_1_3 + 9*x_2_0 + 10*x_2_1 + 11*x_2_2 + 12*x_2_3 + 13*x_3_0 + 14*x_3_1 + 15*x_3_2 + 16*x_3_3\n\n\n\nConstraints. Finally, we add the constraints \n\\begin{array}{lllll}\n& \\displaystyle \\sum_{i=0}^{n-1} x_{ij} & =& 1 & \\text{for } j = 0,\\dots,n-1 \\\\\n&\\displaystyle  \\sum_{j=0}^{n-1} x_{ij} & = &1 & \\text{for } i = 0,\\dots,n-1\n\\end{array}\n to the problem, which can also be done with the prob += [constraint] syntax, where [constraint] is the constraint we want to add. We can add our constraints as follows.\n\nfor j in range(n):\n    prob += pulp.lpSum([x[i,j] for i in range(n)]) == 1\n    \nfor i in range(n):\n    prob += pulp.lpSum([x[i,j] for j in range(n)]) == 1\n\nTo print the constraints, we need to realize that they are stored in an (ordered) dictionary. We can print the keys and values of this dictipnary as follows.\n\n# Print constraints\nfor key, value in prob.constraints.items():\n    print(f\"{key}: {value}\")\n\n_C1: x_0_0 + x_1_0 + x_2_0 + x_3_0 = 1\n_C2: x_0_1 + x_1_1 + x_2_1 + x_3_1 = 1\n_C3: x_0_2 + x_1_2 + x_2_2 + x_3_2 = 1\n_C4: x_0_3 + x_1_3 + x_2_3 + x_3_3 = 1\n_C5: x_0_0 + x_0_1 + x_0_2 + x_0_3 = 1\n_C6: x_1_0 + x_1_1 + x_1_2 + x_1_3 = 1\n_C7: x_2_0 + x_2_1 + x_2_2 + x_2_3 = 1\n_C8: x_3_0 + x_3_1 + x_3_2 + x_3_3 = 1\n\n\n\n Solving the problem. We solve the problem with the solve() function.\nWe can access the values of the objective function and the variables using pulp.value(). The objective function of the problem is stored in prob.objective, and so its value in the optimized model can be accessed with pulp.value(prob.objective).\nWe want to represent the optial matching nicely in a binary matrix. Unfortunately, printing the values of the optimized model is difficult to do without for-loops since the function pulp.value(x[i,j]) that returns the value of variable x_{ij} only works for numbers and not lists or arrays.\n\n# Solve the problem\nprob.solve()\n\n# Store the results in matrix 'matching'\nmatching = np.zeros((n,n), dtype=int)\nfor i in range(n):\n    for j in range(n):\n        matching[i,j] = pulp.value(x[i,j])\n\n# Print solution        \nprint(\"The optimal matching is: \\n\", matching)\nprint(f\"Optimal value of the objective function: {pulp.value(prob.objective)}\")\n\nThe optimal matching is: \n [[1 0 0 0]\n [0 1 0 0]\n [0 0 0 1]\n [0 0 1 0]]\nOptimal value of the objective function: 34.0\n\n\nThe complete code of this section can be found below.\n\n\nShow complete code for linear optimization with Pulp\nimport pulp\n\n# Size of the node sets (input data)\nn = 4\n\n# Weights of the edges ij (input data)\nw = np.arange(1,n**2+1).reshape(n,n)\n\n# Instantiate problem\nprob = pulp.LpProblem(\"Weighted_Bipartite_Matching\", pulp.LpMaximize)\n\n# Instantiate decision variables and store in NumPy array\nx = np.array([[pulp.LpVariable(f\"x_{i}_{j}\", cat='Binary') \\\n               for i in range(n)] for j in range(n)])\n\n# Set objective function\nprob += pulp.lpSum(w*x)  \n\n# Set constraints\nfor j in range(n):\n    prob += pulp.lpSum([x[i,j] for i in range(n)]) == 1\n    \nfor i in range(n):\n    prob += pulp.lpSum([x[i,j] for j in range(n)]) == 1\n    \n# Store the results in matrix 'matching'\nmatching = np.zeros((n,n), dtype=int)\nfor i in range(n):\n    for j in range(n):\n        matching[i,j] = pulp.value(x[i,j])\n\n# Print solution and objective value\nprint(\"The optimal matching is: \\n\", matching)\nprint(f\"Optimal value of the objective function: {pulp.value(prob.objective)}\")",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Linear algebra and optimization</span>"
    ]
  },
  {
    "objectID": "A-errata.html",
    "href": "A-errata.html",
    "title": "Appendix A — Corrections",
    "section": "",
    "text": "A.1 Section 4.3.1",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Corrections</span>"
    ]
  },
  {
    "objectID": "A-errata.html#section-4.3.1",
    "href": "A-errata.html#section-4.3.1",
    "title": "Appendix A — Corrections",
    "section": "",
    "text": "Corrected the explanation of np.argsort().",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Corrections</span>"
    ]
  },
  {
    "objectID": "A-errata.html#section-3.5",
    "href": "A-errata.html#section-3.5",
    "title": "Appendix A — Corrections",
    "section": "A.2 Section 3.5",
    "text": "A.2 Section 3.5\n\nCorrected M_repeat = np.tile(M,3) by M_repeat = np.repeat(M,3)\nCorrected vstack(a,b) to vstack((a,b)).\nCorrected hstack(a,b) to hstack((a,b)).",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Corrections</span>"
    ]
  },
  {
    "objectID": "B-function-basics.html",
    "href": "B-function-basics.html",
    "title": "Appendix B — Function basics",
    "section": "",
    "text": "B.1 Getting specific output arguments\nSuppose we have a function that takes two inputs, and yields four outputs.\ndef f(a,b):\n    return a + b, a - b, a*b, a/b\n\na = 5\nb = 3\nThere are various ways to get one or more specific outputs from Python.\n# Returns all output variables in tuple\noutput = f(a,b)\n\nprint(output)\n\n(8, 2, 15, 1.6666666666666667)\n# Store outputs in variables w, x, y and z\nw, x, y, z = f(a,b)\n\nprint(w, x, y, z)\n\n8 2 15 1.6666666666666667\nWe can suppress one or more output arguments using _.\n# Only store first and last output\nw, _, _, z = f(a,b)\n\nprint(w, z)\n\n8 1.6666666666666667\nIf we only want the first output, and suppress the other ones, we can use *_\n# Only store first output\nx, *_ = f(a,b) # This is the same as x, _, _, _ = f(a,b)\n\nprint(x)\n\n8\nIf we only want the first two outputs, and suppress the remaining ones, we can do something similar.\n# Only store first output\nw, x, *_ = f(a,b) # This is the same as w, x, _, _ = f(a,b)\n\nprint(w,x)\n\n8 2\nIf we only want the last output, we can do the following.\n# Only store last output\n*_, z = f(a,b) # This is the same as _, _, _, z = f(a,b)\n\nprint(z)\n\n1.6666666666666667\nAlso here, if we would like the last two outputs, we can do the following.\n# Only store last output\n*_, y, z = f(a,b) # This is the same as _, _, y, z = f(a,b)\n\nprint(y,z)\n\n15 1.6666666666666667",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Function basics</span>"
    ]
  }
]