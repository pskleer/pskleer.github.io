[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python for Econometrics and Operations Research",
    "section": "",
    "text": "1 Welcome\nWelcome to the online “book” that serves as an introduction to the programming language Python, that you will see in various courses throughout the Econometrics and Operations Research (EOR) bachelor program.\nThe first part of this book is used for the “Python crash course” announced during the course Linear Algebra. The crash course consists of two (recommended) lectures that will form a useful basis for various programming assignments in the EOR bachelor program, including the assignment of the (mandatory) course Linear Optimization in the second quartile of the first year.\nThe two crash course lectures (taught only in English) are outlined below, including links to the lecture materials. To program in Python, we will use the Jupyter Notebook application in which we can execute Python code.\nBefore we jump into coding with Python, we will start by discussing what programming is at the most basic level and motivating why we are learning how to code in Python in the first place.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome</span>"
    ]
  },
  {
    "objectID": "index.html#what-is-a-programming-language",
    "href": "index.html#what-is-a-programming-language",
    "title": "Python for Econometrics and Operations Research",
    "section": "1.1 What is a programming language?",
    "text": "1.1 What is a programming language?\nWithout getting into complicated details, a programming language is a way to communicate to a computer, via written text, tasks or operations that you want it to carry out. This is very different to how we often usually interact with a computer, which often involves pointing and clicking on different buttons and menus with your mouse.\nIn the EOR bachelor program, the goal is often to tell a computer to carry out complicated numerical computations or to visualize numerical data. To some extent, you have already done this in high school using a graphing calculator. In fact, everything that your graphing calculator can do, you can also do with Python, but the advantage of Python is that it can also handle much more complicated tasks.\nTo use Python in a correct fashion, it is important that you understand the grammar, i.e., “syntax”, of the Python programming language. When humans speak to each other and someone makes a grammar mistake, it usually isn’t a big deal. We usually know what they mean. But if you make a “syntax error”, i.e, grammar mistake in a programming language, it won’t understand what you mean. The computer will throw an error.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome</span>"
    ]
  },
  {
    "objectID": "index.html#why-python",
    "href": "index.html#why-python",
    "title": "Python for Econometrics and Operations Research",
    "section": "1.2 Why Python?",
    "text": "1.2 Why Python?\nThere are many different programming languages out there: C, C++, C#, Java, JavaScript, R, Julia, Stata, MATLAB, Fortran, Ruby, Perl, Rust, Go, Lua, Swift - the list goes on. So why should we learn Python over these other alternatives?\nThe best programming language depends on the task you want to accomplish. Are you building a website, writing computer software, creating a game, or analyzing mathematical data? While many languages could perform all of these tasks, some languages excel in some of them.\nPython is by far the most popular programming language when it comes to “data science” tasks, that you will often encounter in the EOR bachelor program. It is also often used in web development, creating desktop applications and games, and for scientific computations. It is therefore a very versatile programming language that can complete a very wide range of tasks.\nPython is also completely free and open source and can run on all common operating systems. This means you can share your code with anyone and they will be able to run it, no matter what computer they are on or where they are in the world.\nThere is also a very large active community that creates packages to do a wide-range of operations, keeping Python up to date with the latest developments. For example, excellent community help is available at Stackoverflow, so if you Google how to do something in Python most likely that question has already been answered on Stackoverflow. Funnily enough, a key skill to develop with programming is how to formulate your question into Google to land on the right Stackoverflow page.\nMore recently, “large-language” models like ChatGPT have become a very useful resource for Python. ChatGPT can write excellent Python code and also explains all the steps it takes, so we encourage you to use it as a tool to help you when you are stuck.\nYou should keep in mind though, that throughout the bachelor program, you will not always be allowed to use tools like ChatGPT. It is also important that you understand basic programming concepts to catch errors that AI might introduce (do not forget that LLMs are merely predicting text and not “consciously” writing a script), or to help improve your AI-prompt writing skills.\nThese days employers are increasingly looking to hire people with programming skills. Knowing how to program in Python - one of the most commonly used languages by companies - is therefore a very valuable addition to your CV.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome</span>"
    ]
  },
  {
    "objectID": "02-installation.html",
    "href": "02-installation.html",
    "title": "2  Software",
    "section": "",
    "text": "2.1 Installing Anaconda\nThe easiest way to install Python and Jupyter Notebook is by installing Anaconda, which is a software package that includes Python, Jupyter Notebook, and other software applications. You can install Anaconda by visiting https://www.anaconda.com/download.\nYou should see this page:\nYou should click the “Skip registration” button (although feel free to register if you like). You will then see the following page:\nYou should then click on the “Download” button. Mac users will see a Mac logo instead.\nAfter downloading the file, click on it to install it. Follow the installation wizard and keep all the default options during installation.\nAfter installation you will see a number of new applications on your computer. You can see all applications that were installed using Anaconda Navigator. You can open the navigator by searching for it in the Start menu (on Windows).\nWe highlight two applications:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Software</span>"
    ]
  },
  {
    "objectID": "02-installation.html#installing-anaconda",
    "href": "02-installation.html#installing-anaconda",
    "title": "2  Software",
    "section": "",
    "text": "Anaconda Download Page\n\n\n\n\n\n\nAnaconda Download Page\n\n\n\n\n\n\n\n\nAnaconda Navigator\n\n\n\n\nJupyter Notebook. This is a web application that allows you to write a notebook (like a report) with text and Python code snippets with output. We will learn how to use this application later on.\nSpyder/VS Code. These are computer applications that allows you to write Python scripts and execute them to see the output. Such an application is called an Integrated Desktop Environment (IDE).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Software</span>"
    ]
  },
  {
    "objectID": "02-installation.html#sec-jn",
    "href": "02-installation.html#sec-jn",
    "title": "2  Software",
    "section": "2.2 Jupyter Notebook",
    "text": "2.2 Jupyter Notebook\nYou can open the Jupyter Notebook application either by pressing ‘Launch’ in the Anaconda Navigator, or you can search for the application directly on your (university) computer via the Start menu.\nThe application will open as a tab in a web browser, and you should then see a list of folders.\n\n\n\nJupyter Notebook application\n\n\n\n2.2.1 Creating new notebook\nYou can navigate to a folder and then create a new notebook by clicking on ‘New’ in the top-right and then selecting ‘Python 3 (ipykernel)’ under Notebook.\n\n\n\nCreating notebook\n\n\nThe new notebook will open in another tab and is stored in the folder in which you created it, typically under the name ‘Untitled.ipynb’. You can change the name of the file either in the folder in which you stored it, or via File -&gt; Rename in the top-left corner. You should see the empty notebook as below.\n\n\n\nNew notebook\n\n\nIn the bar you can type Python code. Let us execute our first code, which is a simple calculation 1 + 1. To find 1+1 in Python, we can use the command 1+1, similar to how we would do it in Excel or in the Google search engine. Let’s try this out. Type 1+1 in the code bar and click \\blacktriangleright Run  (or hit Shift + Enter on your keyboard). We will see the output 2 on the next line next to a red Out [1]:\n\n\n\nFirst Python code\n\n\nThe red Out [1] means this is the output from the code snippet In [1] executed in this notebook. If we continue typing code in the second bar, it will be called In [2] and its output Out [2]. However, the same happens if we would re-run the first code snippet with 1+1: It will also be called In [2] and its output Out [2]. The index keeps track of how many code snippets have been executed in the notebook.\n\n\n2.2.2 Opening existing notebook\nThe extension of a Jupyter Notebook file is .ipynb and sometimes denoted as Jupyter Source File. If you have stored such a file on your computer, you can open in it Jupyter Notebook as follows:\n\nOpen Jupyter Notebook (see above) and navigate to the folder where you stored the file.\nClick on the .ipynb file and then it should open in a new tab of the browser.\n\n\n\n\n\n\n\nWARNING about files on university computer\n\n\n\nIf you store a file on a (TiU) university computer, for example in the Downloads folder, it will typically be deleted when you log out. To avoid this, either:\n\nCopy the file onto a USB drive.\nE-mail the file to yourself.\nStore it on the M: drive (that is denoted by the drive that has your name) of the university computer, whose files are not deleted.\n\nNext time you want to use a file, put it again in the Downloads folder to work on it (and make sure to back it up properly again afterwards).\n\n\nIf you want to open a .ipynb file that is located in the M: drive of a university computer, you need to open Jupyter Notebook differently than explained above (because you cannot navigate to the M: drive if you open Jupyter Notebook via the Start menu). Instead, do the following:\n\nClose all instances of Jupyter Notebook if any are running.\nLook up the Anaconda Prompt application in the Start menu and Run it.\nType jupyter notebook --notebook-dir=M: and press Enter\nJupyter Notebook should now open in the web browser showing the files and folders of the M: drive\nOpen the desired .ipynb file to work on it.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Software</span>"
    ]
  },
  {
    "objectID": "02-installation.html#code-snippets-in-this-book",
    "href": "02-installation.html#code-snippets-in-this-book",
    "title": "2  Software",
    "section": "2.3 Code snippets in this book",
    "text": "2.3 Code snippets in this book\nIn this book, we won’t always show screenshots like we did above. Instead we will show code snippets in boxes like this:\n\n1 + 1\n\n2\n\n\nThe part that is code will be in color and there will be a small clipboard icon on the right which you can use to copy the code to paste into your own Notebook to be able to experiment with it yourself. The output from the code will always be in a separate gray box below it (without a clipboard icon).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Software</span>"
    ]
  },
  {
    "objectID": "03-basics.html",
    "href": "03-basics.html",
    "title": "3  Python basics",
    "section": "",
    "text": "3.1 Arithmetic operations\nWe start with the most basic arithmetic operations: Addition, subtraction, multiplication and division are given by the standard +, -, * and / operators that you would use in other programs like Excel. For example, addition:\n2 + 3\n\n5\nSubtraction:\n5 - 3\n\n2\nMultiplication:\n2 * 3\n\n6\nDivision:\n3 / 2\n\n1.5\nIt is also possible to do multiple operations at the same time using parentheses. For example, suppose we wanted to calculate: \n\\frac{2+4}{4 \\cdot 2} = \\frac{6}{8} = 0.75\n We can calculate this in Python as follows:\n(2 + 4) / (4 * 2)\n\n0.75\nWith the ** operator (two stars) we can raise a number to the power of another number. For example, 2^3=2\\times 2\\times 2 = 8 can be computed as\n2 ** 3\n\n8",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "03-basics.html#arithmetic-operations",
    "href": "03-basics.html#arithmetic-operations",
    "title": "3  Python basics",
    "section": "",
    "text": "WARNING\n\n\n\nDo not use ^ for exponentiation. This actually does a very different thing in Python.\n\n\n\n\n\n\n\n\nExercise 3.1\n\n\n\nCompute the following expressions using the operator +, -, *, / and **:\n\n3 + 5 \\cdot 2\n\\frac{(10 - 4)^2}{3}\n\\frac{\\left((2 + 3) \\cdot 4 - 5\\right)^2}{3 + 1}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "03-basics.html#variables",
    "href": "03-basics.html#variables",
    "title": "3  Python basics",
    "section": "3.2 Variables",
    "text": "3.2 Variables\nIn Python we can assign single numbers to variables and then work with and manipulate those variables.\nAssigning a single number to a variable is very straightforward. We put the name we want to give to the variable on the left, then use the = symbol as the assignment operator, and put the number to the right of the =. The = operator binds a number (on the right-hand size of =) to a name (on the left-hand side of =).\nTo see this at work, let’s set x=2 and y=3 and calculate x+y:\n\nx = 2\ny = 3\nx + y\n\n5\n\n\nWhen we assign x=2, in our code, the number is not fixed forever. We can assign a new number to x. For example, we can assign the number 6 to x instead. The sum of x (which is 6) and y ( which is 3), is now 9:\n\nx = 6\nx + y\n\n9\n\n\nFinally, you cannot set x=2 with the command 2 = x. That will result in an error. The name must be on the left of = and the number must be on the right of =.\n\n\n\n\n\n\nExercise 3.2\n\n\n\nDefine variables a,b,c with numbers 19, 3 and 7, respectively. Compute the following expressions:\n\na + b \\cdot c\n\\frac{(a - c)^2}{b}\n\\frac{((b + c) \\cdot a - c^2)^2}{a + b}\n\n\n\n\nIf you want to print multiple expressions within the same code snippet, you can use the print() function of Python for each of the expressions.\n\nx = 2\ny = 3\nprint(x + y)\nprint(x - y)\n\n5\n-1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "03-basics.html#lists",
    "href": "03-basics.html#lists",
    "title": "3  Python basics",
    "section": "3.3 Lists",
    "text": "3.3 Lists\nWe can also store multiple variables in one object, a so-called list. A list with numbers is created by writing down a sequence of numbers, separated by commas, in between two brackets [ and ].\n\nz = [3, 9, 1, 7]\nz\n\n[3, 9, 1, 7]\n\n\nWe can also create lists with fractional numbers.\n\nz = [3.1, 9, 1.9, 7]\nz\n\n[3.1, 9, 1.9, 7]\n\n\nTo access the numbers in the list, we can index the list at the position of interest. If we want to get the number at position i in the list, we use the syntax z[i].\n\nz[1]\n\n9\n\n\nSomething strange is happening here… The left-most number in the list is 3.1, but z[1] returns 9. This happens because Python actually starts counting at index 0 (instead of 1).\n\n\n\n\n\n\nIndexing convention in Python\n\n\n\nThe left-most number in a Python list is located at position 0. The number next to that at position 1, etc. That is, the i-th number in a list with n numbers can be found at position i - 1 for i = 1,\\dots,n\n\n\nIn other words, the “first” number in the list is located at position 0, and we can access it using z[0] instead.\nBelow we index the number of the list at positions i \\in \\{0,1,2,3\\} separately.\n\nz[0]\n\n3.1\n\n\n\nz[1]\n\n9\n\n\n\nz[2]\n\n1.9\n\n\n\nz[3]\n\n7\n\n\n\n\n\n\n\n\nExercise 3.3\n\n\n\nConsider the list a = [11, 41, 12, 35, 6, 33, 7].\n\nCompute the sum of the numbers at even positions in a (i.e., positions 0, 2, 4, and 6).\nCompute the result of multiplying the first and last elements of a, then subtracting the middle element.\nCompute the square of the element at position 2, divided by the sum of the elements at the odd positions.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "03-basics.html#for-loop",
    "href": "03-basics.html#for-loop",
    "title": "3  Python basics",
    "section": "3.4 For-loop",
    "text": "3.4 For-loop\nSuppose we want to compute the sum of the numbers in the list a of Exercise 3.3. We could do this manually by indexing every number and adding them one by one.\n\na = [1, 4, 2, 5, 6, 3, 7]\n\na[0] + a[1] + a[2] + a[3] + a[4] + a[5] + a[6]\n\n28\n\n\n In fact, we can also define a new variable to store this number in. Let us call this variable total_sum.\n\na = [1, 4, 2, 5, 6, 3, 7]\n\ntotal_sum = a[0] + a[1] + a[2] + a[3] + a[4] + a[5] + a[6]\ntotal_sum\n\n28\n\n\n If the list is a is very long, for example containing thousands of elements, then it becomes very tedious to compute the total sum with the approach above. Such long lists are not uncommon in real-life data.\nA much better way is to use a for-loop, which lets us go through each element in the list one at a time. Here’s how we could compute the sum of the numbers in the list a using a for-loop:\n\na = [1, 4, 2, 5, 6, 3, 7]\ntotal_sum = 0\n\nfor i in [0,1,2,3,4,5,6]:\n    total_sum = total_sum + a[i]\n\nprint(total_sum)\n\n28\n\n\nLet’s break down what is happening here.\n\nWe first define the list a = [1, 4, 2, 5, 6, 3, 7].\nWe define the variable total_sum with initial value 0. This variable will be the running total of the numbers in a that we are adding up.  After the full code has been executed, this variable will contain the sum of all numbers in a, and its value is printed at the end using print(total_sum).\nThe line for i in [0,1,2,3,4,5,6]: indicates that we want to carry out a piece of code multiple times with different values for the variable i.\n\nThe words for and in are Python keywords, meaning they have a very specific purpose in Python. They get a different color when you type them in a code block.\nNote that the line should end with a colon :.\n\nThe piece of code that has to be run multiple times for i \\in \\{0,1,2,3,4,5,6\\} is total_sum = total_sum + a[i]. \n\nFor Python to understand that total_sum = total_sum + a[i] has to be executed with different values for i, we indent this line (using Tab on the keyboard).\nWe overwrite the value of total_sum with its current value plus the number at position i in a, i.e., the number a[i]. In the table below this process is illustrated for all the values of i.\n\n\n\n\n\ni\na[i]\ntotal_sum after this iteration\n\n\n\n\n0\n1\n0 + 1 = 1\n\n\n1\n4\n1 + 4 = 5\n\n\n2\n2\n5 + 2 = 7\n\n\n3\n5\n7 + 5 = 12\n\n\n4\n6\n12 + 6 = 18\n\n\n5\n3\n18 + 3 = 21\n\n\n6\n7\n21 + 7 = 28\n\n\n\nIn the first iteration of the for-loop (i = 0), we have the initial number 0 for total_sum so adding a[0] results in a new value of total_sum being 0 + 1 = 1.\nIn the second iteration, with now total_sum equal to 1, we add the number a[1], which results in the new value of total_sum being 1 (current number of total_sum) plus a[1] (which is 4), resulting in a new running total of 1 + 4 = 5.\nIf we would be interested in only computing, e.g., the sum of the first three numbers in a, we could replace the index list [0,1,2,3,4,5,6] by [0,1,2].\n\na = [1, 4, 2, 5, 6, 3, 7]\ntotal_sum = 0\n\nfor i in [0,1,2]:\n    total_sum = total_sum + a[i]\n\ntotal_sum\n\n7\n\n\n\n\n\n\n\n\nExercise 3.4\n\n\n\nCreate the list a = [1, 4, 2, 5, 6, 3, 7].\n\nCompute the sum of the numbers at the even indices using a for-loop.\nCompute the product of the numbers in a using a for-loop.\n\n\n\nIf you want to execute more lines of code in every iteration of the for-loop, you should indent all of them. In the code below we compute the running total total_sum and also use the print() command of Python to print the value of the running total after every addition. This results in all the values in the right column of the above table being printed.\n\na = [1, 4, 2, 5, 6, 99, 3]\ntotal_sum = 0\n\nfor i in [0,1,2,3,4,5,6]:\n    total_sum = total_sum + a[i]\n    print(total_sum)\n\n1\n5\n7\n12\n18\n117\n120\n\n\nOne final note to make is that this approach might still require a lot of typing if the list a contains many values. For example, if we are given a list of a thousand values, we would have to type a list with values 0 through 999 in the for-loop above.\nThere is a way to do this quicker, by using the range() function in Python. If we instead use the line for i in range(7):, then Python executes the indented code below for the values i = 0,1,2,3,4,5,6. Note that i = 7 is not included!\nIn general using for i in range(n): executes the indented lines below for the (in total n) values i = 0,1,2,\\dots,n-1.\n\na = [1, 4, 2, 5, 6, 99, 3]\ntotal_sum = 0\n\nfor i in range(7):\n    total_sum = total_sum + a[i]\n    print(total_sum)\n\n1\n5\n7\n12\n18\n117\n120",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "03-basics.html#conditional-statements",
    "href": "03-basics.html#conditional-statements",
    "title": "3  Python basics",
    "section": "3.5 Conditional statements",
    "text": "3.5 Conditional statements\nIn many programming situations, we want the computer to make decisions based on certain conditions. For example, if a number is negative, we might want to handle it differently than if it were positive. In Python, we can do this using conditional statements, also known as if/else statements.\nLet’s look at a basic example. We first make a general remark about printing text in Python.\n\n\n\n\n\n\nPrinting text\n\n\n\nIf you want to print text in Python, you should put it in between quotation marks.\n\nprint(\"Hello world\")\n\nHello world\n\n\nIf you want to print both text and variables, you can do that in the same print() command separating them with a comma.\n\nx = 3\nprint(\"The value of x is\", x)\n\nThe value of x is 3\n\n\nNote that in \"The value of x is\" part, the x-symbol is interpreted merely as a letter, not a variable.\n\n\nNow let us look at an example.\n\nx = 5\n\nif x &gt; 0:\n    print(\"x is positive\")\nelse:\n    print(\"x is not positive\")\n\nx is positive\n\n\nHere is what this code does:\n\nx = 5 assigns the number 5 to the variable x.\nif x &gt; 0: checks whether x is greater than zero, i.e, Python checks whether the condition x &gt; 0 is true or false. If the condition is true, it executes the indented code below, which is a print-statement in this case. Python then no longer checks the else: statement.\nIf the condition is false (i.e., x \\leq 0), then Python executes the indented code under else:, which is a different print-statement in this case.\n\nWe can also have multiple conditions using elif, which stands for “else if”. Below we add the third statement that checks if x is precisely equal to zero. Also here, as soon as Python reaches a statement that is true, it does not check the remaining statements anymore.\n\nx = 0\n\nif x &gt; 0:\n    print(\"x is positive\")\nelif x == 0:\n    print(\"x is zero\")\nelse:\n    print(\"x is negative\")\n\nx is zero\n\n\nIn the code above, we use the syntax x == 0 to define the statement that checks whether x is precisely equal to 0. You should not use x = 0 (otherwise Python would confuse this with assigning a value of 0 to the variable x, which is not what we want).\nThis checks the conditions one by one from top to bottom and executes the first indented code block where the condition is true. If you want more than three conditions, you should start with an if statement, then elif statements, and finish with an else.\nFinally, if you want to execute multiple lines of code for one or more of the conditions, you should indent all those lines under the respective conditions.\n\nx = 1\n\nif x &gt; 0:\n    print(\"x is positive\")\n    print(x)\nelif x == 0:\n    print(\"x is zero\")\nelse:\n    print(\"x is negative\")\n    print(x)\n\nx is positive\n1\n\n\n\n\n\n\n\n\nExercise 3.5\n\n\n\nCreate the list a = [1, 4, -4, 0, 5, -3, -7] in Python.\nUse a for-loop in combination with the code above to check for every number in a whether it is positive, zero, or negative. If a number is positive you should print the message \"The number is positive\", if it is zero \"The number is zero\" and if it is negative \"The number is negative\".\nThe output of your piece of code should be as follows.\n\n\nThe number is positive\nThe number is positive\nThe number is negative\nThe number is zero\nThe number is positive\nThe number is negative\nThe number is negative\n\n\n\n\nLet us now look at an example from mathematics. Suppose we want to compute the roots x of a quadratic equation of the form: \nax^2 + bx + c = 0\n Here a,b and c are known given numbers, and the goal is to find one or more x’s that satisfy the above equation.\nThe solution(s) to this problam are given by the quadratic formula (Dutch: abc-formule): \nx = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\n\nHere \\pm means that one solution is given by choosing a plus symbol in the place of \\pm, and the other solution by choosing the minus symbol.\nThe expression under the square root, called the discriminant D = b^2 - 4ac, determines how many (real) roots exist:\n\nIf D &gt; 0, the equation has two real roots.\nIf D = 0, the equation has exactly one real root.\nIf D &lt; 0, there are no (real) roots.\n\n\n\n\n\n\n\nExercise 3.6\n\n\n\nCreate variables a = 3, b = 2 and c = -1. Create a variable D for the discriminant (in terms of a,b and c).\n\nUse conditional statements to determine how many roots the quadratic formula ax^2 + bx + c has, based on the three possibilities for the discriminant. For each possibility, print an appropriate message in the indented code block. For the chosen a,b and c, the function has two roots (so this case should be printed in your code). \nUse conditional statements to print the roots x of the quadratic formula ax^2 + bx + c, based on the three possibilities for the discriminant (in the third case, do not print the roots, but a message saying there are no roots). Hint: If you want to print two variables y and z you can use print(y,z) or use print(y) and print(z) on different indented lines.  For the chosen a,b and c, your output should show the roots -1 and 0.333 (possibly with more or less decimals).\n\n\nYou can play around with your code by choosing different numbers for a,b and c, and see if you get different output cases for both questions above.\n\n\n\n\n\n\n\n\nExercise 3.7\n\n\n\nCreate the lists a = [3,7,1,4], b = [2,7,4,4] and c = [11,3,0,1]. Write a for-loop that executes your code of Exercise 3.6(ii) for every combination (a_i,b_i,c_i) where a_i,b_i,c_i are the numbers at position i in the lists a,b,c, respectively, for i = 0,1,2,3.\nYour output should look like this.\n\n\nThe formula has no real roots\nThe formula has no real roots\n-4.0 0.0\n-0.5\n\n\n\n\n\n\n\n\n\n\nExercise 3.8 (bonus)\n\n\n\nSuppose we are given a list g = [9.1, 1.3, 5.4, 5.6, 5.74, 6.74, 8.25, 9.2, 7.1, 6.9] of student grades.\n\nWrite a Python code that rounds every grade to the nearest half integer, i.e., to the value in the set \\{0, 0.5,1, 1.5,2,2.5,\\dots,8,8.5,9,9.5,10\\} it is closest to, and print this value. Hint: You can round a number to its closest integer by using the round() function. For example round(5.3) gives 5, and round(5.9) gives 6. Think of a way to use the round() function to round to half integers.\n\nOn g as given, the output should be as follows.\n\n\n9.0\n1.5\n5.5\n5.5\n5.5\n6.5\n8.0\n9.0\n7.0\n7.0\n\n\n\nAdjust your code so that grades that lie in the interval (5,6) are rounded either up to 6 or down to 5 depending which of the two a number is closest to (in other words, rounding to 5.5 is no longer allowed). Hint: You can use the and keyword to check multiple conditions in an if-statement.\n\nOn g as given, the output should be as follows.\n\n\n9.0\n1.5\n5\n6\n6\n6.5\n8.0\n9.0\n7.0\n7.0\n\n\nThe latter procedure is in fact how your grades in the EOR bachelor program are rounded.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python basics</span>"
    ]
  },
  {
    "objectID": "04-math-basics.html",
    "href": "04-math-basics.html",
    "title": "4  Math basics",
    "section": "",
    "text": "4.1 Python function\nIf we want to compute a certain mathematical expression for many different variables, it is often convenient to use a Python function for this.\nFor example, consider the quadratic function f(x) = x^2 + 2x^2 -1. Say we want to know the values of f(-3), f(-2.5), f(1) and f(4). What we would like to do is to ‘automate’ the computation of a function value, so that we do not have to write out the whole function everytime.\nFor this we can use a Python function for this as follows.\ndef f(x):\n    return x**2 + 2*x - 1\nWhat does the code above do? First of all the syntax to tell Python we want to define a function called f that takes as input a number x is def f(x):.\nWe next have to tell Python what the function is supposed to compute. On the second line, with one tab indented, we have the return statement. Here we write down the expression that the function should return (or compute), which in our case is the function value f(x) = x^2 + 2x^2 -1.\nWe can now compute the function value f(x) for any value of x. What happens is that Python calls the function f with input the chosen value of x, and then returns the function value f(x), i.e., the expression in the return statement.\nf(-2)\n\n-1\nf(1)\n\n2\nNote that you can also name the function differently, for example we could also have done def quadratic_function(x):. You should then use the name quadratic_function too in the command well you call the Python function to compute the function value f(x).\ndef quadratic_function(x):\n    return x**2 + 2*x - 1\n    \nquadratic_function(1)\n\n2\nJust as your graphing calculator we can plot a Python function, search for its roots, integrate a certain area under the curve and much more! More advanced tasks that Python can handle will introduced in later courses in the EOR bachelor program.\nIf you want to get a better understanding of the codes in the coming sections, you could already have a look at Chapter 9 of this course document of another course taught at the Tilburg School of Economics and Management. We do not explain the code here, but give it as a teaser what more is possible with Python!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Math basics</span>"
    ]
  },
  {
    "objectID": "04-math-basics.html#plotting",
    "href": "04-math-basics.html#plotting",
    "title": "4  Math basics",
    "section": "4.2 Plotting",
    "text": "4.2 Plotting\nConsider again the function f(x) = x^2 + 2x - 1. A visualization of this function is given below. If you want to plot a function in Python you have to make use of functionality from NumPy and Matplotlib which are so-called Python packages.\nPackages are functions written by other people to make our live easy, i.e., so that we do not have to write every code file from scratch in Python.\n\n\n\nShow code generating the plot below\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the x range\nx = np.linspace(-3, 3, 600)\n\n# Define the function f\ndef f(x):\n    return x**2 + 2*x -1\n\n# Create the plot\nplt.figure(figsize=(6, 4))\nplt.plot(x, f(x), label='$f(x) = x^2 + 2x - 1$')\n\n# Add labels and title\nplt.title('Plot of the function f on the interval [-3,3]')\nplt.xlabel('x')\nplt.ylabel('f(x)')\n\n# Add a grid\nplt.grid(True)\n\n# Set range\nplt.xlim(-3,3)\nplt.ylim(-4,14)\n\n# Add a legend\nplt.legend()\n\n# Show the plot\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Math basics</span>"
    ]
  },
  {
    "objectID": "04-math-basics.html#root-finding",
    "href": "04-math-basics.html#root-finding",
    "title": "4  Math basics",
    "section": "4.3 Root finding",
    "text": "4.3 Root finding\nSimilarly, the SciPy package can be used to carry out various mathematical tasks and algorithms, making it very important for data analysis purposes.\nThe code below uses a pre-written Python function called fsolve() from SciPy to compute the roots of a function f. In other words, fsolve() is a mathematical algorithm for finding the root of a function, such as Newton’s method, that someone implemented in Python and made available publicly for the whole world to use. If you are interested in the source code of this function, you can look it up in the documentation of Python (more specifically, SciPy in this case).\n\nimport scipy.optimize as optimize\n\ndef f(x):\n    return x**2 + 2*x - 1\n\nguess = 3\nf_zero = optimize.fsolve(f,guess) \n\nprint(\"A root of the function f is given by\", f_zero)\n\nA root of the function f is given by [0.41421356]\n\n\nThe function fsolve() takes two inputs: a function of which we want to find a root, and an initial guess (3 in our case) of where the root is.\nEntering an initial guess for where the root is located, is in some sense the equivalent of giving a bracket in which the root should lie on your graphing calculator. In fact, there are other root finding functions available in Python that work in this way, i.e., that require you to give an initial bracket, just as you do on your graphing calculator.\nDifferent initial guesses might lead to different roots found by Python. In fact, as you can see the function f has two roots of which the above code finds the right one. We could find the left root by filling in a different initial guess, e.g., -3 instead of 3.\n\nguess = -3\nf_zero = optimize.fsolve(f,guess) \n\nprint(\"A root of the function f is given by\", f_zero)\n\nA root of the function f is given by [-2.41421356]",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Math basics</span>"
    ]
  },
  {
    "objectID": "04-math-basics.html#integration",
    "href": "04-math-basics.html#integration",
    "title": "4  Math basics",
    "section": "4.4 Integration",
    "text": "4.4 Integration\nFinally, it is also possible to use built-in functionality from SciPy to integrate a function. Below we integrate the function f from 0 to 2. This integral area is illustrated in the figure below.\n\n\n\nShow code generating the plot below\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the x range for the full plot\nx = np.linspace(-3, 3, 600)\n\n# Define the function f\ndef f(x):\n    return x**2 + 2*x - 1\n\n# Create the plot\nplt.figure(figsize=(6, 4))\nplt.plot(x, f(x), label='$f(x) = x^2 + 2x - 1$')\n\n# Define the interval for shading (0 to 2)\nx_fill = np.linspace(0, 2, 300)\nplt.fill_between(x_fill, f(x_fill), alpha=0.3, color='orange', \n    label='Area under $f(x)$ from 0 to 2')\n\n# Add labels and title\nplt.title('Plot of function $f$ and shaded integral area from 0 to 2')\nplt.xlabel('x')\nplt.ylabel('f(x)')\n\n# Add a grid\nplt.grid(True)\n\n# Set axis limits\nplt.xlim(-3, 3)\nplt.ylim(-4, 14)\n\n# Add a legend\nplt.legend()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n\nfrom scipy.integrate import quad\n\n# Define the function to integrate\ndef f(x):\n    return x**2 + 2*x - 1\n\n# Perform the integration from 0 to 2\nresult, error = quad(f, 0, 2)\n\n# Print the result\nprint(\"Integral of f(x) from 0 to 2 is:\", result)\nprint(\"Numerical error in integral computation is at most\", error)\n\nIntegral of f(x) from 0 to 2 is: 4.666666666666666\nNumerical error in integral computation is at most 5.666271351443603e-14",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Math basics</span>"
    ]
  },
  {
    "objectID": "04-math-basics.html#why-python-and-not-my-calculator",
    "href": "04-math-basics.html#why-python-and-not-my-calculator",
    "title": "4  Math basics",
    "section": "4.5 Why Python and not my calculator?",
    "text": "4.5 Why Python and not my calculator?\nSo far we have illustrated task with Python that you graphing calculator can also carry out. The advantage of Python is that it can handle much more complicated computing tasks and handle much more difficult mathematical functions, that your graphing calculator is not able to handle.\nMany of these tasks you will come across in various courses of the EOR bachelor program, already starting with the course Linear Optimization in the second quartile of year 1.\nFurthermore, throught the EOR bachelor program you will also see some other programming languages such as R and Matlab. Many of the general programming ideas, such as for-loops and conditional statements, exist in those languages as well, but sometimes the syntax (i.e., the grammar of the programming language) is different than that of Python.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Math basics</span>"
    ]
  }
]